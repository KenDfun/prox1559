Disassembly Listing for MTCH1559 Evaluation Board Source
Generated From:
/Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/project.X/dist/PIC16LF1559/production/project.X.production.elf
May 21, 2015 10:50:11 AM

---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/uart.c  
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            
37:            #include <xc.h>
38:            #include <stdint.h>
39:            
40:            #include "configuration.h"
41:            #include "uart.h"
42:            #include "memory.h"
43:            
44:            enum UART_STATES
45:            {
46:                UART_STATE_idle = 0,
47:                UART_STATE_read,
48:                UART_STATE_write
49:            };
50:            
51:            void    UART_SendChar_Hex(uint8_t value);
52:            uint8_t UART_HexToBinary(uint8_t* data);
53:            
54:            void UART_Init(void)
55:            {
56:            #if defined(UART_ENABLED)
57:                TRISBbits.TRISB7 = 1;
0BF5  178D     BSF PORTB, 0x7
58:                TXSTA   = 0b00100100;
0BF6  3024     MOVLW 0x24
0BF7  0023     MOVLB 0x3
0BF8  009E     MOVWF TXSTA
59:                RCSTA   = 0b10000000;
0BF9  3080     MOVLW 0x80
0BFA  009D     MOVWF RCSTA
60:                BAUDCON = 0b00001000;
0BFB  3008     MOVLW 0x8
0BFC  009F     MOVWF BAUDCON
61:                SPBRG   = 68;           /* 115200 @ 32MHz Fosc */
0BFD  3044     MOVLW 0x44
0BFE  009B     MOVWF SPBRG
0BFF  019C     CLRF SPBRGH
62:            #endif
63:            }
0C00  0008     RETURN
64:            
65:            void UART_SendSignedLong(int32_t value)
66:            {
67:                uint8_t d = (uint8_t)0;
68:            
69:                if (value < 0)
70:                {
71:                    UART_PutChar('-');
72:                    value = ~value;
73:                    value++;
74:                }
75:                else
76:                    UART_PutChar(' ');
77:            
78:                while (value >= (int32_t)1000000000) { value -= (int32_t)1000000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
79:                while (value >= (int32_t) 100000000) { value -= (int32_t) 100000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
80:                while (value >= (int32_t)  10000000) { value -= (int32_t)  10000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
81:                while (value >= (int32_t)   1000000) { value -= (int32_t)   1000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
82:                while (value >= (int32_t)    100000) { value -= (int32_t)    100000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
83:                while (value >= (int32_t)     10000) { value -= (int32_t)     10000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
84:                while (value >= (int32_t)      1000) { value -= (int32_t)      1000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
85:                while (value >= (int32_t)       100) { value -= (int32_t)       100; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
86:                while (value >= (int32_t)        10) { value -= (int32_t)        10; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
87:                while (value >= (int32_t)         1) { value -= (int32_t)         1; d++; } UART_PutChar(d + (uint8_t)0x30);
88:                UART_PutChar((uint8_t)UART_DELIMITER);
89:            }
90:            
91:            void UART_SendLong(uint32_t value)
92:            {
93:                uint8_t d = (uint8_t)0;
94:            
95:                while (value >= (uint32_t)1000000000) { value -= (uint32_t)1000000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
96:                while (value >= (uint32_t) 100000000) { value -= (uint32_t) 100000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
97:                while (value >= (uint32_t)  10000000) { value -= (uint32_t)  10000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
98:                while (value >= (uint32_t)   1000000) { value -= (uint32_t)   1000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
99:                while (value >= (uint32_t)    100000) { value -= (uint32_t)    100000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
100:               while (value >= (uint32_t)     10000) { value -= (uint32_t)     10000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
101:               while (value >= (uint32_t)      1000) { value -= (uint32_t)      1000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
102:               while (value >= (uint32_t)       100) { value -= (uint32_t)       100; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
103:               while (value >= (uint32_t)        10) { value -= (uint32_t)        10; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
104:               while (value >= (uint32_t)         1) { value -= (uint32_t)         1; d++; } UART_PutChar(d + (uint8_t)0x30);
105:               UART_PutChar((uint8_t)UART_DELIMITER);
106:           }
107:           
108:           void UART_SendShortLong(uint24_t value)
109:           {
110:               uint8_t d = (uint8_t)0;
111:           
112:               while (value >= (uint24_t)10000000) { value -= (uint24_t)10000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
113:               while (value >= (uint24_t) 1000000) { value -= (uint24_t) 1000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
114:               while (value >= (uint24_t)  100000) { value -= (uint24_t)  100000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
115:               while (value >= (uint24_t)   10000) { value -= (uint24_t)   10000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
116:               while (value >= (uint24_t)    1000) { value -= (uint24_t)    1000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
117:               while (value >= (uint24_t)     100) { value -= (uint24_t)     100; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
118:               while (value >= (uint24_t)      10) { value -= (uint24_t)      10; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
119:               while (value >= (uint24_t)       1) { value -= (uint24_t)       1; d++; } UART_PutChar(d + (uint8_t)0x30);
120:               UART_PutChar((uint8_t)UART_DELIMITER);
121:           }
122:           
123:           void UART_SendSignedShortLong(int24_t value)
124:           {
125:               uint8_t d = (uint8_t)0;
126:           
127:               if (value < 0)
128:               {
129:                   UART_PutChar('-');
130:                   value = ~value;
131:                   value++;
132:               }
133:               else
134:                   UART_PutChar(' ');
135:           
136:               while (value >= (int24_t)1000000) { value -= (int24_t)1000000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
137:               while (value >= (int24_t) 100000) { value -= (int24_t) 100000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
138:               while (value >= (int24_t)  10000) { value -= (int24_t)  10000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
139:               while (value >= (int24_t)   1000) { value -= (int24_t)   1000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
140:               while (value >= (int24_t)    100) { value -= (int24_t)    100; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
141:               while (value >= (int24_t)     10) { value -= (int24_t)     10; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
142:               while (value >= (int24_t)      1) { value -= (int24_t)      1; d++; } UART_PutChar(d + (uint8_t)0x30);
143:               UART_PutChar((uint8_t)UART_DELIMITER);
144:           }
145:           
146:           void UART_SendInt(uint16_t value)
147:           {
148:               uint8_t d = (uint8_t)0;
149:           
150:               while (value >= (uint16_t)10000) { value -= (uint16_t)10000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
151:               while (value >= (uint16_t) 1000) { value -= (uint16_t) 1000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
152:               while (value >= (uint16_t)  100) { value -= (uint16_t)  100; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
153:               while (value >= (uint16_t)   10) { value -= (uint16_t)   10; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
154:               while (value >= (uint16_t)    1) { value -= (uint16_t)    1; d++; } UART_PutChar(d + (uint8_t)0x30);
155:               UART_PutChar((uint8_t)UART_DELIMITER);
156:           }
157:           
158:           void UART_SendSignedInt(int16_t value)
159:           {
160:               uint8_t d = (uint8_t)0;
161:           
162:               if (value < 0)
163:               {
164:                   UART_PutChar('-');
165:                   value = ~value;
166:                   value++;
167:               }
168:               else
169:                   UART_PutChar(' ');
170:           
171:               while (value >= (int16_t)10000) { value -= (int16_t)10000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
172:               while (value >= (int16_t) 1000) { value -= (int16_t) 1000; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
173:               while (value >= (int16_t)  100) { value -= (int16_t)  100; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
174:               while (value >= (int16_t)   10) { value -= (int16_t)   10; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
175:               while (value >= (int16_t)    1) { value -= (int16_t)    1; d++; } UART_PutChar(d + (uint8_t)0x30);
176:               UART_PutChar((uint8_t)UART_DELIMITER);
177:           }
178:           
179:           void UART_SendChar(uint8_t value)
180:           {
181:               uint8_t d = (uint8_t)0;
182:           
183:               while (value >= (uint8_t)100) { value -= (uint8_t)100; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
184:               while (value >= (uint8_t) 10) { value -= (uint8_t) 10; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
185:               while (value >= (uint8_t)  1) { value -= (uint8_t)  1; d++; } UART_PutChar(d + (uint8_t)0x30);
186:               UART_PutChar((uint8_t)UART_DELIMITER);
187:           }
188:           
189:           void UART_SendSignedChar(int8_t value)
190:           {
191:               uint8_t d = (uint8_t)0;
192:           
193:               if (value < 0)
194:               {
195:                   UART_PutChar('-');
196:                   value = ~value;
197:                   value++;
198:               }
199:               else
200:                   UART_PutChar(' ');
201:           
202:               while (value >= (int8_t)100) { value -= (int8_t)100; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
203:               while (value >= (int8_t) 10) { value -= (int8_t) 10; d++; } UART_PutChar(d + (uint8_t)0x30); d = (uint8_t)0;
204:               while (value >= (int8_t)  1) { value -= (int8_t)  1; d++; } UART_PutChar(d + (uint8_t)0x30);
205:               UART_PutChar((uint8_t)UART_DELIMITER);
206:           }
207:           
208:           #define UART_OUTPUT_NIBBLE(value, shift)                            \
209:               nibble = (uint8_t) value >> shift;                              \
210:               if (nibble <= 9) { nibble += 0x30; } else { nibble += 0x37; }   \
211:               UART_PutChar(nibble);
212:           
213:           void UART_SendChar_Hex(uint8_t value)
00E0  00F1     MOVWF 0x1F1
214:           {
215:               uint8_t nibble;
216:           
217:               UART_OUTPUT_NIBBLE(value,         4);
00E1  0E71     SWAPF 0x1F1, W
00E2  390F     ANDLW 0xF
00E3  00F2     MOVWF 0x1F2
00E4  300A     MOVLW 0xA
00E5  0272     SUBWF 0x1F2, W
00E6  1803     BTFSC 0x183, 0x0
00E7  28EA     GOTO 0xEA
00E8  3030     MOVLW 0x30
00E9  28EB     GOTO 0xEB
00EA  3037     MOVLW 0x37
00EB  07F2     ADDWF 0x1F2, F
00EC  0872     MOVF 0x1F2, W
00ED  20FD     CALL 0xFD
00EE  3180     MOVLP 0x0
218:               UART_OUTPUT_NIBBLE(value & 0x0F,  0);
00EF  0871     MOVF 0x1F1, W
00F0  00F2     MOVWF 0x1F2
00F1  300F     MOVLW 0xF
00F2  05F2     ANDWF 0x1F2, F
00F3  300A     MOVLW 0xA
00F4  0272     SUBWF 0x1F2, W
00F5  1803     BTFSC 0x183, 0x0
00F6  28F9     GOTO 0xF9
00F7  3030     MOVLW 0x30
00F8  28FA     GOTO 0xFA
00F9  3037     MOVLW 0x37
00FA  07F2     ADDWF 0x1F2, F
00FB  0872     MOVF 0x1F2, W
00FC  28FD     GOTO 0xFD
219:           }
220:           
221:           void UART_SendNewLine(void)
222:           {
223:               UART_PutChar((uint8_t)'\r');
0030  300D     MOVLW 0xD
0031  20FD     CALL 0xFD
0032  3180     MOVLP 0x0
224:               UART_PutChar((uint8_t)'\n');
0033  300A     MOVLW 0xA
0034  28FD     GOTO 0xFD
225:           }
226:           
227:           void UART_PutChar(uint8_t value)
00FD  00F0     MOVWF 0x1F0
228:           {
229:               while(PIR1bits.TXIF == 0) {}
00FE  0020     MOVLB 0x0
00FF  1E11     BTFSS PIR1, 0x4
0100  28FE     GOTO 0xFE
230:               TXREG = value;
0101  0870     MOVF __pcstackCOMMON, W
0102  0023     MOVLB 0x3
0103  009A     MOVWF TXREG
231:           }
0104  0008     RETURN
232:           
233:           
234:           void UART_Receive_Service(void)
235:           {
236:               static  uint8_t             buffer[2]           = {0,0};
237:               static  enum UART_STATES    state               = UART_STATE_idle;
238:               static  uint8_t             startAddress        = 0;
239:               static  uint8_t             first               = 0;
240:               static  uint8_t             count               = 0;
241:               static  uint8_t             readCount           = 0;
242:               static  uint8_t             i                   = 0;
243:                       uint8_t             data                = RCREG;
0035  0023     MOVLB 0x3
0036  0819     MOVF RCREG, W
0037  0020     MOVLB 0x0
0038  00A0     MOVWF __pcstackBANK0
244:           
245:               /* Overrun error detected */
246:               if (OERR)
0039  0023     MOVLB 0x3
003A  1C9D     BTFSS RCSTA, 0x1
003B  28A6     GOTO 0xA6
247:               {
248:                   CREN = 0;                                   /* Reset the UART module    */
003C  121D     BCF RCSTA, 0x4
249:                   NOP();
003D  0000     NOP
250:                   NOP();
003E  0000     NOP
251:                   CREN = 1;
003F  0023     MOVLB 0x3
0040  161D     BSF RCSTA, 0x4
252:           
253:                   UART_PutChar(UART_NACK);                    /* Send ASCII NACK to host  */
0041  3015     MOVLW 0x15
0042  20FD     CALL 0xFD
254:                   state = UART_STATE_read;
0043  0020     MOVLB 0x0
0044  01D1     CLRF state
0045  0AD1     INCF state, F
255:                   return;
0046  0008     RETURN
256:               }
257:           
258:               switch(state)
00A6  0020     MOVLB 0x0
00A7  0851     MOVF state, W
00A8  3A00     XORLW 0x0
00A9  1903     BTFSC STATUS, 0x2
00AA  2847     GOTO 0x47
00AB  3A01     XORLW 0x1
00AC  1903     BTFSC STATUS, 0x2
00AD  2857     GOTO 0x57
00AE  3A03     XORLW 0x3
00AF  1903     BTFSC STATUS, 0x2
00B0  2881     GOTO 0x81
00B1  28B2     GOTO 0xB2
259:               {
260:                   case UART_STATE_idle:
261:                       count = 0;                              /* So far, no data received */
0047  01CC     CLRF count
262:                       i     = 0;
0048  01CE     CLRF i
263:                       first = 1;                              /* First byte incoming      */
0049  01CD     CLRF first
004A  0ACD     INCF first, F
264:                       if      (data == 'W') { state = UART_STATE_write; }
004B  0820     MOVF __pcstackBANK0, W
004C  3A57     XORLW 0x57
004D  1D03     BTFSS STATUS, 0x2
004E  2852     GOTO 0x52
004F  3002     MOVLW 0x2
0050  00D1     MOVWF state
0051  0008     RETURN
265:                       else if (data == 'R') { state = UART_STATE_read;  }
0052  0820     MOVF __pcstackBANK0, W
0053  3A52     XORLW 0x52
0054  1D03     BTFSS STATUS, 0x2
0055  0008     RETURN
0056  2843     GOTO 0x43
266:                       else                  { /* Error! */              }
267:                       break;
268:           
269:                   case UART_STATE_read:                        /* Receive read byte count*/
270:                       if (data == '\n')                     /* End of a packet and start to send data to host*/
0057  0820     MOVF __pcstackBANK0, W
0058  3A0A     XORLW 0xA
0059  1D03     BTFSS STATUS, 0x2
005A  286D     GOTO 0x6D
271:                       {
272:                           for (i = 0; i < readCount; i++)
005B  01CE     CLRF i
005C  084F     MOVF readCount, W
005D  024E     SUBWF i, W
005E  1803     BTFSC STATUS, 0x0
005F  2869     GOTO 0x69
0066  0020     MOVLB 0x0
0067  0ACE     INCF i, F
0068  285C     GOTO 0x5C
273:                           {
274:                               UART_SendChar_Hex(MEMORY_Read((uint8_t)(startAddress + i)));    /* Send data */
0060  0850     MOVF startAddress, W
0061  074E     ADDWF i, W
0062  2105     CALL 0x105
0063  3180     MOVLP 0x0
0064  20E0     CALL 0xE0
0065  3180     MOVLP 0x0
275:                           }
276:                           UART_SendNewLine();
0069  2030     CALL 0x30
277:                           state = UART_STATE_idle;
006A  0020     MOVLB 0x0
006B  01D1     CLRF state
278:                       }
006C  0008     RETURN
279:                       else if (data != '\r')
006D  0820     MOVF __pcstackBANK0, W
006E  3A0D     XORLW 0xD
006F  1903     BTFSC STATUS, 0x2
0070  0008     RETURN
280:                       {
281:                           buffer[count] = data;
0071  084C     MOVF count, W
0072  3EE6     ADDLW 0xE6
0073  0086     MOVWF FSR1
0074  0187     CLRF FSR1H
0075  0820     MOVF __pcstackBANK0, W
0076  0081     MOVWF INDF1
282:                           count++;
0077  0ACC     INCF count, F
283:                           if(count == 2)
0078  084C     MOVF count, W
0079  3A02     XORLW 0x2
007A  1D03     BTFSS STATUS, 0x2
007B  0008     RETURN
284:                           {
285:                               count = 0;
007D  01CC     CLRF count
286:                               readCount = UART_HexToBinary(buffer);
007C  30E6     MOVLW 0xE6
007E  20B3     CALL 0xB3
007F  00CF     MOVWF readCount
0080  0008     RETURN
287:                           }
288:                       }
289:                       break;
290:           
291:                   case UART_STATE_write:
292:                      if      (data == '\n') { state = UART_STATE_idle; } /* End of packet */
0081  0820     MOVF __pcstackBANK0, W
0082  3A0A     XORLW 0xA
0083  1903     BTFSC STATUS, 0x2
0084  286A     GOTO 0x6A
293:                      else if (data == 'R')  { state = UART_STATE_read; } /* Read register after setting the start address */
0085  0820     MOVF __pcstackBANK0, W
0086  3A52     XORLW 0x52
0087  1903     BTFSC STATUS, 0x2
0088  2843     GOTO 0x43
294:                      else
295:                      {
296:                          buffer[count] = data;
0089  084C     MOVF count, W
008A  3EE6     ADDLW 0xE6
008B  0086     MOVWF FSR1
008C  0187     CLRF FSR1H
008D  0820     MOVF __pcstackBANK0, W
008E  0081     MOVWF INDF1
297:                          count++;
008F  0ACC     INCF count, F
298:                          if (count == 2)
0090  084C     MOVF count, W
0091  3A02     XORLW 0x2
0092  1D03     BTFSS STATUS, 0x2
0093  0008     RETURN
299:                          {
300:                               count = 0;
0095  01CC     CLRF count
301:           
302:                               if (first == 0)
0096  08CD     MOVF first, F
0097  1D03     BTFSS STATUS, 0x2
0098  28A2     GOTO 0xA2
303:                               {
304:                                   MEMORY_Write((uint8_t)(startAddress + i), UART_HexToBinary(buffer));
0094  30E6     MOVLW 0xE6
0099  20B3     CALL 0xB3
009A  00F4     MOVWF sensor
009B  0850     MOVF startAddress, W
009C  074E     ADDWF i, W
009D  3195     MOVLP 0x15
009E  2552     CALL 0x552
305:                                   i++;
009F  0020     MOVLB 0x0
00A0  0ACE     INCF i, F
306:                               }
00A1  0008     RETURN
307:                               else
308:                               {
309:                                   first = 0;
310:                                   startAddress = UART_HexToBinary(buffer);
00A2  01CD     CLRF first
00A3  20B3     CALL 0xB3
00A4  00D0     MOVWF startAddress
00A5  0008     RETURN
311:                               }
312:                          }
313:                      }
314:                      break;
315:               }
316:           }
00B2  0008     RETURN
317:           
318:           uint8_t UART_HexToBinary(uint8_t* data)
00B3  00F2     MOVWF nibble
319:           {
320:               uint8_t output = 0;
321:               
322:               if ((data[0] & 0x40) == 1) { output  = data[0] - 0x37; } /* data[0] is A-F */
00B4  0086     MOVWF FSR1
00B5  3040     MOVLW 0x40
00B6  0187     CLRF FSR1H
00B7  0501     ANDWF INDF1, W
00B8  00F0     MOVWF __pcstackCOMMON
00B9  3A01     XORLW 0x1
00BA  1D03     BTFSS STATUS, 0x2
00BB  28C1     GOTO 0xC1
00BC  0872     MOVF nibble, W
00BD  0086     MOVWF FSR1
00BE  0801     MOVF INDF1, W
00BF  3EC9     ADDLW 0xC9
00C0  28C6     GOTO 0xC6
323:               else                       { output  = data[0] - 0x30; } /* data[0] is 0-9 */
00C1  0872     MOVF nibble, W
00C2  0086     MOVWF FSR1
00C3  0187     CLRF FSR1H
00C4  0801     MOVF INDF1, W
00C5  3ED0     ADDLW 0xD0
00C6  00F1     MOVWF value
324:               
325:               output <<= 4;
00C7  30F0     MOVLW 0xF0
00C8  0EF1     SWAPF value, F
00C9  05F1     ANDWF value, F
326:               
327:               if ((data[1] & 0x40) == 1) { output += data[1] - 0x37; } /* data[0] is A-F */
00CA  0A72     INCF nibble, W
00CB  0086     MOVWF FSR1
00CC  3040     MOVLW 0x40
00CD  0187     CLRF FSR1H
00CE  0501     ANDWF INDF1, W
00CF  00F0     MOVWF __pcstackCOMMON
00D0  3A01     XORLW 0x1
00D1  1D03     BTFSS STATUS, 0x2
00D2  28D8     GOTO 0xD8
00D3  0A72     INCF nibble, W
00D4  0086     MOVWF FSR1
00D5  0801     MOVF INDF1, W
00D6  3EC9     ADDLW 0xC9
00D7  28DD     GOTO 0xDD
328:               else                       { output += data[1] - 0x30; } /* data[0] is 0-9 */
00D8  0A72     INCF nibble, W
00D9  0086     MOVWF FSR1
00DA  0187     CLRF FSR1H
00DB  0801     MOVF INDF1, W
00DC  3ED0     ADDLW 0xD0
00DD  07F1     ADDWF value, F
329:               
330:               return output;
00DE  0871     MOVF value, W
331:           }
00DF  0008     RETURN
---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/output_1559.c
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            
37:            #include <xc.h>
38:            #include <stdint.h>
39:            #include "configuration.h"
40:            #include "mtouch.h"
41:            
42:            #define TRIS_INPUT  ((uint8_t)1)
43:            #define TRIS_OUTPUT ((uint8_t)0)
44:            
45:            void MTOUCH_CALLBACK_PressOccurred(uint8_t sensor)
14CA  00A1     MOVWF divisor
46:            {
47:                #if (MTOUCH_SENSORS != 6)
48:                #warning("Output logic should be updated!")
49:                #endif
50:            
51:                switch(sensor)
14CB  2CDB     GOTO 0x4DB
14DB  0821     MOVF divisor, W
14DC  3A01     XORLW 0x1
14DD  1903     BTFSC STATUS, 0x2
14DE  2CCC     GOTO 0x4CC
14DF  3A03     XORLW 0x3
14E0  1903     BTFSC STATUS, 0x2
14E1  2CCF     GOTO 0x4CF
14E2  3A01     XORLW 0x1
14E3  1903     BTFSC STATUS, 0x2
14E4  2CD2     GOTO 0x4D2
14E5  3A07     XORLW 0x7
14E6  1903     BTFSC STATUS, 0x2
14E7  2CD5     GOTO 0x4D5
14E8  3A01     XORLW 0x1
14E9  1903     BTFSC STATUS, 0x2
14EA  2CD8     GOTO 0x4D8
14EB  2CEC     GOTO 0x4EC
52:                {
53:                    //case 0:     LED0_TRIS = TRIS_OUTPUT; break;
54:                    case 1:     LED1_TRIS = TRIS_OUTPUT; break;
14CC  0021     MOVLB 0x1
14CD  118E     BCF TRISC, 0x3
14CE  0008     RETURN
55:                    case 2:     LED2_TRIS = TRIS_OUTPUT; break;
14CF  0021     MOVLB 0x1
14D0  138E     BCF TRISC, 0x7
14D1  0008     RETURN
56:                    case 3:     LED3_TRIS = TRIS_OUTPUT; break;
14D2  0021     MOVLB 0x1
14D3  128E     BCF TRISC, 0x5
14D4  0008     RETURN
57:                    case 4:     LED4_TRIS = TRIS_OUTPUT; break;
14D5  0021     MOVLB 0x1
14D6  108C     BCF TRISA, 0x1
14D7  0008     RETURN
58:                    case 5:     LED5_TRIS = TRIS_OUTPUT; break;
14D8  0021     MOVLB 0x1
14D9  100C     BCF TRISA, 0x0
14DA  0008     RETURN
59:                    default:                             break;
60:                }
61:            }
14EC  0008     RETURN
62:            
63:            void MTOUCH_CALLBACK_ReleaseOccurred(uint8_t sensor)
0A78  00A1     MOVWF 0xA1
64:            {
65:                #if (MTOUCH_SENSORS != 6)
66:                #warning("Output logic should be updated!")
67:                #endif
68:            
69:                switch(sensor)
0A79  2A89     GOTO 0x289
0A89  0821     MOVF 0xA1, W
0A8A  3A01     XORLW 0x1
0A8B  1903     BTFSC 0x83, 0x2
0A8C  2A7A     GOTO 0x27A
0A8D  3A03     XORLW 0x3
0A8E  1903     BTFSC 0x83, 0x2
0A8F  2A7D     GOTO 0x27D
0A90  3A01     XORLW 0x1
0A91  1903     BTFSC 0x83, 0x2
0A92  2A80     GOTO 0x280
0A93  3A07     XORLW 0x7
0A94  1903     BTFSC 0x83, 0x2
0A95  2A83     GOTO 0x283
0A96  3A01     XORLW 0x1
0A97  1903     BTFSC 0x83, 0x2
0A98  2A86     GOTO 0x286
0A99  2A9A     GOTO 0x29A
70:                {
71:                    //case 0:     LED0_TRIS = TRIS_INPUT; break;
72:                    case 1:     LED1_TRIS = TRIS_INPUT; break;
0A7A  0021     MOVLB 0x1
0A7B  158E     BSF TRISC, 0x3
0A7C  0008     RETURN
73:                    case 2:     LED2_TRIS = TRIS_INPUT; break;
0A7D  0021     MOVLB 0x1
0A7E  178E     BSF TRISC, 0x7
0A7F  0008     RETURN
74:                    case 3:     LED3_TRIS = TRIS_INPUT; break;
0A80  0021     MOVLB 0x1
0A81  168E     BSF TRISC, 0x5
0A82  0008     RETURN
75:                    case 4:     LED4_TRIS = TRIS_INPUT; break;
0A83  0021     MOVLB 0x1
0A84  148C     BSF TRISA, 0x1
0A85  0008     RETURN
76:                    case 5:     LED5_TRIS = TRIS_INPUT; break;
0A86  0021     MOVLB 0x1
0A87  140C     BSF TRISA, 0x0
0A88  0008     RETURN
77:                    default:                            break;
78:                }
79:            }
0A9A  0008     RETURN
80:            
81:            #if defined(MTOUCH_SLIDER_ENABLED)
82:            void MTOUCH_CALLBACK_SliderUpdate       (void)
83:            {
84:                MTOUCH_SLIDER_t slider = MTOUCH_Slider_GetFiltered();
85:            }
86:            #endif
87:            
88:            #if defined(MTOUCH_PROXIMITY_ENABLED)
89:            void MTOUCH_CALLBACK_ProxActivated      (void)          {LED0_TRIS = TRIS_OUTPUT;}
07F5  110E     BCF TRISC, 0x2
07F6  0008     RETURN
90:            void MTOUCH_CALLBACK_ProxDeactivated    (void)          {LED0_TRIS = TRIS_INPUT;}
07F7  0021     MOVLB 0x1
91:            #endif
92:            
93:            #if defined(MTOUCH_MATRIX_ENABLED)
94:            void MTOUCH_CALLBACK_Matrix_NodePressed (uint8_t node)  {}
95:            void MTOUCH_CALLBACK_Matrix_NodeReleased(uint8_t node)  {}
96:            #endif
---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/mtouch_scan_1559.c
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            #include <xc.h>
37:            #include <stdint.h>
38:            
39:            #include "configuration.h"
40:            #include "mtouch.h"
41:            #include "hamming.h"
42:            #include "main.h"
43:            
44:            enum SCAN_HANDLER_STATUS
45:            {
46:                SCAN_HANDLER_good = 0,
47:                SCAN_HANDLER_error
48:            };
49:            
50:            // Global Variables
51:            extern  enum MTOUCH_STATE       MTOUCH_button_state             [MTOUCH_SENSORS];
52:            extern  uint24_t                MTOUCH_reading                  [MTOUCH_SENSORS];
53:            extern  MTOUCH_DELTA_t          MTOUCH_button_threshold         [MTOUCH_SENSORS];
54:            extern  uint8_t                 MTOUCH_delta_scaling            [MTOUCH_SENSORS];
55:            
56:            #if defined(CONFIGURABLE_NOISETHRESH)
57:                    int24_t                 MTOUCH_noise_threshold;
58:            #endif
59:                    uint8_t                 MTOUCH_frequency;
60:                    uint8_t                 MTOUCH_frequency_min;
61:            #if defined(CONFIGURABLE_NUMBERSAMPLES)
62:                     int8_t                 MTOUCH_numberSamples;
63:            #endif
64:                    uint8_t                 MTOUCH_addcap                   [MTOUCH_SENSORS];
65:            #if defined(CONFIGURABLE_READINGGAIN)
66:                    uint8_t                 MTOUCH_readingGain;
67:            #endif
68:            
69:            
70:            // Local Variables
71:            static uint16_t                 MTOUCH_capturedSamples          [MTOUCH_ADCS][MTOUCH_SAMPLES+1];
72:            
73:            static MTOUCH_SAMPLE_t          MTOUCH_sample                   [MTOUCH_ADCS];
74:            static uint24_t                 MTOUCH_noise                    [MTOUCH_ADCS];
75:            
76:            static uint8_t                  MTOUCH_dataReady;
77:            static  int8_t                  MTOUCH_sampleCounter;
78:            static uint8_t                  MTOUCH_readingCounter           [MTOUCH_SENSORS];
79:            static uint8_t                  MTOUCH_calibrated               [MTOUCH_SENSORS];
80:                   MTOUCH_SAMPLE_t          MTOUCH_lastSample               [MTOUCH_SENSORS];
81:            
82:            #if defined(CONFIGURABLE_SINGLERESULT)
83:                   uint16_t                 MTOUCH_singleResult             [MTOUCH_SENSORS];
84:            #endif
85:            #if defined(CONFIGURABLE_DIFFRESULT)
86:                   uint16_t                 MTOUCH_diffResult               [MTOUCH_SENSORS];
87:            #endif
88:            
89:                   MTOUCH_FLAGS_t           MTOUCH_flags;
90:            
91:                   void interrupt           ISR                             (void);
92:            static void                     Sample                          (uint8_t sensor1, uint8_t sensor2);
93:            static enum SCAN_HANDLER_STATUS Scan_Handler                    (uint8_t sensor1, uint8_t sensor2);
94:            static void                     Hamming_Handler                 (uint8_t adc,     uint8_t i);
95:            static uint8_t                  Sample_Handler                  (uint8_t adc,     uint8_t sensor);
96:            static uint8_t                  Noise_Check                     (uint8_t adc,     uint8_t sensor);
97:            static void                     Noise_Calculation               (uint8_t adc);
98:            static void                     FREQ_incrMin(void);
99:            
100:           #if defined(CONFIGURABLE_SAMPLETYPE)
101:           static uint8_t MTOUCH_Random(void);
102:           #endif
103:           
104:           void MTOUCH_Scan(void)
105:           {
106:               #if (MTOUCH_SENSORS != 6)
107:               #warning("Sample function calls should be updated!")
108:               #endif
109:           
110:               /*                             ADC1, ADC2                            */
111:               Sample(    0,    2   );
0BE4  3002     MOVLW 0x2
0BE5  0020     MOVLB 0x0
0BE6  00C2     MOVWF sensor2
0BE7  3000     MOVLW 0x0
0BE8  2401     CALL 0x401
0BE9  3188     MOVLP 0x8
112:           
113:           #if !defined(DEBUG_I2C)
114:               Sample(    3,    1   );
0BEA  0020     MOVLB 0x0
0BEB  3003     MOVLW 0x3
0BEC  01C2     CLRF sensor2
0BED  0AC2     INCF sensor2, F
0BEE  2401     CALL 0x401
0BEF  3188     MOVLP 0x8
115:           #endif
116:           
117:           #if !defined(DEBUG_UART)
118:               Sample(    4,    5   );
0BF0  3005     MOVLW 0x5
119:           #endif
120:           }
121:           
122:           void MTOUCH_Scan_Init(void)
123:           {
124:               for (uint8_t i = 0; i < MTOUCH_SENSORS; i++)
0FA4  01A1     CLRF divisor
0FBD  3006     MOVLW 0x6
0FBE  0AA1     INCF divisor, F
0FBF  0221     SUBWF divisor, W
0FC0  1C03     BTFSS STATUS, 0x0
0FC1  2FA5     GOTO 0x7A5
125:               {
126:                   MTOUCH_readingCounter   [i] = (uint8_t)0;
0FA5  0821     MOVF divisor, W
0FA6  3E57     ADDLW 0x57
0FA7  0086     MOVWF FSR1
0FA8  3001     MOVLW 0x1
0FA9  0087     MOVWF FSR1H
0FAA  0181     CLRF INDF1
127:                   MTOUCH_addcap           [i] = (uint8_t)0;
0FAB  0821     MOVF divisor, W
0FAC  3E33     ADDLW 0x33
0FAD  0086     MOVWF FSR1
0FAE  0181     CLRF INDF1
128:                   MTOUCH_calibrated       [i] = (uint8_t)0;
0FAF  0821     MOVF divisor, W
0FB0  3E4B     ADDLW 0x4B
0FB1  0086     MOVWF FSR1
0FB2  0181     CLRF INDF1
129:                   MTOUCH_lastSample       [i] = (MTOUCH_SAMPLE_t)0;
0FB3  0821     MOVF divisor, W
0FB4  0721     ADDWF divisor, W
0FB5  0721     ADDWF divisor, W
0FB6  3EA0     ADDLW 0xA0
0FB7  0086     MOVWF FSR1
0FB8  3000     MOVLW 0x0
0FB9  0187     CLRF FSR1H
0FBA  3FC0     MOVWI [0]FSR1
0FBB  3FC1     MOVWI [1]FSR1
0FBC  3FC2     MOVWI [2]FSR1
130:               }
131:               
132:               MTOUCH_dataReady                = (uint8_t)0;
0FC2  0021     MOVLB 0x1
0FC4  01E2     CLRF MTOUCH_dataReady
133:               MTOUCH_frequency                = (uint8_t)TMR_FREQ_MIN;
0FC3  30AA     MOVLW 0xAA
0FC5  0020     MOVLB 0x0
0FC6  00D7     MOVWF MTOUCH_frequency
134:               MTOUCH_frequency_min            = (uint8_t)TMR_FREQ_MIN;
0FC7  00D8     MOVWF MTOUCH_frequency_min
135:           
136:           #if defined(CONFIGURABLE_NOISETHRESH)
137:               MTOUCH_noise_threshold          = MTOUCH_NOISE_THRESHOLD;
0FC8  3003     MOVLW 0x3
0FC9  0021     MOVLB 0x1
0FCA  00DE     MOVWF MTOUCH_noise_threshold
0FCC  01DF     CLRF 0xDF
0FCD  01E0     CLRF 0xE0
138:           #endif
139:           #if defined(CONFIGURABLE_NUMBERSAMPLES)
140:               MTOUCH_numberSamples            = MTOUCH_SAMPLES;
0FCB  3020     MOVLW 0x20
0FCE  0020     MOVLB 0x0
0FCF  00DB     MOVWF MTOUCH_numberSamples
141:           #endif
142:           #if defined(CONFIGURABLE_READINGGAIN)
143:               MTOUCH_readingGain              = MTOUCH_READING_GAIN;
0FD0  01DF     CLRF MTOUCH_readingGain
0FD1  0ADF     INCF MTOUCH_readingGain, F
144:           #endif
145:           
146:           #if defined(CONFIGURABLE_SAMPLETYPE)
147:               MTOUCH_flags.active_nJitter = 1;
0FD2  1656     BSF MTOUCH_flags, 0x4
148:           #endif
149:           #if defined(CONFIGURABLE_GUARD)
150:               MTOUCH_flags.guard = 1;
0FD3  16D6     BSF MTOUCH_flags, 0x5
151:           #endif
152:           #if defined(CONFIGURABLE_FITLERTYPE)
153:               MTOUCH_flags.hamming_nAccumulation = 1;
154:           #endif
155:           
156:           }
0FD4  0008     RETURN
157:           
158:           void MTOUCH_Scan_ResetCalibration(uint8_t sensor)
0FF4  00A1     MOVWF divisor
1667  00F0     MOVWF __pcstackCOMMON
159:           {
160:               MTOUCH_addcap    [sensor] = 0;
0FF5  3E33     ADDLW 0x33
0FF6  0086     MOVWF FSR1
0FF7  3001     MOVLW 0x1
0FF8  0087     MOVWF FSR1H
0FF9  0181     CLRF INDF1
1668  3E33     ADDLW 0x33
1669  0086     MOVWF FSR1
166A  3001     MOVLW 0x1
166B  0087     MOVWF FSR1H
166C  0181     CLRF INDF1
161:               MTOUCH_calibrated[sensor] = 0;
0FFA  0821     MOVF divisor, W
0FFB  3E4B     ADDLW 0x4B
0FFC  0086     MOVWF FSR1
0FFD  3001     MOVLW 0x1
0FFE  0181     CLRF INDF1
166D  0870     MOVF __pcstackCOMMON, W
166E  3E4B     ADDLW 0x4B
166F  0086     MOVWF FSR1
1670  3001     MOVLW 0x1
1671  0181     CLRF INDF1
162:           }
0FFF  0008     RETURN
1672  0008     RETURN
163:           
164:           static void Sample(uint8_t sensor1, uint8_t sensor2)
0C01  0022     MOVLB 0x2
0C02  00ED     MOVWF sensor1
165:           {
166:               static const uint8_t    TMR_FREQUENCIES[4] =
167:               {
168:                   (uint8_t)TMR_FREQ_INCR0,
169:                   (uint8_t)TMR_FREQ_INCR1,
170:                   (uint8_t)TMR_FREQ_INCR2,
171:                   (uint8_t)TMR_FREQ_INCR3
172:               };
173:           
174:                       uint8_t         freq;
175:                       uint8_t         i;        
176:                       uint8_t         best_frequency                    = (uint8_t)MTOUCH_frequency;
177:                       uint24_t        best_noise                        = (uint24_t)0;
178:                       MTOUCH_SAMPLE_t best_sample      [MTOUCH_ADCS];
179:           
180:           
181:               do
182:               {
183:                   MTOUCH_dataReady = 1;
0C03  0021     MOVLB 0x1
0C04  01E2     CLRF MTOUCH_dataReady
0C05  0AE2     INCF MTOUCH_dataReady, F
184:                   
185:                   /* Perform scan */
186:                   PR2 = (uint8_t)MTOUCH_frequency;
0C06  0020     MOVLB 0x0
0C07  0857     MOVF MTOUCH_frequency, W
0C08  009B     MOVWF PR2
187:                   while(Scan_Handler(sensor1, sensor2) == SCAN_HANDLER_error);
0C09  0842     MOVF sensor2, W
0C0A  00BB     MOVWF sensor2
0C0B  0022     MOVLB 0x2
0C0C  086D     MOVF sensor1, W
0C0D  3184     MOVLP 0x4
0C0E  2400     CALL 0x400
0C0F  3188     MOVLP 0x8
0C10  3A01     XORLW 0x1
0C11  1903     BTFSC 0x103, 0x2
0C12  2C09     GOTO 0x409
188:           
189:           #if defined(CONFIGURABLE_SAMPLETYPE)
190:                   if (MTOUCH_flags.active_nJitter == 1)
0C13  1E56     BTFSS 0x156, 0x4
0C14  2D01     GOTO 0x501
191:                   {
192:           #endif
193:                       if (   (MTOUCH_calibrated[sensor1] == 0)
194:                           || (MTOUCH_calibrated[sensor2] == 0)
195:                           || (Noise_Check(0, sensor1)    != 0)
196:                           || (Noise_Check(1, sensor2)    != 0)
197:                          )
0C15  0022     MOVLB 0x2
0C16  086D     MOVF sensor1, W
0C17  3E4B     ADDLW 0x4B
0C18  0086     MOVWF 0x106
0C19  3001     MOVLW 0x1
0C1A  0087     MOVWF 0x107
0C1B  0801     MOVF 0x101, W
0C1C  3A00     XORLW 0x0
0C1D  1903     BTFSC 0x103, 0x2
0C1E  2C39     GOTO 0x439
0C1F  0020     MOVLB 0x0
0C20  0842     MOVF sensor2, W
0C21  3E4B     ADDLW 0x4B
0C22  0086     MOVWF FSR1
0C23  0801     MOVF INDF1, W
0C24  3A00     XORLW 0x0
0C25  1903     BTFSC STATUS, 0x2
0C26  2C39     GOTO 0x439
0C27  0022     MOVLB 0x2
0C28  086D     MOVF sensor1, W
0C29  0020     MOVLB 0x0
0C2A  00A1     MOVWF divisor
0C2B  3000     MOVLW 0x0
0C2C  2516     CALL 0x516
0C2D  3188     MOVLP 0x8
0C2E  3800     IORLW 0x0
0C2F  1D03     BTFSS STATUS, 0x2
0C30  2C39     GOTO 0x439
0C31  0842     MOVF sensor2, W
0C32  00A1     MOVWF divisor
0C33  3001     MOVLW 0x1
0C34  2516     CALL 0x516
0C35  3188     MOVLP 0x8
0C36  3A00     XORLW 0x0
0C37  1903     BTFSC STATUS, 0x2
0C38  2CE8     GOTO 0x4E8
198:                       {
199:                           best_frequency                    = (uint8_t)MTOUCH_frequency;
0C39  0020     MOVLB 0x0
0C3A  0857     MOVF MTOUCH_frequency, W
0C3B  0022     MOVLB 0x2
0C3C  00E1     MOVWF __pcstackBANK2
200:                           best_noise                        = (uint24_t)0;
0C3D  01E8     CLRF best_noise
0C3E  01E9     CLRF 0x169
0C3F  01EA     CLRF 0x16A
201:                           
202:                           /* Now find the best scanning frequency in case there's been a change in noise.*/
203:                           for (i = (uint8_t)0; i < (uint8_t)4; i++)
0C40  01EB     CLRF i
0CCA  3004     MOVLW 0x4
0CCB  0AEB     INCF i, F
0CCC  026B     SUBWF i, W
0CCD  1C03     BTFSS 0x103, 0x0
0CCE  2C41     GOTO 0x441
204:                           {
205:                               freq = MTOUCH_frequency + TMR_FREQUENCIES[i];
0C41  086B     MOVF i, W
0C42  3E06     ADDLW 0x6
0C43  0084     MOVWF 0x104
0C44  3098     MOVLW 0x98
0C45  1803     BTFSC 0x103, 0x0
0C46  3E01     ADDLW 0x1
0C47  0085     MOVWF 0x105
0C48  0800     MOVF 0x100, W
0C49  0020     MOVLB 0x0
0C4A  0757     ADDWF MTOUCH_frequency, W
0C4B  0022     MOVLB 0x2
0C4C  00EC     MOVWF freq
206:                               if (freq < MTOUCH_frequency_min) { freq += MTOUCH_frequency_min; }
0C4D  0020     MOVLB 0x0
0C4E  0858     MOVF MTOUCH_frequency_min, W
0C4F  0022     MOVLB 0x2
0C50  026C     SUBWF freq, W
0C51  1803     BTFSC 0x103, 0x0
0C52  2C57     GOTO 0x457
0C53  0020     MOVLB 0x0
0C54  0858     MOVF MTOUCH_frequency_min, W
0C55  0022     MOVLB 0x2
0C56  07EC     ADDWF freq, F
207:                               PR2 = freq;
0C57  086C     MOVF freq, W
0C58  0020     MOVLB 0x0
0C59  009B     MOVWF PR2
208:                               while(Scan_Handler(sensor1, sensor2) == SCAN_HANDLER_error);
0C5A  0842     MOVF sensor2, W
0C5B  00BB     MOVWF sensor2
0C5C  0022     MOVLB 0x2
0C5D  086D     MOVF sensor1, W
0C5E  3184     MOVLP 0x4
0C5F  2400     CALL 0x400
0C60  3188     MOVLP 0x8
0C61  3A01     XORLW 0x1
0C62  1903     BTFSC 0x103, 0x2
0C63  2C5A     GOTO 0x45A
209:           
210:                               if (MTOUCH_noise[0] > best_noise)
0C64  0021     MOVLB 0x1
0C65  0852     MOVF 0xD2, W
0C66  0022     MOVLB 0x2
0C67  026A     SUBWF 0x16A, W
0C68  1D03     BTFSS 0x103, 0x2
0C69  2C74     GOTO 0x474
0C6A  0021     MOVLB 0x1
0C6B  0851     MOVF 0xD1, W
0C6C  0022     MOVLB 0x2
0C6D  0269     SUBWF 0x169, W
0C6E  1D03     BTFSS 0x103, 0x2
0C6F  2C74     GOTO 0x474
0C70  0021     MOVLB 0x1
0C71  0850     MOVF MTOUCH_noise, W
0C72  0022     MOVLB 0x2
0C73  0268     SUBWF best_noise, W
0C74  1803     BTFSC 0x103, 0x0
0C75  2C99     GOTO 0x499
211:                               {
212:                                   best_sample[0]  = MTOUCH_sample[0];
0C76  0020     MOVLB 0x0
0C77  0843     MOVF MTOUCH_sample, W
0C78  0022     MOVLB 0x2
0C79  00E2     MOVWF best_sample
0C7A  0020     MOVLB 0x0
0C7B  0844     MOVF 0x44, W
0C7C  0022     MOVLB 0x2
0C7D  00E3     MOVWF 0x163
0C7E  0020     MOVLB 0x0
0C7F  0845     MOVF 0x45, W
0C80  0022     MOVLB 0x2
0C81  00E4     MOVWF 0x164
213:                                   best_sample[1]  = MTOUCH_sample[1];
0C82  3046     MOVLW 0x46
0C83  0086     MOVWF 0x106
0C84  0187     CLRF 0x107
0C85  3F40     MOVIW [0]FSR1
0C86  00E5     MOVWF 0x165
0C87  3F41     MOVIW [1]FSR1
0C88  00E6     MOVWF 0x166
0C89  3F42     MOVIW [2]FSR1
0C8A  00E7     MOVWF 0x167
214:                                   best_noise      = MTOUCH_noise[0];
0C8B  0021     MOVLB 0x1
0C8C  0850     MOVF MTOUCH_noise, W
0C8D  0022     MOVLB 0x2
0C8E  00E8     MOVWF best_noise
0C8F  0021     MOVLB 0x1
0C90  0851     MOVF 0xD1, W
0C91  0022     MOVLB 0x2
0C92  00E9     MOVWF 0x169
0C93  0021     MOVLB 0x1
0C94  0852     MOVF 0xD2, W
0C95  0022     MOVLB 0x2
0C96  00EA     MOVWF 0x16A
215:                                   best_frequency  = freq;
0C97  086C     MOVF freq, W
0C98  00E1     MOVWF __pcstackBANK2
216:                               }
217:                               if (MTOUCH_noise[1] > best_noise)
0C99  0021     MOVLB 0x1
0C9A  0855     MOVF 0xD5, W
0C9B  0022     MOVLB 0x2
0C9C  026A     SUBWF 0x16A, W
0C9D  1D03     BTFSS 0x103, 0x2
0C9E  2CA9     GOTO 0x4A9
0C9F  0021     MOVLB 0x1
0CA0  0854     MOVF 0xD4, W
0CA1  0022     MOVLB 0x2
0CA2  0269     SUBWF 0x169, W
0CA3  1D03     BTFSS 0x103, 0x2
0CA4  2CA9     GOTO 0x4A9
0CA5  0021     MOVLB 0x1
0CA6  0853     MOVF 0xD3, W
0CA7  0022     MOVLB 0x2
0CA8  0268     SUBWF best_noise, W
0CA9  1803     BTFSC 0x103, 0x0
0CAA  2CCA     GOTO 0x4CA
218:                               {
219:                                   best_sample[0]  = MTOUCH_sample[0];
0CAB  0020     MOVLB 0x0
0CAC  0843     MOVF MTOUCH_sample, W
0CAD  0022     MOVLB 0x2
0CAE  00E2     MOVWF best_sample
0CAF  0020     MOVLB 0x0
0CB0  0844     MOVF 0x44, W
0CB1  0022     MOVLB 0x2
0CB2  00E3     MOVWF 0x163
0CB3  0020     MOVLB 0x0
0CB4  0845     MOVF 0x45, W
0CB5  0022     MOVLB 0x2
0CB6  00E4     MOVWF 0x164
220:                                   best_sample[1]  = MTOUCH_sample[1];
0CB7  3046     MOVLW 0x46
0CB8  0086     MOVWF 0x106
0CB9  0187     CLRF 0x107
0CBA  3F40     MOVIW [0]FSR1
0CBB  00E5     MOVWF 0x165
0CBC  3F41     MOVIW [1]FSR1
0CBD  00E6     MOVWF 0x166
0CBE  3F42     MOVIW [2]FSR1
0CBF  00E7     MOVWF 0x167
221:                                   best_noise      = MTOUCH_noise[1];
0CC0  30D3     MOVLW 0xD3
0CC1  0086     MOVWF 0x106
0CC2  3F40     MOVIW [0]FSR1
0CC3  00E8     MOVWF best_noise
0CC4  3F41     MOVIW [1]FSR1
0CC5  00E9     MOVWF 0x169
0CC6  3F42     MOVIW [2]FSR1
0CC7  00EA     MOVWF 0x16A
222:                                   best_frequency  = freq;
0CC8  086C     MOVF freq, W
0CC9  00E1     MOVWF __pcstackBANK2
223:                               }
224:                           }
225:                           MTOUCH_frequency = best_frequency;
0CCF  0861     MOVF __pcstackBANK2, W
0CD0  0020     MOVLB 0x0
0CD1  00D7     MOVWF MTOUCH_frequency
226:                           MTOUCH_sample[0] = best_sample[0];
0CD2  0022     MOVLB 0x2
0CD3  0862     MOVF best_sample, W
0CD4  0020     MOVLB 0x0
0CD5  00C3     MOVWF MTOUCH_sample
0CD6  0022     MOVLB 0x2
0CD7  0863     MOVF 0x163, W
0CD8  0020     MOVLB 0x0
0CD9  00C4     MOVWF 0x44
0CDA  0022     MOVLB 0x2
0CDB  0864     MOVF 0x164, W
0CDC  0020     MOVLB 0x0
0CDD  00C5     MOVWF 0x45
227:                           MTOUCH_sample[1] = best_sample[1];
0CDE  3065     MOVLW 0x65
0CDF  0086     MOVWF FSR1
0CE0  3001     MOVLW 0x1
0CE1  0087     MOVWF FSR1H
0CE2  3F40     MOVIW [0]FSR1
0CE3  00C6     MOVWF 0x46
0CE4  3F41     MOVIW [1]FSR1
0CE5  00C7     MOVWF 0x47
0CE6  3F42     MOVIW [2]FSR1
0CE7  00C8     MOVWF 0x48
228:                       }
229:                       MTOUCH_lastSample[sensor1] = MTOUCH_sample[0]; /* Set for next time. */
0CE8  0022     MOVLB 0x2
0CE9  086D     MOVF sensor1, W
0CEA  076D     ADDWF sensor1, W
0CEB  076D     ADDWF sensor1, W
0CEC  3EA0     ADDLW 0xA0
0CED  0086     MOVWF 0x106
0CEE  0187     CLRF 0x107
0CEF  0020     MOVLB 0x0
0CF0  0843     MOVF MTOUCH_sample, W
0CF1  3FC0     MOVWI [0]FSR1
0CF2  0844     MOVF 0x44, W
0CF3  3FC1     MOVWI [1]FSR1
0CF4  0845     MOVF 0x45, W
0CF5  3FC2     MOVWI [2]FSR1
230:                       MTOUCH_lastSample[sensor2] = MTOUCH_sample[1];
0CF6  0842     MOVF sensor2, W
0CF7  0742     ADDWF sensor2, W
0CF8  0742     ADDWF sensor2, W
0CF9  3EA0     ADDLW 0xA0
0CFA  0086     MOVWF FSR1
0CFB  0846     MOVF 0x46, W
0CFC  3FC0     MOVWI [0]FSR1
0CFD  0847     MOVF 0x47, W
0CFE  3FC1     MOVWI [1]FSR1
0CFF  0848     MOVF 0x48, W
0D00  3FC2     MOVWI [2]FSR1
231:           #if defined(CONFIGURABLE_SAMPLETYPE)
232:                   }
233:           #endif
234:           
235:                   MTOUCH_dataReady &= Sample_Handler(0, sensor1);
0D01  0022     MOVLB 0x2
0D02  086D     MOVF sensor1, W
0D03  0020     MOVLB 0x0
0D04  00A6     MOVWF sign
0D05  3000     MOVLW 0x0
0D06  2577     CALL 0x577
0D07  3188     MOVLP 0x8
0D08  0021     MOVLB 0x1
0D09  05E2     ANDWF MTOUCH_dataReady, F
236:                   MTOUCH_dataReady &= Sample_Handler(1, sensor2);
0D0A  0020     MOVLB 0x0
0D0B  0842     MOVF sensor2, W
0D0C  00A6     MOVWF sign
0D0D  3001     MOVLW 0x1
0D0E  2577     CALL 0x577
0D0F  3188     MOVLP 0x8
0D10  0021     MOVLB 0x1
0D11  05E2     ANDWF MTOUCH_dataReady, F
237:           
238:               /* If the reading is not yet initialized, repeat this scan a few times
239:                * until it has had an opportunity to settle. */
240:               } while (MTOUCH_dataReady == (uint8_t)0);
0D12  0862     MOVF MTOUCH_dataReady, W
0D13  1D03     BTFSS 0x83, 0x2
0D15  2C03     GOTO 0x403
241:           }
0D14  0008     RETURN
242:           
243:           static uint8_t Noise_Check(uint8_t adc, uint8_t sensor)
0D16  00A5     MOVWF 0xA5
244:           {
245:               int24_t delta;
246:               int24_t threshold   = MTOUCH_button_threshold[sensor];
0D17  0821     MOVF 0xA1, W
0D18  3EE8     ADDLW 0xE8
0D19  0086     MOVWF 0x86
0D1A  0187     CLRF 0x87
0D1B  0801     MOVF 0x81, W
0D1C  00A2     MOVWF 0xA2
0D1D  3000     MOVLW 0x0
0D1E  1BA2     BTFSC 0xA2, 0x7
0D1F  30FF     MOVLW 0xFF
0D20  00A3     MOVWF 0xA3
0D21  00A4     MOVWF 0xA4
0D22  0822     MOVF 0xA2, W
0D23  00A6     MOVWF 0xA6
0D24  0823     MOVF 0xA3, W
0D25  00A7     MOVWF 0xA7
0D26  0824     MOVF 0xA4, W
0D27  00A8     MOVWF 0xA8
247:                       threshold <<= MTOUCH_delta_scaling[sensor];
0D28  0821     MOVF 0xA1, W
0D29  3ECA     ADDLW 0xCA
0D2A  0086     MOVWF 0x86
0D2B  0A01     INCF 0x81, W
0D2C  2D30     GOTO 0x530
0D2D  35A6     LSLF 0xA6, F
0D2E  0DA7     RLF 0xA7, F
0D2F  0DA8     RLF 0xA8, F
0D30  0B89     DECFSZ 0x89, F
0D31  2D2D     GOTO 0x52D
248:                       threshold >>= MTOUCH_READING_GAIN;
0D32  37A8     ASRF 0xA8, F
0D33  0CA7     RRF 0xA7, F
0D34  0CA6     RRF 0xA6, F
249:               #if defined(CONFIGURABLE_NOISETHRESH)
250:                       threshold >>= MTOUCH_noise_threshold;
0D35  0021     MOVLB 0x1
0D36  0A5E     INCF MTOUCH_noise_threshold, W
0D37  0020     MOVLB 0x0
0D38  2D3C     GOTO 0x53C
0D39  37A8     ASRF sensor, F
0D3A  0CA7     RRF quotient, F
0D3B  0CA6     RRF sign, F
0D3C  0B89     DECFSZ WREG, F
0D3D  2D39     GOTO 0x539
251:               #else
252:                       threshold >>= MTOUCH_NOISE_THRESHOLD;
253:               #endif
254:           
255:               delta = MTOUCH_sample[adc] - MTOUCH_lastSample[sensor];
0D3E  0825     MOVF counter, W
0D3F  0725     ADDWF counter, W
0D40  0725     ADDWF counter, W
0D41  3E43     ADDLW 0x43
0D42  0086     MOVWF FSR1
0D43  0187     CLRF FSR1H
0D44  3F40     MOVIW [0]FSR1
0D45  00A9     MOVWF delta
0D46  3F41     MOVIW [1]FSR1
0D47  00AA     MOVWF dataReady
0D48  3F42     MOVIW [2]FSR1
0D49  00AB     MOVWF i
0D4A  0821     MOVF divisor, W
0D4B  0721     ADDWF divisor, W
0D4C  0721     ADDWF divisor, W
0D4D  3EA0     ADDLW 0xA0
0D4E  0086     MOVWF FSR1
0D4F  3F40     MOVIW [0]FSR1
0D50  00A2     MOVWF i
0D51  3F41     MOVIW [1]FSR1
0D52  00A3     MOVWF dividend
0D53  3F42     MOVIW [2]FSR1
0D54  00A4     MOVWF 0x24
0D55  0822     MOVF i, W
0D56  02A9     SUBWF delta, F
0D57  0823     MOVF dividend, W
0D58  3BAA     SUBWFB dataReady, F
0D59  0824     MOVF 0x24, W
0D5A  3BAB     SUBWFB i, F
256:               if (delta < 0) { delta = -delta; }
0D5B  1FAB     BTFSS i, 0x7
0D5C  2D65     GOTO 0x565
0D5D  09A9     COMF delta, F
0D5E  09AA     COMF dataReady, F
0D5F  09AB     COMF i, F
0D60  0AA9     INCF delta, F
0D61  1903     BTFSC STATUS, 0x2
0D62  0AAA     INCF dataReady, F
0D63  1903     BTFSC STATUS, 0x2
0D64  0AAB     INCF i, F
257:           
258:               #if defined(CONFIGURABLE_NOISETHRESH)
259:               return (delta > threshold) ? (uint8_t)1 : (uint8_t)0;
0D65  0828     MOVF sensor, W
0D66  3A80     XORLW 0x80
0D67  00A2     MOVWF i
0D68  082B     MOVF i, W
0D69  3A80     XORLW 0x80
0D6A  0222     SUBWF i, W
0D6B  1D03     BTFSS STATUS, 0x2
0D6C  2D73     GOTO 0x573
0D6D  082A     MOVF dataReady, W
0D6E  0227     SUBWF quotient, W
0D6F  1D03     BTFSS STATUS, 0x2
0D70  2D73     GOTO 0x573
0D71  0829     MOVF delta, W
0D72  0226     SUBWF sign, W
0D73  3000     MOVLW 0x0
0D74  1C03     BTFSS STATUS, 0x0
0D75  3001     MOVLW 0x1
260:               #else
261:               return (delta > threshold) ? (uint8_t)1 : (uint8_t)0;
262:               #endif
263:           }
0D76  0008     RETURN
264:           
265:           static uint8_t Sample_Handler(uint8_t adc, uint8_t sensor)
0D77  00AB     MOVWF i
266:           {
267:               int24_t delta;
268:               uint8_t dataReady = 0;
0D78  01AA     CLRF dataReady
269:           
270:               if (MTOUCH_calibrated[sensor] == 0)
0D79  0826     MOVF sign, W
0D7A  3E4B     ADDLW 0x4B
0D7B  0086     MOVWF FSR1
0D7C  3001     MOVLW 0x1
0D7D  0087     MOVWF FSR1H
0D7E  0881     MOVF INDF1, F
0D7F  1D03     BTFSS STATUS, 0x2
0D80  2D87     GOTO 0x587
271:               {
272:                   MTOUCH_calibrated[sensor] = 1;
0D81  0826     MOVF sign, W
0D82  3E4B     ADDLW 0x4B
0D83  0086     MOVWF FSR1
0D84  0181     CLRF INDF1
0D85  0A81     INCF INDF1, F
273:           //        if (MTOUCH_calibrated[sensor] == 0)
274:           //        {
275:           //            if (    (MTOUCH_sample[adc] < MTOUCH_ADDCAP_LIMIT_DONOTEDIT)
276:           //                 || (MTOUCH_addcap[sensor] == ADC_ADDCAP_MAX)
277:           //               )
278:           //            {
279:           //                MTOUCH_calibrated[sensor] = 1;
280:           //            }
281:           //            else
282:           //            {
283:           //                MTOUCH_addcap[sensor]++;
284:           //            }
285:           //        }
286:               }
0D86  2E03     GOTO 0x603
287:               else
288:               {
289:                   /* Integrate the latest sample with the reading through a simple IIR low
290:                    * pass filter. This smoothes the reading used to decode the sensor. */
291:                   MTOUCH_readingCounter[sensor]++;
0D87  0826     MOVF sign, W
0D88  3E57     ADDLW 0x57
0D89  0086     MOVWF FSR1
0D8A  3001     MOVLW 0x1
0D8B  0087     MOVWF FSR1H
0D8C  0A81     INCF INDF1, F
292:                   if ((MTOUCH_button_state[sensor] == MTOUCH_STATE_initializing) && (MTOUCH_readingCounter[sensor] == (uint8_t)1))
0D8D  0826     MOVF sign, W
0D8E  3E45     ADDLW 0x45
0D8F  0086     MOVWF FSR1
0D90  0881     MOVF INDF1, F
0D91  1D03     BTFSS STATUS, 0x2
0D92  2DB9     GOTO 0x5B9
0D93  0826     MOVF sign, W
0D94  3E57     ADDLW 0x57
0D95  0086     MOVWF FSR1
0D96  0B01     DECFSZ INDF1, W
0D97  2DB9     GOTO 0x5B9
293:                   {  
294:                       #if defined(CONFIGURABLE_READINGGAIN)
295:                       MTOUCH_reading[sensor] = (MTOUCH_READING_t)((MTOUCH_READING_t)((uint24_t)MTOUCH_sample[adc] << (uint8_t)MTOUCH_readingGain));
0D98  082B     MOVF i, W
0D99  072B     ADDWF i, W
0D9A  072B     ADDWF i, W
0D9B  3E43     ADDLW 0x43
0D9C  0086     MOVWF FSR1
0D9D  0187     CLRF FSR1H
0D9E  3F40     MOVIW [0]FSR1
0D9F  00A7     MOVWF quotient
0DA0  3F41     MOVIW [1]FSR1
0DA1  00A8     MOVWF sensor
0DA2  3F42     MOVIW [2]FSR1
0DA3  00A9     MOVWF delta
0DA4  0A5F     INCF MTOUCH_readingGain, W
0DA5  2DA9     GOTO 0x5A9
0DA6  35A7     LSLF quotient, F
0DA7  0DA8     RLF sensor, F
0DA8  0DA9     RLF delta, F
0DA9  0B89     DECFSZ WREG, F
0DAA  2DA6     GOTO 0x5A6
0DAB  0826     MOVF sign, W
0DAC  0726     ADDWF sign, W
0DAD  0726     ADDWF sign, W
0DAE  3ED4     ADDLW 0xD4
0DAF  0086     MOVWF FSR1
0DB0  3001     MOVLW 0x1
0DB1  0087     MOVWF FSR1H
0DB2  0827     MOVF quotient, W
0DB3  3FC0     MOVWI [0]FSR1
0DB4  0828     MOVF sensor, W
0DB5  3FC1     MOVWI [1]FSR1
0DB6  0829     MOVF delta, W
0DB7  3FC2     MOVWI [2]FSR1
296:                       #else
297:                       MTOUCH_reading[sensor] = (MTOUCH_READING_t)((MTOUCH_READING_t)((uint24_t)MTOUCH_sample[adc] << (uint8_t)MTOUCH_READING_GAIN));
298:                       #endif
299:                   }
0DB8  2E03     GOTO 0x603
300:                   else
301:                   {
302:                       delta = MTOUCH_sample[adc];
0DB9  082B     MOVF i, W
0DBA  072B     ADDWF i, W
0DBB  072B     ADDWF i, W
0DBC  3E43     ADDLW 0x43
0DBD  0086     MOVWF FSR1
0DBE  0187     CLRF FSR1H
0DBF  3F40     MOVIW [0]FSR1
0DC0  00AC     MOVWF delta
0DC1  3F41     MOVIW [1]FSR1
0DC2  00AD     MOVWF sensor
0DC3  3F42     MOVIW [2]FSR1
0DC4  00AE     MOVWF temp_data
303:                       #if defined(CONFIGURABLE_READINGGAIN)
304:                       delta -= (MTOUCH_Sensor_Reading_Get(sensor) >> (uint8_t)MTOUCH_readingGain);
0DC5  0826     MOVF sign, W
0DC6  2144     CALL 0x144
0DC7  3188     MOVLP 0x8
0DC8  0821     MOVF divisor, W
0DC9  00A7     MOVWF quotient
0DCA  0822     MOVF i, W
0DCB  00A8     MOVWF sensor
0DCC  0823     MOVF dividend, W
0DCD  00A9     MOVWF delta
0DCE  0A5F     INCF MTOUCH_readingGain, W
0DCF  2DD3     GOTO 0x5D3
0DD0  36A9     LSRF delta, F
0DD1  0CA8     RRF sensor, F
0DD2  0CA7     RRF quotient, F
0DD3  0B89     DECFSZ WREG, F
0DD4  2DD0     GOTO 0x5D0
0DD5  0827     MOVF quotient, W
0DD6  02AC     SUBWF delta, F
0DD7  0828     MOVF sensor, W
0DD8  3BAD     SUBWFB sensor, F
0DD9  0829     MOVF delta, W
0DDA  3BAE     SUBWFB temp_data, F
305:                       #else
306:                       delta -= (MTOUCH_Sensor_Reading_Get(sensor) >> (uint8_t)MTOUCH_READING_GAIN);
307:                       #endif
308:                       MTOUCH_reading[sensor] += delta;
0DDB  0826     MOVF sign, W
0DDC  0726     ADDWF sign, W
0DDD  0726     ADDWF sign, W
0DDE  3ED4     ADDLW 0xD4
0DDF  0086     MOVWF FSR1
0DE0  3001     MOVLW 0x1
0DE1  0087     MOVWF FSR1H
0DE2  082C     MOVF delta, W
0DE3  0781     ADDWF INDF1, F
0DE4  3141     ADDFSR 1, 1
0DE5  082D     MOVF sensor, W
0DE6  3D81     ADDWFC INDF1, F
0DE7  3141     ADDFSR 1, 1
0DE8  082E     MOVF temp_data, W
0DE9  3D81     ADDWFC INDF1, F
309:           
310:                       if (delta < 0) delta = -delta;
0DEA  1FAE     BTFSS temp_data, 0x7
0DEB  2DF4     GOTO 0x5F4
0DEC  09AC     COMF delta, F
0DED  09AD     COMF sensor, F
0DEE  09AE     COMF temp_data, F
0DEF  0AAC     INCF delta, F
0DF0  1903     BTFSC STATUS, 0x2
0DF1  0AAD     INCF sensor, F
0DF2  1903     BTFSC STATUS, 0x2
0DF3  0AAE     INCF temp_data, F
311:           
312:                       if (MTOUCH_readingCounter[sensor] > (uint8_t)MTOUCH_READING_RISETIME)
0DF4  0826     MOVF sign, W
0DF5  3E57     ADDLW 0x57
0DF6  0086     MOVWF FSR1
0DF7  3001     MOVLW 0x1
0DF8  0087     MOVWF FSR1H
0DF9  3004     MOVLW 0x4
0DFA  0201     SUBWF INDF1, W
0DFB  1C03     BTFSS STATUS, 0x0
0DFC  2E03     GOTO 0x603
313:                       {
314:                           MTOUCH_readingCounter[sensor]--;
0DFD  0826     MOVF sign, W
0DFE  3E57     ADDLW 0x57
0DFF  0086     MOVWF FSR1
0E00  0381     DECF INDF1, F
315:                           dataReady = (uint8_t)1;
0E01  01AA     CLRF dataReady
0E02  0AAA     INCF dataReady, F
316:                       }
317:                   }
318:               }
319:               
320:               return dataReady;
0E03  082A     MOVF dataReady, W
321:           }
0E04  0008     RETURN
322:           
323:           static enum SCAN_HANDLER_STATUS Scan_Handler(uint8_t sensor1, uint8_t sensor2)
0400  0020     MOVLB 0x0
0401  00C1     MOVWF i
324:           {
325:               static const uint8_t MTOUCH_ADCON0[MTOUCH_SENSORS] =
326:               {
327:                    ADC_SENSOR0_ADCON0
328:                   #if (MTOUCH_SENSORS > 1)
329:                   ,ADC_SENSOR1_ADCON0
330:                   #endif
331:                   #if (MTOUCH_SENSORS > 2)
332:                   ,ADC_SENSOR2_ADCON0
333:                   #endif
334:                   #if (MTOUCH_SENSORS > 3)
335:                   ,ADC_SENSOR3_ADCON0
336:                   #endif
337:                   #if (MTOUCH_SENSORS > 4)
338:                   ,ADC_SENSOR4_ADCON0
339:                   #endif
340:                   #if (MTOUCH_SENSORS > 5)
341:                   ,ADC_SENSOR5_ADCON0
342:                   #endif
343:                   #if (MTOUCH_SENSORS > 6)
344:                   #error("Edit required in MTOUCH_ADCON0 array initialization to support additional sensors.")
345:                   #endif
346:               };
347:           
348:               int8_t i;
349:           
350:               /* ADC initialization */
351:               AAD1CON0    = MTOUCH_ADCON0[sensor1];
0402  3E00     ADDLW 0x0
0403  0084     MOVWF FSR0
0404  3098     MOVLW 0x98
0405  1803     BTFSC STATUS, 0x0
0406  3E01     ADDLW 0x1
0407  0085     MOVWF FSR0H
0408  0800     MOVF INDF0, W
0409  002E     MOVLB 0xE
040A  0091     MOVWF AD1CON0
352:               AAD1CAP     = MTOUCH_addcap[sensor1];
040B  0020     MOVLB 0x0
040C  0841     MOVF i, W
040D  3E33     ADDLW 0x33
040E  0086     MOVWF FSR1
040F  3001     MOVLW 0x1
0410  0087     MOVWF FSR1H
0411  0801     MOVF INDF1, W
0412  002E     MOVLB 0xE
0413  0099     MOVWF AD1CAPCON
353:               AAD1CON2    = 0b01010000; /* TMR2 Trigger */
0414  3050     MOVLW 0x50
0415  0093     MOVWF AD1CON2
354:               AAD1CON3    = 0b01000000;
0416  3040     MOVLW 0x40
0417  0094     MOVWF AD1CON3
355:               AD1PRECON   = (uint8_t)20;
0418  3014     MOVLW 0x14
0419  0096     MOVWF AD1PRECON
356:               AD1ACQCON   = (uint8_t)6;
041A  3006     MOVLW 0x6
041B  0097     MOVWF AD1ACQCON
357:           
358:               AAD2CON0    = MTOUCH_ADCON0[sensor2];
041C  0020     MOVLB 0x0
041D  083B     MOVF sensor2, W
041E  3E00     ADDLW 0x0
041F  0084     MOVWF FSR0
0420  3098     MOVLW 0x98
0421  1803     BTFSC STATUS, 0x0
0422  3E01     ADDLW 0x1
0423  0085     MOVWF FSR0H
0424  0800     MOVF INDF0, W
0425  002F     MOVLB 0xF
0426  0091     MOVWF AD2CON0
359:               AAD2CAP     = MTOUCH_addcap[sensor2];
0427  0020     MOVLB 0x0
0428  083B     MOVF sensor2, W
0429  3E33     ADDLW 0x33
042A  0086     MOVWF FSR1
042B  0801     MOVF INDF1, W
042C  002F     MOVLB 0xF
042D  0099     MOVWF AD2CAPCON
360:               AAD2CON2    = 0b01010000; /* TMR2 Trigger */
042E  3050     MOVLW 0x50
042F  0093     MOVWF AD2CON2
361:               AAD2CON3    = 0b01000000;
0430  3040     MOVLW 0x40
0431  0094     MOVWF AD2CON3
362:               AD2PRECON   = (uint8_t)20;
0432  3014     MOVLW 0x14
0433  0096     MOVWF AD2PRECON
363:               AD2ACQCON   = (uint8_t)6;
0434  3006     MOVLW 0x6
0435  0097     MOVWF AD2ACQCON
364:           
365:               AAD2GRD = 0;
0436  0198     CLRF AD2GRD
366:           #if defined(CONFIGURABLE_GUARD)
367:               if (MTOUCH_flags.guard == 1)    { AAD1GRD= 0b01000000; }
0437  0020     MOVLB 0x0
0438  1ED6     BTFSS MTOUCH_flags, 0x5
0439  2C3E     GOTO 0x43E
043A  3040     MOVLW 0x40
043B  002E     MOVLB 0xE
043C  0098     MOVWF AD1GRD
043D  2C40     GOTO 0x440
368:               else                            { AAD1GRD= 0b00000000; }
043E  002E     MOVLB 0xE
043F  0198     CLRF AD1GRD
369:           #else
370:               AAD1GRD = 0b01100000;
371:           #endif
372:           
373:               /* Interrupt initialization */
374:               ADCOMCON                = (uint8_t)0b01010000;
0440  3050     MOVLW 0x50
0441  0092     MOVWF ADCOMCON
375:               T2CON                   = (uint8_t)0;
0442  0020     MOVLB 0x0
0443  019C     CLRF T2CON
376:           #if defined(CONFIGURABLE_NUMBERSAMPLES)
377:               MTOUCH_sampleCounter    = MTOUCH_numberSamples;
0444  085B     MOVF MTOUCH_numberSamples, W
0445  00E0     MOVWF MTOUCH_sampleCounter
378:           #else
379:               MTOUCH_sampleCounter    = (int8_t)(MTOUCH_SAMPLES);
380:           #endif
381:           
382:               MTOUCH_flags.check = (uint8_t)0;
0446  1056     BCF MTOUCH_flags, 0x0
383:               MTOUCH_flags.error = (uint8_t)0;
0447  10D6     BCF MTOUCH_flags, 0x1
384:               MTOUCH_flags.done  = (uint8_t)0;
0448  1156     BCF MTOUCH_flags, 0x2
385:               T2CONbits.TMR2ON   = (uint8_t)1;
0449  151C     BSF T2CON, 0x2
386:               do
387:               {
388:                   /* If the next ADC sample is not yet complete, then our sampling rate
389:                    * is sufficiently slow to fit our processing between samples. This is
390:                    * good. If the conversion is already complete, we will error out of
391:                    * this packet because we may be missing data. */
392:                   if      (PIR1bits.AD1IF == 0)   { MTOUCH_flags.check = 0; }
044A  1F11     BTFSS PIR1, 0x6
044B  1056     BCF MTOUCH_flags, 0x0
393:                   while   (PIR1bits.AD1IF == 0)   { }
044C  1F11     BTFSS PIR1, 0x6
044D  2C4C     GOTO 0x44C
394:                   PIR1bits.AD1IF  = 0;
044E  1311     BCF PIR1, 0x6
395:                   
396:           
397:                   AAD1CON3 ^= 0b11000000; /* Toggle precharge polarities  */
044F  30C0     MOVLW 0xC0
0450  002E     MOVLB 0xE
0451  0694     XORWF AD1CON3, F
398:                   AAD2CON3 ^= 0b11000000;
0452  002F     MOVLB 0xF
0453  0694     XORWF AD2CON3, F
399:                   AAD1GRD  ^= 0b00100000; /* Toggle guard polarity        */
0454  3020     MOVLW 0x20
0455  002E     MOVLB 0xE
0456  0698     XORWF AD1GRD, F
400:           
401:                   MTOUCH_capturedSamples[0][MTOUCH_sampleCounter] = AAD1RES0;
0457  0020     MOVLB 0x0
0458  0860     MOVF MTOUCH_sampleCounter, W
0459  00BC     MOVWF 0x3C
045A  306C     MOVLW 0x6C
045B  01BD     CLRF 0x3D
045C  35BC     LSLF 0x3C, F
045D  0DBD     RLF 0x3D, F
045E  00BE     MOVWF secondDelta
045F  3021     MOVLW 0x21
0460  00BF     MOVWF delta
0461  083C     MOVF 0x3C, W
0462  073E     ADDWF secondDelta, W
0463  0086     MOVWF FSR1
0464  083D     MOVF 0x3D, W
0465  3D3F     ADDWFC delta, W
0466  0087     MOVWF FSR1H
0467  002E     MOVLB 0xE
0468  081A     MOVF AAD1RES0, W
0469  3FC0     MOVWI [0]FSR1
046A  081B     MOVF AAD1RES0H, W
046B  3FC1     MOVWI [1]FSR1
402:                   MTOUCH_capturedSamples[1][MTOUCH_sampleCounter] = AAD2RES0;
046C  0020     MOVLB 0x0
046D  0860     MOVF MTOUCH_sampleCounter, W
046E  00BC     MOVWF 0x3C
046F  30AE     MOVLW 0xAE
0470  01BD     CLRF 0x3D
0471  35BC     LSLF 0x3C, F
0472  0DBD     RLF 0x3D, F
0473  00BE     MOVWF secondDelta
0474  3021     MOVLW 0x21
0475  00BF     MOVWF delta
0476  083C     MOVF 0x3C, W
0477  073E     ADDWF secondDelta, W
0478  0086     MOVWF FSR1
0479  083D     MOVF 0x3D, W
047A  3D3F     ADDWFC delta, W
047B  0087     MOVWF FSR1H
047C  002F     MOVLB 0xF
047D  081A     MOVF AAD2RES0, W
047E  3FC0     MOVWI [0]FSR1
047F  081B     MOVF AAD2RES0H, W
0480  3FC1     MOVWI [1]FSR1
403:           
404:                   MTOUCH_sampleCounter--;
0481  0020     MOVLB 0x0
0482  03E0     DECF MTOUCH_sampleCounter, F
405:                   if (MTOUCH_sampleCounter < (int8_t)0)
0483  1BE0     BTFSC MTOUCH_sampleCounter, 0x7
406:                   {
407:                       /* Complete packet. Perform final storage steps. */
408:                       MTOUCH_flags.done   = (uint8_t)1;
0484  1556     BSF MTOUCH_flags, 0x2
409:                   }
410:           
411:                   #if defined(CONFIGURABLE_SAMPLETYPE)
412:                   if (MTOUCH_flags.active_nJitter == 0)
0485  1A56     BTFSC MTOUCH_flags, 0x4
0486  2C9A     GOTO 0x49A
413:                   {
414:                       AD1CON0bits.ADON = 0;
0487  002E     MOVLB 0xE
0488  1011     BCF AD1CON0, 0x0
415:                       AD2CON0bits.ADON = 0;       /* Stop possible conversion. */
0489  002F     MOVLB 0xF
048A  1011     BCF AD2CON0, 0x0
416:                       T2CONbits.TMR2ON = 0;
048B  0020     MOVLB 0x0
048C  111C     BCF T2CON, 0x2
417:                       PR2 = MTOUCH_Random();      /* Randomize next TMR2 trigger. */
048D  277D     CALL 0x77D
048E  3184     MOVLP 0x4
048F  009B     MOVWF PR2
418:                       if (PR2 == 0) { PR2++; }    /* Do not allow PR2 == 0. */
0490  081B     MOVF PR2, W
0491  1903     BTFSC STATUS, 0x2
0492  0A9B     INCF PR2, F
419:                       PIR1bits.AD1IF   = 0;       /* Clear ADC flag */
0493  1311     BCF PIR1, 0x6
420:                       AD1CON0bits.ADON = 1;
0494  002E     MOVLB 0xE
0495  1411     BSF AD1CON0, 0x0
421:                       AD2CON0bits.ADON = 1;
0496  002F     MOVLB 0xF
0497  1411     BSF AD2CON0, 0x0
422:                       T2CONbits.TMR2ON = 1;       /* Begin next scanning phase. */
0498  0020     MOVLB 0x0
0499  151C     BSF T2CON, 0x2
423:                   }
424:                   #endif
425:           
426:                   if (MTOUCH_flags.check != 0)
049A  1856     BTFSC MTOUCH_flags, 0x0
427:                   {
428:                       #if defined(CONFIGURABLE_SAMPLETYPE)
429:                       if (MTOUCH_flags.active_nJitter != 0)
049B  1E56     BTFSS MTOUCH_flags, 0x4
049C  2C9F     GOTO 0x49F
430:                       {
431:                       #endif
432:                           MTOUCH_flags.error = 1;
049D  14D6     BSF MTOUCH_flags, 0x1
433:                           MTOUCH_flags.done  = 1;
049E  1556     BSF MTOUCH_flags, 0x2
434:                       #if defined(CONFIGURABLE_SAMPLETYPE)
435:                       }
436:                       #endif
437:                   }
438:                   MTOUCH_flags.check = 1;
049F  1456     BSF MTOUCH_flags, 0x0
439:           
440:               } while(MTOUCH_flags.done == 0);
04A0  1D56     BTFSS MTOUCH_flags, 0x2
04A1  2C4A     GOTO 0x44A
441:               T2CONbits.TMR2ON        = 0;
04A2  111C     BCF T2CON, 0x2
442:               AAD1CON0bits.ADON       = 0;
04A3  002E     MOVLB 0xE
04A4  1011     BCF AD1CON0, 0x0
443:               AAD2CON0bits.ADON       = 0;
04A5  002F     MOVLB 0xF
04A6  1011     BCF AD2CON0, 0x0
444:           
445:               if (MTOUCH_flags.error == 1)
04A7  0020     MOVLB 0x0
04A8  18D6     BTFSC MTOUCH_flags, 0x1
446:               {
447:                   return SCAN_HANDLER_error;
04A9  3401     RETLW 0x1
448:               }
449:           
450:               MTOUCH_sample[0] = 0;
04AB  01C3     CLRF MTOUCH_sample
04AC  01C4     CLRF 0x44
04AD  01C5     CLRF 0x45
451:               MTOUCH_sample[1] = 0;
04AE  01C6     CLRF 0x46
04AF  01C7     CLRF 0x47
04B0  01C8     CLRF 0x48
452:               #if defined(CONFIGURABLE_NUMBERSAMPLES)
453:               for (i = (int8_t)((MTOUCH_numberSamples/2)-1); i >= 0; i--)
04AA  3002     MOVLW 0x2
04B1  00A1     MOVWF divisor
04B2  01A2     CLRF i
04B3  085B     MOVF MTOUCH_numberSamples, W
04B4  00A3     MOVWF dividend
04B5  01A4     CLRF 0x24
04B6  1BA3     BTFSC dividend, 0x7
04B7  03A4     DECF 0x24, F
04B8  318A     MOVLP 0xA
04B9  229B     CALL 0x29B
04BA  3184     MOVLP 0x4
04BB  0821     MOVF divisor, W
04BC  3EFF     ADDLW 0xFF
04BD  00C0     MOVWF biggestDelta
04BE  1BC0     BTFSC biggestDelta, 0x7
04BF  2CCC     GOTO 0x4CC
04CA  03C0     DECF biggestDelta, F
04CB  2CBE     GOTO 0x4BE
454:               #else
455:               for (i = (int8_t)((MTOUCH_SAMPLES/2)-1); i >= 0; i--)
456:               #endif
457:               {
458:                   Hamming_Handler(0, i);
04C0  0840     MOVF biggestDelta, W
04C1  00AB     MOVWF i
04C2  3000     MOVLW 0x0
04C3  2551     CALL 0x551
04C4  3184     MOVLP 0x4
459:                   Hamming_Handler(1, i);
04C5  0840     MOVF biggestDelta, W
04C6  00AB     MOVWF i
04C7  3001     MOVLW 0x1
04C8  2551     CALL 0x551
04C9  3184     MOVLP 0x4
460:               }
461:           
462:               /* Calculate high pass filter output */
463:               Noise_Calculation(0);
04CC  3000     MOVLW 0x0
04CD  2701     CALL 0x701
04CE  3184     MOVLP 0x4
464:               Noise_Calculation(1);
04CF  3001     MOVLW 0x1
04D0  2701     CALL 0x701
04D1  3184     MOVLP 0x4
465:           
466:               MTOUCH_singleResult[sensor1] = MTOUCH_capturedSamples[0][0];
04D2  306C     MOVLW 0x6C
04D3  0086     MOVWF FSR1
04D4  3021     MOVLW 0x21
04D5  0087     MOVWF FSR1H
04D6  3F40     MOVIW [0]FSR1
04D7  00BC     MOVWF 0x3C
04D8  3F41     MOVIW [1]FSR1
04D9  00BD     MOVWF 0x3D
04DA  3541     LSLF i, W
04DB  3EBE     ADDLW 0xBE
04DC  0086     MOVWF FSR1
04DD  0187     CLRF FSR1H
04DE  083C     MOVF 0x3C, W
04DF  3FC0     MOVWI [0]FSR1
04E0  083D     MOVF 0x3D, W
04E1  3FC1     MOVWI [1]FSR1
467:               MTOUCH_singleResult[sensor2] = MTOUCH_capturedSamples[1][0];
04E2  30AE     MOVLW 0xAE
04E3  0086     MOVWF FSR1
04E4  3021     MOVLW 0x21
04E5  0087     MOVWF FSR1H
04E6  353B     LSLF sensor2, W
04E7  3EBE     ADDLW 0xBE
04E8  0084     MOVWF FSR0
04E9  0185     CLRF FSR0H
04EA  3F40     MOVIW [0]FSR1
04EB  3F80     MOVWI [0]FSR0
04EC  3F41     MOVIW [1]FSR1
04ED  3F81     MOVWI [1]FSR0
468:           
469:           #if defined(CONFIGURABLE_DIFFRESULT)
470:               MTOUCH_diffResult[sensor1]  = 0x8000;
04EE  3541     LSLF i, W
04EF  3EB2     ADDLW 0xB2
04F0  0086     MOVWF FSR1
04F1  3000     MOVLW 0x0
04F2  0187     CLRF FSR1H
04F3  3FC0     MOVWI [0]FSR1
04F4  3080     MOVLW 0x80
04F5  3FC1     MOVWI [1]FSR1
471:               MTOUCH_diffResult[sensor1] += MTOUCH_capturedSamples[0][0] >> 1;
04F6  306C     MOVLW 0x6C
04F7  0086     MOVWF FSR1
04F8  3021     MOVLW 0x21
04F9  0087     MOVWF FSR1H
04FA  3F40     MOVIW [0]FSR1
04FB  00BC     MOVWF 0x3C
04FC  3F41     MOVIW [1]FSR1
04FD  00BD     MOVWF 0x3D
04FE  36BD     LSRF 0x3D, F
04FF  0CBC     RRF 0x3C, F
0500  3541     LSLF i, W
0501  3EB2     ADDLW 0xB2
0502  0086     MOVWF FSR1
0503  0187     CLRF FSR1H
0504  083C     MOVF 0x3C, W
0505  0781     ADDWF INDF1, F
0506  3141     ADDFSR 1, 1
0507  083D     MOVF 0x3D, W
0508  3D81     ADDWFC INDF1, F
050A  317F     ADDFSR 1, -1
472:               MTOUCH_diffResult[sensor1] -= MTOUCH_capturedSamples[0][1] >> 1;
0509  306C     MOVLW 0x6C
050B  0086     MOVWF FSR1
050C  3021     MOVLW 0x21
050D  0087     MOVWF FSR1H
050E  3142     ADDFSR 1, 2
050F  3F40     MOVIW [0]FSR1
0510  00BC     MOVWF 0x3C
0511  3F41     MOVIW [1]FSR1
0512  00BD     MOVWF 0x3D
0513  36BD     LSRF 0x3D, F
0514  0CBC     RRF 0x3C, F
0515  3541     LSLF i, W
0516  3EB2     ADDLW 0xB2
0517  0086     MOVWF FSR1
0518  0187     CLRF FSR1H
0519  083C     MOVF 0x3C, W
051A  0281     SUBWF INDF1, F
051B  3141     ADDFSR 1, 1
051C  083D     MOVF 0x3D, W
051D  3B81     SUBWFB INDF1, F
051E  317F     ADDFSR 1, -1
473:               MTOUCH_diffResult[sensor2]  = 0x8000;
051F  353B     LSLF sensor2, W
0520  3EB2     ADDLW 0xB2
0521  0086     MOVWF FSR1
0522  3000     MOVLW 0x0
0523  0187     CLRF FSR1H
0524  3FC0     MOVWI [0]FSR1
0525  3080     MOVLW 0x80
0526  3FC1     MOVWI [1]FSR1
474:               MTOUCH_diffResult[sensor2] += MTOUCH_capturedSamples[1][0] >> 1;
0527  30AE     MOVLW 0xAE
0528  0086     MOVWF FSR1
0529  3021     MOVLW 0x21
052A  0087     MOVWF FSR1H
052B  3F40     MOVIW [0]FSR1
052C  00BC     MOVWF 0x3C
052D  3F41     MOVIW [1]FSR1
052E  00BD     MOVWF 0x3D
052F  36BD     LSRF 0x3D, F
0530  0CBC     RRF 0x3C, F
0531  353B     LSLF sensor2, W
0532  3EB2     ADDLW 0xB2
0533  0086     MOVWF FSR1
0534  0187     CLRF FSR1H
0535  083C     MOVF 0x3C, W
0536  0781     ADDWF INDF1, F
0537  3141     ADDFSR 1, 1
0538  083D     MOVF 0x3D, W
0539  3D81     ADDWFC INDF1, F
053B  317F     ADDFSR 1, -1
475:               MTOUCH_diffResult[sensor2] -= MTOUCH_capturedSamples[1][1] >> 1;
053A  30B0     MOVLW 0xB0
053C  0086     MOVWF FSR1
053D  3021     MOVLW 0x21
053E  0087     MOVWF FSR1H
053F  3F40     MOVIW [0]FSR1
0540  00BC     MOVWF 0x3C
0541  3F41     MOVIW [1]FSR1
0542  00BD     MOVWF 0x3D
0543  36BD     LSRF 0x3D, F
0544  0CBC     RRF 0x3C, F
0545  353B     LSLF sensor2, W
0546  3EB2     ADDLW 0xB2
0547  0086     MOVWF FSR1
0548  0187     CLRF FSR1H
0549  083C     MOVF 0x3C, W
054A  0281     SUBWF INDF1, F
054B  3141     ADDFSR 1, 1
054C  083D     MOVF 0x3D, W
054D  3B81     SUBWFB INDF1, F
054F  317F     ADDFSR 1, -1
476:           #endif
477:           
478:               return SCAN_HANDLER_good;
054E  3000     MOVLW 0x0
479:           }
0550  0008     RETURN
480:           
481:           static void Hamming_Handler(uint8_t adc, uint8_t i)
0551  00BA     MOVWF adc
482:           {
483:               MTOUCH_SAMPLE_t sample = 0x20000;
0552  3002     MOVLW 0x2
0553  01B7     CLRF sample
0554  01B8     CLRF 0x38
0555  00B9     MOVWF delta
484:           
485:               if ((i & 0x01) == 0)
0556  182B     BTFSC i, 0x0
0557  2E03     GOTO 0x603
486:               {
487:                   sample += MTOUCH_capturedSamples[adc][i+1];
0558  082B     MOVF i, W
0559  00AC     MOVWF delta
055A  01AD     CLRF sensor
055B  35AC     LSLF delta, F
055C  0DAD     RLF sensor, F
055D  083A     MOVF adc, W
055E  00A1     MOVWF divisor
055F  3042     MOVLW 0x42
0560  01A2     CLRF i
0561  00A3     MOVWF dividend
0562  01A4     CLRF 0x24
0563  26EC     CALL 0x6EC
0564  3184     MOVLP 0x4
0565  306E     MOVLW 0x6E
0566  00AE     MOVWF temp_data
0567  3021     MOVLW 0x21
0568  00AF     MOVWF 0x2F
0569  0821     MOVF divisor, W
056A  072E     ADDWF temp_data, W
056B  00B0     MOVWF 0x30
056C  0822     MOVF i, W
056D  3D2F     ADDWFC 0x2F, W
056E  00B1     MOVWF 0x31
056F  082C     MOVF delta, W
0570  0730     ADDWF 0x30, W
0571  0086     MOVWF FSR1
0572  082D     MOVF sensor, W
0573  3D31     ADDWFC 0x31, W
0574  0087     MOVWF FSR1H
0575  3F40     MOVIW [0]FSR1
0576  00B2     MOVWF delta
0577  3F41     MOVIW [1]FSR1
0578  00B3     MOVWF i
0579  0832     MOVF delta, W
057A  00B4     MOVWF sensor
057B  0833     MOVF i, W
057C  00B5     MOVWF delta
057D  01B6     CLRF i
057E  0834     MOVF sensor, W
057F  07B7     ADDWF sample, F
0580  0835     MOVF delta, W
0581  3DB8     ADDWFC 0x38, F
0582  0836     MOVF i, W
0583  3DB9     ADDWFC delta, F
488:                   sample -= MTOUCH_capturedSamples[adc][i];
0584  082B     MOVF i, W
0585  00AC     MOVWF delta
0586  01AD     CLRF sensor
0587  35AC     LSLF delta, F
0588  0DAD     RLF sensor, F
0589  083A     MOVF adc, W
058A  00A1     MOVWF divisor
058B  3042     MOVLW 0x42
058C  01A2     CLRF i
058D  00A3     MOVWF dividend
058E  01A4     CLRF 0x24
058F  26EC     CALL 0x6EC
0590  3184     MOVLP 0x4
0591  306C     MOVLW 0x6C
0592  00AE     MOVWF temp_data
0593  3021     MOVLW 0x21
0594  00AF     MOVWF 0x2F
0595  0821     MOVF divisor, W
0596  072E     ADDWF temp_data, W
0597  00B0     MOVWF 0x30
0598  0822     MOVF i, W
0599  3D2F     ADDWFC 0x2F, W
059A  00B1     MOVWF 0x31
059B  082C     MOVF delta, W
059C  0730     ADDWF 0x30, W
059D  0086     MOVWF FSR1
059E  082D     MOVF sensor, W
059F  3D31     ADDWFC 0x31, W
05A0  0087     MOVWF FSR1H
05A1  3F40     MOVIW [0]FSR1
05A2  00B2     MOVWF delta
05A3  3F41     MOVIW [1]FSR1
05A4  00B3     MOVWF i
05A5  0832     MOVF delta, W
05A6  00B4     MOVWF sensor
05A7  0833     MOVF i, W
05A8  00B5     MOVWF delta
05A9  01B6     CLRF i
05AA  0834     MOVF sensor, W
05AB  02B7     SUBWF sample, F
05AC  0835     MOVF delta, W
05AD  3BB8     SUBWFB 0x38, F
05AE  0836     MOVF i, W
05AF  3BB9     SUBWFB delta, F
489:                   sample += MTOUCH_capturedSamples[adc][MTOUCH_SAMPLES-(i+1)];
05B0  01AD     CLRF sensor
05B1  082B     MOVF i, W
05B2  3C1F     SUBLW 0x1F
05B3  00AC     MOVWF delta
05B4  1C03     BTFSS STATUS, 0x0
05B5  03AD     DECF sensor, F
05B6  35AC     LSLF delta, F
05B7  0DAD     RLF sensor, F
05B8  083A     MOVF adc, W
05B9  00A1     MOVWF divisor
05BA  3042     MOVLW 0x42
05BB  01A2     CLRF i
05BC  00A3     MOVWF dividend
05BD  01A4     CLRF 0x24
05BE  26EC     CALL 0x6EC
05BF  3184     MOVLP 0x4
05C0  306C     MOVLW 0x6C
05C1  00AE     MOVWF temp_data
05C2  3021     MOVLW 0x21
05C3  00AF     MOVWF 0x2F
05C4  0821     MOVF divisor, W
05C5  072E     ADDWF temp_data, W
05C6  00B0     MOVWF 0x30
05C7  0822     MOVF i, W
05C8  3D2F     ADDWFC 0x2F, W
05C9  00B1     MOVWF 0x31
05CA  082C     MOVF delta, W
05CB  0730     ADDWF 0x30, W
05CC  0086     MOVWF FSR1
05CD  082D     MOVF sensor, W
05CE  3D31     ADDWFC 0x31, W
05CF  0087     MOVWF FSR1H
05D0  3F40     MOVIW [0]FSR1
05D1  00B2     MOVWF delta
05D2  3F41     MOVIW [1]FSR1
05D3  00B3     MOVWF i
05D4  0832     MOVF delta, W
05D5  00B4     MOVWF sensor
05D6  0833     MOVF i, W
05D7  00B5     MOVWF delta
05D8  01B6     CLRF i
05D9  0834     MOVF sensor, W
05DA  07B7     ADDWF sample, F
05DB  0835     MOVF delta, W
05DC  3DB8     ADDWFC 0x38, F
05DD  0836     MOVF i, W
05DE  3DB9     ADDWFC delta, F
490:                   sample -= MTOUCH_capturedSamples[adc][MTOUCH_SAMPLES-i];
05DF  01AD     CLRF sensor
05E0  082B     MOVF i, W
05E1  3C20     SUBLW 0x20
05E2  00AC     MOVWF delta
05E3  1C03     BTFSS STATUS, 0x0
05E4  03AD     DECF sensor, F
05E5  35AC     LSLF delta, F
05E6  0DAD     RLF sensor, F
05E7  083A     MOVF adc, W
05E8  00A1     MOVWF divisor
05E9  3042     MOVLW 0x42
05EA  01A2     CLRF i
05EB  00A3     MOVWF dividend
05EC  01A4     CLRF 0x24
05ED  26EC     CALL 0x6EC
05EE  3184     MOVLP 0x4
05EF  306C     MOVLW 0x6C
05F0  00AE     MOVWF temp_data
05F1  3021     MOVLW 0x21
05F2  00AF     MOVWF 0x2F
05F3  0821     MOVF divisor, W
05F4  072E     ADDWF temp_data, W
05F5  00B0     MOVWF 0x30
05F6  0822     MOVF i, W
05F7  3D2F     ADDWFC 0x2F, W
05F8  00B1     MOVWF 0x31
05F9  082C     MOVF delta, W
05FA  0730     ADDWF 0x30, W
05FB  0086     MOVWF FSR1
05FC  082D     MOVF sensor, W
05FD  3D31     ADDWFC 0x31, W
05FE  0087     MOVWF FSR1H
05FF  3F40     MOVIW [0]FSR1
0600  00B2     MOVWF delta
0601  3F41     MOVIW [1]FSR1
0602  2EAD     GOTO 0x6AD
491:               }
492:               else
493:               {
494:                   sample += MTOUCH_capturedSamples[adc][i];
0603  082B     MOVF i, W
0604  00AC     MOVWF delta
0605  01AD     CLRF sensor
0606  35AC     LSLF delta, F
0607  0DAD     RLF sensor, F
0608  083A     MOVF adc, W
0609  00A1     MOVWF divisor
060A  3042     MOVLW 0x42
060B  01A2     CLRF i
060C  00A3     MOVWF dividend
060D  01A4     CLRF 0x24
060E  26EC     CALL 0x6EC
060F  3184     MOVLP 0x4
0610  306C     MOVLW 0x6C
0611  00AE     MOVWF temp_data
0612  3021     MOVLW 0x21
0613  00AF     MOVWF 0x2F
0614  0821     MOVF divisor, W
0615  072E     ADDWF temp_data, W
0616  00B0     MOVWF 0x30
0617  0822     MOVF i, W
0618  3D2F     ADDWFC 0x2F, W
0619  00B1     MOVWF 0x31
061A  082C     MOVF delta, W
061B  0730     ADDWF 0x30, W
061C  0086     MOVWF FSR1
061D  082D     MOVF sensor, W
061E  3D31     ADDWFC 0x31, W
061F  0087     MOVWF FSR1H
0620  3F40     MOVIW [0]FSR1
0621  00B2     MOVWF delta
0622  3F41     MOVIW [1]FSR1
0623  00B3     MOVWF i
0624  0832     MOVF delta, W
0625  00B4     MOVWF sensor
0626  0833     MOVF i, W
0627  00B5     MOVWF delta
0628  01B6     CLRF i
0629  0834     MOVF sensor, W
062A  07B7     ADDWF sample, F
062B  0835     MOVF delta, W
062C  3DB8     ADDWFC 0x38, F
062D  0836     MOVF i, W
062E  3DB9     ADDWFC delta, F
495:                   sample -= MTOUCH_capturedSamples[adc][i+1];
062F  082B     MOVF i, W
0630  00AC     MOVWF delta
0631  01AD     CLRF sensor
0632  35AC     LSLF delta, F
0633  0DAD     RLF sensor, F
0634  083A     MOVF adc, W
0635  00A1     MOVWF divisor
0636  3042     MOVLW 0x42
0637  01A2     CLRF i
0638  00A3     MOVWF dividend
0639  01A4     CLRF 0x24
063A  26EC     CALL 0x6EC
063B  3184     MOVLP 0x4
063C  306E     MOVLW 0x6E
063D  00AE     MOVWF temp_data
063E  3021     MOVLW 0x21
063F  00AF     MOVWF 0x2F
0640  0821     MOVF divisor, W
0641  072E     ADDWF temp_data, W
0642  00B0     MOVWF 0x30
0643  0822     MOVF i, W
0644  3D2F     ADDWFC 0x2F, W
0645  00B1     MOVWF 0x31
0646  082C     MOVF delta, W
0647  0730     ADDWF 0x30, W
0648  0086     MOVWF FSR1
0649  082D     MOVF sensor, W
064A  3D31     ADDWFC 0x31, W
064B  0087     MOVWF FSR1H
064C  3F40     MOVIW [0]FSR1
064D  00B2     MOVWF delta
064E  3F41     MOVIW [1]FSR1
064F  00B3     MOVWF i
0650  0832     MOVF delta, W
0651  00B4     MOVWF sensor
0652  0833     MOVF i, W
0653  00B5     MOVWF delta
0654  01B6     CLRF i
0655  0834     MOVF sensor, W
0656  02B7     SUBWF sample, F
0657  0835     MOVF delta, W
0658  3BB8     SUBWFB 0x38, F
0659  0836     MOVF i, W
065A  3BB9     SUBWFB delta, F
496:                   sample += MTOUCH_capturedSamples[adc][MTOUCH_SAMPLES-i];
065B  01AD     CLRF sensor
065C  082B     MOVF i, W
065D  3C20     SUBLW 0x20
065E  00AC     MOVWF delta
065F  1C03     BTFSS STATUS, 0x0
0660  03AD     DECF sensor, F
0661  35AC     LSLF delta, F
0662  0DAD     RLF sensor, F
0663  083A     MOVF adc, W
0664  00A1     MOVWF divisor
0665  3042     MOVLW 0x42
0666  01A2     CLRF i
0667  00A3     MOVWF dividend
0668  01A4     CLRF 0x24
0669  26EC     CALL 0x6EC
066A  3184     MOVLP 0x4
066B  306C     MOVLW 0x6C
066C  00AE     MOVWF temp_data
066D  3021     MOVLW 0x21
066E  00AF     MOVWF 0x2F
066F  0821     MOVF divisor, W
0670  072E     ADDWF temp_data, W
0671  00B0     MOVWF 0x30
0672  0822     MOVF i, W
0673  3D2F     ADDWFC 0x2F, W
0674  00B1     MOVWF 0x31
0675  082C     MOVF delta, W
0676  0730     ADDWF 0x30, W
0677  0086     MOVWF FSR1
0678  082D     MOVF sensor, W
0679  3D31     ADDWFC 0x31, W
067A  0087     MOVWF FSR1H
067B  3F40     MOVIW [0]FSR1
067C  00B2     MOVWF delta
067D  3F41     MOVIW [1]FSR1
067E  00B3     MOVWF i
067F  0832     MOVF delta, W
0680  00B4     MOVWF sensor
0681  0833     MOVF i, W
0682  00B5     MOVWF delta
0683  01B6     CLRF i
0684  0834     MOVF sensor, W
0685  07B7     ADDWF sample, F
0686  0835     MOVF delta, W
0687  3DB8     ADDWFC 0x38, F
0688  0836     MOVF i, W
0689  3DB9     ADDWFC delta, F
497:                   sample -= MTOUCH_capturedSamples[adc][MTOUCH_SAMPLES-(i+1)];
068A  01AD     CLRF sensor
068B  082B     MOVF i, W
068C  3C1F     SUBLW 0x1F
068D  00AC     MOVWF delta
068E  1C03     BTFSS STATUS, 0x0
068F  03AD     DECF sensor, F
0690  35AC     LSLF delta, F
0691  0DAD     RLF sensor, F
0692  083A     MOVF adc, W
0693  00A1     MOVWF divisor
0694  3042     MOVLW 0x42
0695  01A2     CLRF i
0696  00A3     MOVWF dividend
0697  01A4     CLRF 0x24
0698  26EC     CALL 0x6EC
0699  3184     MOVLP 0x4
069A  306C     MOVLW 0x6C
069B  00AE     MOVWF temp_data
069C  3021     MOVLW 0x21
069D  00AF     MOVWF 0x2F
069E  0821     MOVF divisor, W
069F  072E     ADDWF temp_data, W
06A0  00B0     MOVWF 0x30
06A1  0822     MOVF i, W
06A2  3D2F     ADDWFC 0x2F, W
06A3  00B1     MOVWF 0x31
06A4  082C     MOVF delta, W
06A5  0730     ADDWF 0x30, W
06A6  0086     MOVWF FSR1
06A7  082D     MOVF sensor, W
06A8  3D31     ADDWFC 0x31, W
06A9  0087     MOVWF FSR1H
06AA  3F40     MOVIW [0]FSR1
06AB  00B2     MOVWF delta
06AC  3F41     MOVIW [1]FSR1
06AD  00B3     MOVWF i
06AE  0832     MOVF delta, W
06AF  00B4     MOVWF sensor
06B0  0833     MOVF i, W
06B1  00B5     MOVWF delta
06B2  01B6     CLRF i
06B3  0834     MOVF sensor, W
06B4  02B7     SUBWF sample, F
06B5  0835     MOVF delta, W
06B6  3BB8     SUBWFB 0x38, F
06B7  0836     MOVF i, W
06B8  3BB9     SUBWFB delta, F
498:               }
499:               sample >>= 2;
06B9  3002     MOVLW 0x2
06BA  00AC     MOVWF delta
06BB  37B9     ASRF delta, F
06BC  0CB8     RRF 0x38, F
06BD  0CB7     RRF sample, F
06BE  0BAC     DECFSZ delta, F
06BF  2EBB     GOTO 0x6BB
500:           
501:               #if defined(CONFIGURABLE_FILTERTYPE)
502:               if (MTOUCH_flags.hamming_nAccumulation == 1)
06C0  1DD6     BTFSS MTOUCH_flags, 0x3
06C1  2EDD     GOTO 0x6DD
503:               {
504:                   MTOUCH_sample[adc] += (MTOUCH_SAMPLE_t)MTOUCH_Hamming(i, sample);
06C2  0838     MOVF 0x38, W
06C3  00A2     MOVWF i
06C4  0837     MOVF sample, W
06C5  00A1     MOVWF divisor
06C6  082B     MOVF i, W
06C7  3196     MOVLP 0x16
06C8  2673     CALL 0x673
06C9  0821     MOVF divisor, W
06CA  00AC     MOVWF delta
06CB  0822     MOVF i, W
06CC  00AD     MOVWF sensor
06CD  01AE     CLRF temp_data
06CE  083A     MOVF adc, W
06CF  073A     ADDWF adc, W
06D0  073A     ADDWF adc, W
06D1  3E43     ADDLW 0x43
06D2  0086     MOVWF FSR1
06D3  0187     CLRF FSR1H
06D4  082C     MOVF delta, W
06D5  0781     ADDWF INDF1, F
06D6  3141     ADDFSR 1, 1
06D7  082D     MOVF sensor, W
06D8  3D81     ADDWFC INDF1, F
06D9  3141     ADDFSR 1, 1
06DA  082E     MOVF temp_data, W
06DB  3D81     ADDWFC INDF1, F
505:               }
06DC  0008     RETURN
506:               else
507:               {
508:                   MTOUCH_sample[adc] += sample;
06DD  083A     MOVF adc, W
06DE  073A     ADDWF adc, W
06DF  073A     ADDWF adc, W
06E0  3E43     ADDLW 0x43
06E1  0086     MOVWF FSR1
06E2  0187     CLRF FSR1H
06E3  0837     MOVF sample, W
06E4  0781     ADDWF INDF1, F
06E5  3141     ADDFSR 1, 1
06E6  0838     MOVF 0x38, W
06E7  3D81     ADDWFC INDF1, F
06E8  3141     ADDFSR 1, 1
06E9  0839     MOVF delta, W
06EA  3D81     ADDWFC INDF1, F
509:               }
510:               #else
511:               MTOUCH_sample[adc] += (MTOUCH_SAMPLE_t)MTOUCH_Hamming(i, sample);
512:               #endif
513:           }
06EB  0008     RETURN
514:           
515:           static void Noise_Calculation(uint8_t adc)
0701  00B5     MOVWF delta
516:           {
517:               int24_t delta;
518:               uint8_t i;
519:               
520:               MTOUCH_noise[adc] = 0;
0702  0735     ADDWF delta, W
0703  0735     ADDWF delta, W
0704  3ED0     ADDLW 0xD0
0705  0086     MOVWF FSR1
0706  3000     MOVLW 0x0
0707  0187     CLRF FSR1H
0708  3FC0     MOVWI [0]FSR1
0709  3FC1     MOVWI [1]FSR1
070A  3FC2     MOVWI [2]FSR1
521:               for (i = (uint8_t)1; i < (uint8_t)MTOUCH_SAMPLES; i++)
070B  01B6     CLRF i
070C  0AB6     INCF i, F
0777  3020     MOVLW 0x20
0778  0AB6     INCF i, F
0779  0236     SUBWF i, W
077A  1803     BTFSC STATUS, 0x0
077B  0008     RETURN
077C  2F0D     GOTO 0x70D
522:               {
523:                   delta  = MTOUCH_capturedSamples[adc][i-(uint8_t)1];
070D  0836     MOVF i, W
070E  00A7     MOVWF quotient
070F  01A8     CLRF sensor
0710  35A7     LSLF quotient, F
0711  0DA8     RLF sensor, F
0712  0835     MOVF delta, W
0713  00A1     MOVWF divisor
0714  3042     MOVLW 0x42
0715  01A2     CLRF i
0716  00A3     MOVWF dividend
0717  01A4     CLRF 0x24
0718  26EC     CALL 0x6EC
0719  3184     MOVLP 0x4
071A  306A     MOVLW 0x6A
071B  00A9     MOVWF delta
071C  3021     MOVLW 0x21
071D  00AA     MOVWF dataReady
071E  0821     MOVF divisor, W
071F  0729     ADDWF delta, W
0720  00AB     MOVWF i
0721  0822     MOVF i, W
0722  3D2A     ADDWFC dataReady, W
0723  00AC     MOVWF delta
0724  0827     MOVF quotient, W
0725  072B     ADDWF i, W
0726  0086     MOVWF FSR1
0727  0828     MOVF sensor, W
0728  3D2C     ADDWFC delta, W
0729  0087     MOVWF FSR1H
072A  3F40     MOVIW [0]FSR1
072B  00AD     MOVWF sensor
072C  3F41     MOVIW [1]FSR1
072D  00AE     MOVWF temp_data
072E  082D     MOVF sensor, W
072F  00B2     MOVWF delta
0730  082E     MOVF temp_data, W
0731  00B3     MOVWF i
0732  01B4     CLRF sensor
524:                   delta -= MTOUCH_capturedSamples[adc][i+(uint8_t)1];
0733  0836     MOVF i, W
0734  00A7     MOVWF quotient
0735  01A8     CLRF sensor
0736  35A7     LSLF quotient, F
0737  0DA8     RLF sensor, F
0738  0835     MOVF delta, W
0739  00A1     MOVWF divisor
073A  3042     MOVLW 0x42
073B  01A2     CLRF i
073C  00A3     MOVWF dividend
073D  01A4     CLRF 0x24
073E  26EC     CALL 0x6EC
073F  3184     MOVLP 0x4
0740  306E     MOVLW 0x6E
0741  00A9     MOVWF delta
0742  3021     MOVLW 0x21
0743  00AA     MOVWF dataReady
0744  0821     MOVF divisor, W
0745  0729     ADDWF delta, W
0746  00AB     MOVWF i
0747  0822     MOVF i, W
0748  3D2A     ADDWFC dataReady, W
0749  00AC     MOVWF delta
074A  0827     MOVF quotient, W
074B  072B     ADDWF i, W
074C  0086     MOVWF FSR1
074D  0828     MOVF sensor, W
074E  3D2C     ADDWFC delta, W
074F  0087     MOVWF FSR1H
0750  3F40     MOVIW [0]FSR1
0751  00AD     MOVWF sensor
0752  3F41     MOVIW [1]FSR1
0753  00AE     MOVWF temp_data
0754  082D     MOVF sensor, W
0755  00AF     MOVWF 0x2F
0756  082E     MOVF temp_data, W
0757  00B0     MOVWF 0x30
0758  01B1     CLRF 0x31
0759  082F     MOVF 0x2F, W
075A  02B2     SUBWF delta, F
075B  0830     MOVF 0x30, W
075C  3BB3     SUBWFB i, F
075D  0831     MOVF 0x31, W
075E  3BB4     SUBWFB sensor, F
525:                   if (delta < 0) { delta = -delta; }
075F  1FB4     BTFSS sensor, 0x7
0760  2F69     GOTO 0x769
0761  09B2     COMF delta, F
0762  09B3     COMF i, F
0763  09B4     COMF sensor, F
0764  0AB2     INCF delta, F
0765  1903     BTFSC STATUS, 0x2
0766  0AB3     INCF i, F
0767  1903     BTFSC STATUS, 0x2
0768  0AB4     INCF sensor, F
526:                   MTOUCH_noise[adc] += (uint24_t)delta;
0769  0835     MOVF delta, W
076A  0735     ADDWF delta, W
076B  0735     ADDWF delta, W
076C  3ED0     ADDLW 0xD0
076D  0086     MOVWF FSR1
076E  0187     CLRF FSR1H
076F  0832     MOVF delta, W
0770  0781     ADDWF INDF1, F
0771  3141     ADDFSR 1, 1
0772  0833     MOVF i, W
0773  3D81     ADDWFC INDF1, F
0774  3141     ADDFSR 1, 1
0775  0834     MOVF sensor, W
0776  3D81     ADDWFC INDF1, F
527:               }
528:           }
529:           
530:           void MTOUCH_Notify_InterruptServiced(void)
531:           {
532:               MTOUCH_flags.error = 1;
07FA  0020     MOVLB 0x0
07FB  14D6     BSF MTOUCH_flags, 0x1
533:           }
07FC  0008     RETURN
534:           
535:           #if defined(CONFIGURABLE_SAMPLETYPE)
536:           /*
537:            *  PRIVATE FUNCTION
538:            *
539:            *  Generates a pseudo-random value based on the Galois LFSR algorithm.
540:            *
541:            *  If MTOUCH_RANDOM_BIT is 8, then an 8-bit value is used for the seed and
542:            *  the output of the function will repeat after 2^8 function calls.
543:            *
544:            *  If MTOUCH_RANDOM_BIT is 16, then a 16-bit value is used for the seed and
545:            *  the output of the function will repeat after 2^16 function calls.
546:            *
547:            *  If MTOUCH_RANDOM_BIT is 24, then a 24-bit value is used for the seed and
548:            *  the output of the function will repeat after 2^24 function calls.
549:            *
550:            *  If MTOUCH_RANDOM_BIT is 32, then a 32-bit value is used for the seed and
551:            *  the output of the function will repeat after 2^32 function calls.
552:            *
553:            *
554:            *  NOTE: This function is completely self-contained. You can copy and paste
555:            *  this into another project without needing to include any other code.
556:            *
557:            *
558:            *  @prototype      uint8_t MTOUCH_Random(void)
559:            *
560:            *  @return         a pseudo-random value. Not sufficient for any algorithm
561:            *                  needing true randomization such as cryptography. Plenty
562:            *                  of randomness to implement mTouch sample rate jittering.
563:            */
564:           
565:           #define MTOUCH_RANDOM_BIT   8
566:           
567:           #if     MTOUCH_RANDOM_BIT == 8
568:               #define MTOUCH_RANDOM_XOR   0xB4
569:               typedef uint8_t MTOUCH_RANDOM_t;
570:           #elif   MTOUCH_RANDOM_BIT == 16
571:               #define MTOUCH_RANDOM_XOR   0xA1A1
572:               typedef uint16_t MTOUCH_RANDOM_t;
573:           #elif   MTOUCH_RANDOM_BIT == 24
574:               #define MTOUCH_RANDOM_XOR   0xD7D7D7
575:               typedef uint_least24_t MTOUCH_RANDOM_t;
576:           #elif   MTOUCH_RANDOM_BIT == 32
577:               #define MTOUCH_RANDOM_XOR   0xA6A6A6A6
578:               typedef uint32_t MTOUCH_RANDOM_t;
579:           #endif
580:           
581:           static uint8_t MTOUCH_Random(void)
582:           {
583:               static MTOUCH_RANDOM_t seed = (MTOUCH_RANDOM_t)0;
584:           
585:               if ((seed & (MTOUCH_RANDOM_t)1) != (MTOUCH_RANDOM_t)0)
077D  1C4B     BTFSS seed, 0x0
077E  2F81     GOTO 0x781
586:               {
587:                   /* If the LSb of "seed" is a '1' then divide seed by 2. */
588:                   seed = seed >> (uint8_t)1;
077F  36CB     LSRF seed, F
589:               }
0780  2F84     GOTO 0x784
590:               else
591:               {
592:                   /*
593:                    * If the LSb of "seed" is a '0' then divide seed by 2, and XOR it with
594:                    * the LFSR polynom.
595:                    */
596:                   seed = seed >> (uint8_t)1;
0782  36CB     LSRF seed, F
597:                   seed = seed ^ (MTOUCH_RANDOM_t)MTOUCH_RANDOM_XOR;
0781  30B4     MOVLW 0xB4
0783  06CB     XORWF seed, F
598:               }
599:           
600:               return (uint8_t)seed;
0784  084B     MOVF seed, W
601:           }
0785  0008     RETURN
602:           #endif
---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/mtouch_proximity.c
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            
37:            #include <stdint.h>
38:            
39:            #include "configuration.h"
40:            #include "mtouch.h"
41:            #include "mtouch_proximity.h"
42:            
43:            #if defined(MTOUCH_PROXIMITY_ENABLED)
44:            /* Local Variables */
45:            static uint32_t             MTOUCH_prox_reading;
46:            static uint32_t             MTOUCH_prox_baseline;
47:            static uint32_t             MTOUCH_prox_filter;
48:            static enum MTOUCH_STATE    MTOUCH_prox_state;
49:            static MTOUCH_DELTA_t      MTOUCH_Proximity_Delta;
50:            static uint8_t              tap_index[MTOUCH_MEDIAN_FILTER_TAP];
51:            static uint32_t             filter_data[MTOUCH_MEDIAN_FILTER_TAP];
52:            
53:            
54:            extern void MTOUCH_CALLBACK_ProxActivated   (void);
55:            extern void MTOUCH_CALLBACK_ProxDeactivated (void);
56:            
57:            MTOUCH_DELTA_t       MTOUCH_proximity_threshold;
58:            uint8_t              MTOUCH_proximity_scaling;    
59:            
60:            /* Local Prototypes */
61:            static void MTOUCH_Proximity_StateMachine   (void);
62:            static void MTOUCH_Proximity_Update         (void);
63:            static uint32_t median_filter(uint32_t );
64:            
65:            /*
66:             *  PUBLIC FUNCTION
67:             *
68:             *  Initializes all proximity variables.
69:             *
70:             *  @prototype      void MTOUCH_Proximity_Init(void)
71:             */
72:            void MTOUCH_Proximity_Init(void)
73:            {
74:                MTOUCH_prox_reading     = (uint32_t)0;
14ED  0021     MOVLB 0x1
14EE  01DA     CLRF MTOUCH_prox_reading
14EF  01DB     CLRF 0xDB
14F0  01DC     CLRF 0xDC
14F1  01DD     CLRF 0xDD
75:                MTOUCH_prox_baseline    = (uint32_t)0;
14F2  0022     MOVLB 0x2
14F3  01DD     CLRF MTOUCH_prox_baseline
14F4  01DE     CLRF 0x15E
14F5  01DF     CLRF 0x15F
14F6  01E0     CLRF 0x160
76:                MTOUCH_prox_filter      = (uint32_t)0;
14F7  0021     MOVLB 0x1
14F9  01D6     CLRF MTOUCH_prox_filter
14FA  01D7     CLRF 0xD7
14FB  01D8     CLRF 0xD8
14FC  01D9     CLRF 0xD9
77:                MTOUCH_prox_state       = MTOUCH_STATE_released;
14FD  01E5     CLRF MTOUCH_prox_state
14FE  0AE5     INCF MTOUCH_prox_state, F
78:                MTOUCH_proximity_threshold = (MTOUCH_DELTA_t)MTOUCH_PROX_ACTIVATE_THRESHOLD;
14F8  3064     MOVLW 0x64
14FF  0020     MOVLB 0x0
1500  00DE     MOVWF MTOUCH_proximity_threshold
79:                MTOUCH_proximity_scaling = (uint8_t)MTOUCH_PROX_SCALING;
1501  3006     MOVLW 0x6
1502  00DD     MOVWF MTOUCH_proximity_scaling
80:                
81:                /*Initialize Median filter*/
82:                for (uint8_t i=0;i<MTOUCH_MEDIAN_FILTER_TAP;i++)
1503  01A1     CLRF divisor
1515  3007     MOVLW 0x7
83:                {
84:                    tap_index[i]=i;
1504  0821     MOVF divisor, W
1505  3E2C     ADDLW 0x2C
1506  0086     MOVWF FSR1
1507  3001     MOVLW 0x1
1508  0087     MOVWF FSR1H
1509  0821     MOVF divisor, W
150A  0081     MOVWF INDF1
85:                    filter_data[i] = 0;
150B  0821     MOVF divisor, W
150C  0709     ADDWF WREG, W
150D  0709     ADDWF WREG, W
150E  3EA0     ADDLW 0xA0
150F  0086     MOVWF FSR1
1510  3000     MOVLW 0x0
1511  3FC0     MOVWI [0]FSR1
1512  3FC1     MOVWI [1]FSR1
1513  3FC2     MOVWI [2]FSR1
1514  3FC3     MOVWI [3]FSR1
86:                }
87:            }
88:            
89:            /*
90:             *  PUBLIC FUNCTION
91:             *
92:             *  This is the API function call for decoding the proximity sensor.
93:             *
94:             *  @prototype      void MTOUCH_Proximity_Decode(void)
95:             */
96:            void MTOUCH_Proximity_Decode(void)
97:            {
98:                MTOUCH_Proximity_Update();
0ADB  2605     CALL 0x605
99:                MTOUCH_Proximity_StateMachine();
0ADC  3187     MOVLP 0x7
100:           }
101:           
102:           /*
103:            *  PUBLIC FUNCTION
104:            *
105:            *  Calculate the current proximity sensor delta value.
106:            *
107:            *  @prototype      MTOUCH_DELTA_t MTOUCH_Proximity_Delta_Calculate(void)
108:            */
109:           void MTOUCH_Proximity_Delta_Calculate(void)
110:           {
111:               uint32_t            reading;
112:           
113:               reading = MTOUCH_prox_filter >> MTOUCH_proximity_scaling;
07C8  0859     MOVF MTOUCH_mostPressed_index, W
07C9  0020     MOVLB 0x0
07CA  00A4     MOVWF 0x24
07CB  0021     MOVLB 0x1
07CC  0858     MOVF 0xD8, W
07CD  0020     MOVLB 0x0
07CE  00A3     MOVWF dividend
07CF  0021     MOVLB 0x1
07D0  0857     MOVF 0xD7, W
07D1  0020     MOVLB 0x0
07D2  00A2     MOVWF i
07D3  0021     MOVLB 0x1
07D4  0856     MOVF MTOUCH_prox_filter, W
07D5  0020     MOVLB 0x0
07D6  00A1     MOVWF divisor
07D7  0A5D     INCF MTOUCH_proximity_scaling, W
07D8  2FDD     GOTO 0x7DD
07D9  36A4     LSRF 0x24, F
07DA  0CA3     RRF dividend, F
07DB  0CA2     RRF i, F
07DC  0CA1     RRF divisor, F
07DD  0B89     DECFSZ WREG, F
07DE  2FD9     GOTO 0x7D9
114:           
115:               if (reading > (uint32_t)INT8_MAX)
07DF  3000     MOVLW 0x0
07E0  0224     SUBWF 0x24, W
07E1  1D03     BTFSS STATUS, 0x2
07E2  2FED     GOTO 0x7ED
07E3  3000     MOVLW 0x0
07E4  0223     SUBWF dividend, W
07E5  1D03     BTFSS STATUS, 0x2
07E6  2FED     GOTO 0x7ED
07E7  3000     MOVLW 0x0
07E8  0222     SUBWF i, W
07E9  1D03     BTFSS STATUS, 0x2
07EA  2FED     GOTO 0x7ED
07EB  3080     MOVLW 0x80
07EC  0221     SUBWF divisor, W
07ED  1C03     BTFSS STATUS, 0x0
07EE  2FF2     GOTO 0x7F2
116:               {
117:                   MTOUCH_Proximity_Delta = (MTOUCH_DELTA_t)INT8_MAX;
07EF  307F     MOVLW 0x7F
07F0  00D2     MOVWF MTOUCH_Proximity_Delta
118:               }
07F1  0008     RETURN
119:               else
120:               {
121:                   MTOUCH_Proximity_Delta = (MTOUCH_DELTA_t)reading;
07F2  0821     MOVF divisor, W
07F3  00D2     MOVWF MTOUCH_Proximity_Delta
122:               }
123:           }
07F4  0008     RETURN
124:           
125:           MTOUCH_DELTA_t      MTOUCH_Proximity_Delta_Get  (void)
126:           {
127:               return MTOUCH_Proximity_Delta;
03FE  0852     MOVF MTOUCH_Proximity_Delta, W
07C5  0020     MOVLB 0x0
07C6  0852     MOVF MTOUCH_Proximity_Delta, W
128:           }
03FF  0008     RETURN
07C7  0008     RETURN
129:           
130:           /*
131:            *  PUBLIC FUNCTION
132:            *
133:            *  Provides the current proximity sensor state.
134:            *
135:            *  @prototype      enum MTOUCH_STATE MTOUCH_Proximity_State_Get(void)
136:            */
137:           enum MTOUCH_STATE MTOUCH_Proximity_State_Get(void)
138:           {
139:               return MTOUCH_prox_state;
140:           }
141:           
142:           /*
143:            *  PRIVATE FUNCTION
144:            *
145:            *  The state machine for the proximity sensor. Very similar to the button state
146:            *  machine, but with fewer features.
147:            *
148:            *  @prototype      static void MTOUCH_Proximity_StateMachine(void)
149:            */
150:           static void MTOUCH_Proximity_StateMachine(void)
151:           {
152:               MTOUCH_Proximity_Delta_Calculate();
0786  27C8     CALL 0x7C8
0787  3187     MOVLP 0x7
153:               switch(MTOUCH_prox_state)
0788  2FB8     GOTO 0x7B8
07B8  0021     MOVLB 0x1
07B9  0865     MOVF MTOUCH_prox_state, W
07BA  3A00     XORLW 0x0
07BB  1903     BTFSC 0x83, 0x2
07BC  2F89     GOTO 0x789
07BD  3A01     XORLW 0x1
07BE  1903     BTFSC 0x83, 0x2
07BF  2F8C     GOTO 0x78C
07C0  3A03     XORLW 0x3
07C1  1903     BTFSC 0x83, 0x2
07C2  2F9A     GOTO 0x79A
07C3  2FB6     GOTO 0x7B6
154:               {
155:                   /*
156:                    * 
157:                    */
158:                   case MTOUCH_STATE_initializing:
159:                       MTOUCH_prox_state = MTOUCH_STATE_released;
0789  01E5     CLRF MTOUCH_prox_state
078A  0AE5     INCF MTOUCH_prox_state, F
160:                       break;
078B  0008     RETURN
161:           
162:                   /*
163:                    * 
164:                    */
165:                   case MTOUCH_STATE_released:
166:                       if (MTOUCH_Proximity_Delta_Get() > MTOUCH_proximity_threshold)
078C  0020     MOVLB 0x0
078D  085E     MOVF MTOUCH_proximity_threshold, W
078E  3A80     XORLW 0x80
078F  00A5     MOVWF counter
0790  27C5     CALL 0x7C5
0791  3187     MOVLP 0x7
0792  3A80     XORLW 0x80
0793  02A5     SUBWF counter, F
0794  1803     BTFSC STATUS, 0x0
0795  0008     RETURN
167:                       {
168:                           MTOUCH_prox_state = MTOUCH_STATE_pressed;
0796  3002     MOVLW 0x2
0797  0021     MOVLB 0x1
0798  00E5     MOVWF MTOUCH_prox_state
169:                           
170:                           /*lint -e522*/
171:                           MTOUCH_CALLBACK_ProxActivated();  /* Do not care if this has no side effects. */
0799  2FF5     GOTO 0x7F5
172:                           /*lint +e522*/
173:                       }
174:                       break;
175:           
176:                   /*
177:                    * 
178:                    */
179:                   case MTOUCH_STATE_pressed:
180:                       if (MTOUCH_Proximity_Delta_Get() < (MTOUCH_proximity_threshold>>1))
079A  27C5     CALL 0x7C5
079B  3187     MOVLP 0x7
079C  3A80     XORLW 0x80
079D  00A5     MOVWF 0xA5
079E  375E     ASRF MTOUCH_noise_threshold, W
079F  3A80     XORLW 0x80
07A0  02A5     SUBWF 0xA5, F
07A1  1803     BTFSC 0x83, 0x0
07A2  0008     RETURN
181:                       {
182:                           MTOUCH_prox_state = MTOUCH_STATE_released;
07A3  0021     MOVLB 0x1
07A4  01E5     CLRF MTOUCH_prox_state
07A5  0AE5     INCF MTOUCH_prox_state, F
183:                           MTOUCH_prox_baseline = MTOUCH_prox_reading;
07A6  085D     MOVF 0xDD, W
07A7  0022     MOVLB 0x2
07A8  00E0     MOVWF 0x160
07A9  0021     MOVLB 0x1
07AA  085C     MOVF 0xDC, W
07AB  0022     MOVLB 0x2
07AC  00DF     MOVWF 0x15F
07AD  0021     MOVLB 0x1
07AE  085B     MOVF 0xDB, W
07AF  0022     MOVLB 0x2
07B0  00DE     MOVWF 0x15E
07B1  0021     MOVLB 0x1
07B2  085A     MOVF MTOUCH_prox_reading, W
07B3  0022     MOVLB 0x2
07B4  00DD     MOVWF MTOUCH_prox_baseline
184:           
185:                           /*lint -e522*/
186:                           MTOUCH_CALLBACK_ProxDeactivated();    /* Do not care if this has no side effects. */
07B5  2FF7     GOTO 0x7F7
187:                           /*lint +e522*/
188:                       }
189:                       break;
190:           
191:                   /*
192:                    * We should never reach this point.
193:                    */
194:                   default:    MTOUCH_prox_state = MTOUCH_STATE_initializing;
07B6  01E5     CLRF 0x165
195:               }
07B7  0008     RETURN
196:           }
07C4  0008     RETURN
197:           
198:           /*
199:            *  PRIVATE FUNCTION
200:            *
201:            *  Updates the current proximity sensor readings based on the current sensor's
202:            *  values.
203:            *
204:            *  @prototype      static void MTOUCH_Proximity_Update(void)
205:            */
206:           static void MTOUCH_Proximity_Update(void)
207:           {
208:               int32_t delta;
209:           
210:               MTOUCH_prox_reading  -= MTOUCH_prox_reading >> MTOUCH_PROX_GAIN;
0E05  0021     MOVLB 0x1
0E06  085A     MOVF MTOUCH_prox_reading, W
0E07  0020     MOVLB 0x0
0E08  00B5     MOVWF delta
0E09  0021     MOVLB 0x1
0E0A  085B     MOVF 0xDB, W
0E0B  0020     MOVLB 0x0
0E0C  00B6     MOVWF i
0E0D  0021     MOVLB 0x1
0E0E  085C     MOVF 0xDC, W
0E0F  0020     MOVLB 0x0
0E10  00B7     MOVWF sample
0E11  0021     MOVLB 0x1
0E12  085D     MOVF 0xDD, W
0E13  0020     MOVLB 0x0
0E14  00B8     MOVWF 0x38
0E15  3002     MOVLW 0x2
0E16  36B8     LSRF 0x38, F
0E17  0CB7     RRF sample, F
0E18  0CB6     RRF i, F
0E19  0CB5     RRF delta, F
0E1A  0B89     DECFSZ WREG, F
0E1B  2E16     GOTO 0x616
0E1C  0835     MOVF delta, W
0E1D  0021     MOVLB 0x1
0E1E  02DA     SUBWF MTOUCH_prox_reading, F
0E1F  0020     MOVLB 0x0
0E20  0836     MOVF i, W
0E21  0021     MOVLB 0x1
0E22  3BDB     SUBWFB 0xDB, F
0E23  0020     MOVLB 0x0
0E24  0837     MOVF sample, W
0E25  0021     MOVLB 0x1
0E26  3BDC     SUBWFB 0xDC, F
0E27  0020     MOVLB 0x0
0E28  0838     MOVF 0x38, W
0E29  0021     MOVLB 0x1
0E2A  3BDD     SUBWFB 0xDD, F
211:               MTOUCH_prox_reading  +=median_filter(MTOUCH_Sensor_Reading_Get((uint8_t)MTOUCH_PROXIMITY));
0E2B  3000     MOVLW 0x0
0E2C  2144     CALL 0x144
0E2D  3188     MOVLP 0x8
0E2E  0821     MOVF 0xA1, W
0E2F  00B5     MOVWF 0xB5
0E30  0822     MOVF 0xA2, W
0E31  00B6     MOVWF 0xB6
0E32  0823     MOVF 0xA3, W
0E33  00B7     MOVWF 0xB7
0E34  01B8     CLRF 0xB8
0E35  0838     MOVF 0xB8, W
0E36  00A9     MOVWF 0xA9
0E37  0837     MOVF 0xB7, W
0E38  00A8     MOVWF 0xA8
0E39  0836     MOVF 0xB6, W
0E3A  00A7     MOVWF 0xA7
0E3B  0835     MOVF 0xB5, W
0E3C  00A6     MOVWF 0xA6
0E3D  26C6     CALL 0x6C6
0E3E  3188     MOVLP 0x8
0E3F  0826     MOVF 0xA6, W
0E40  0021     MOVLB 0x1
0E41  07DA     ADDWF MTOUCH_prox_reading, F
0E42  0020     MOVLB 0x0
0E43  0827     MOVF quotient, W
0E44  0021     MOVLB 0x1
0E45  3DDB     ADDWFC 0xDB, F
0E46  0020     MOVLB 0x0
0E47  0828     MOVF sensor, W
0E48  0021     MOVLB 0x1
0E49  3DDC     ADDWFC 0xDC, F
0E4A  0020     MOVLB 0x0
0E4B  0829     MOVF delta, W
0E4C  0021     MOVLB 0x1
0E4D  3DDD     ADDWFC 0xDD, F
212:               
213:               MTOUCH_prox_baseline = MTOUCH_Sensor_Baseline_Get((uint8_t)MTOUCH_PROXIMITY)<<MTOUCH_PROX_GAIN;
0E4E  3000     MOVLW 0x0
0E4F  2153     CALL 0x153
0E50  3188     MOVLP 0x8
0E51  0821     MOVF 0xA1, W
0E52  00B5     MOVWF 0xB5
0E53  0822     MOVF 0xA2, W
0E54  00B6     MOVWF 0xB6
0E55  0823     MOVF 0xA3, W
0E56  00B7     MOVWF 0xB7
0E57  3002     MOVLW 0x2
0E58  35B5     LSLF 0xB5, F
0E59  0DB6     RLF 0xB6, F
0E5A  0DB7     RLF 0xB7, F
0E5B  0B89     DECFSZ 0x89, F
0E5C  2E58     GOTO 0x658
0E5D  0835     MOVF 0xB5, W
0E5E  0022     MOVLB 0x2
0E5F  00DD     MOVWF MTOUCH_prox_baseline
0E60  0020     MOVLB 0x0
0E61  0836     MOVF i, W
0E62  0022     MOVLB 0x2
0E63  00DE     MOVWF 0x15E
0E64  0020     MOVLB 0x0
0E65  0837     MOVF sample, W
0E66  0022     MOVLB 0x2
0E67  00DF     MOVWF 0x15F
0E68  01E0     CLRF 0x160
214:           
215:               delta = (int32_t)(MTOUCH_prox_reading - MTOUCH_prox_baseline);
0E69  0021     MOVLB 0x1
0E6A  085D     MOVF 0xDD, W
0E6B  0020     MOVLB 0x0
0E6C  00BC     MOVWF 0x3C
0E6D  0021     MOVLB 0x1
0E6E  085C     MOVF 0xDC, W
0E6F  0020     MOVLB 0x0
0E70  00BB     MOVWF sensor2
0E71  0021     MOVLB 0x1
0E72  085B     MOVF 0xDB, W
0E73  0020     MOVLB 0x0
0E74  00BA     MOVWF adc
0E75  0021     MOVLB 0x1
0E76  085A     MOVF MTOUCH_prox_reading, W
0E77  0020     MOVLB 0x0
0E78  00B9     MOVWF delta
0E79  0022     MOVLB 0x2
0E7A  085D     MOVF MTOUCH_prox_baseline, W
0E7B  0020     MOVLB 0x0
0E7C  02B9     SUBWF delta, F
0E7D  0022     MOVLB 0x2
0E7E  085E     MOVF 0x15E, W
0E7F  0020     MOVLB 0x0
0E80  3BBA     SUBWFB adc, F
0E81  0022     MOVLB 0x2
0E82  085F     MOVF 0x15F, W
0E83  0020     MOVLB 0x0
0E84  3BBB     SUBWFB sensor2, F
0E85  0022     MOVLB 0x2
0E86  0860     MOVF 0x160, W
0E87  0020     MOVLB 0x0
0E88  3BBC     SUBWFB 0x3C, F
216:           
217:               /* Clipping the negative side of the delta values. */
218:               if (delta < (int32_t)0)
0E89  1FBC     BTFSS 0x3C, 0x7
0E8A  2E8F     GOTO 0x68F
219:               { 
220:                   delta = (int32_t)0;
0E8B  01B9     CLRF delta
0E8C  01BA     CLRF adc
0E8D  01BB     CLRF sensor2
0E8E  01BC     CLRF 0x3C
221:               }
222:           
223:               MTOUCH_prox_filter -= MTOUCH_prox_filter >> (uint8_t)MTOUCH_PROX_GAIN;
0E8F  0021     MOVLB 0x1
0E90  0856     MOVF MTOUCH_prox_filter, W
0E91  0020     MOVLB 0x0
0E92  00B5     MOVWF delta
0E93  0021     MOVLB 0x1
0E94  0857     MOVF 0xD7, W
0E95  0020     MOVLB 0x0
0E96  00B6     MOVWF i
0E97  0021     MOVLB 0x1
0E98  0858     MOVF 0xD8, W
0E99  0020     MOVLB 0x0
0E9A  00B7     MOVWF sample
0E9B  0021     MOVLB 0x1
0E9C  0859     MOVF 0xD9, W
0E9D  0020     MOVLB 0x0
0E9E  00B8     MOVWF 0x38
0E9F  3002     MOVLW 0x2
0EA0  36B8     LSRF 0x38, F
0EA1  0CB7     RRF sample, F
0EA2  0CB6     RRF i, F
0EA3  0CB5     RRF delta, F
0EA4  0B89     DECFSZ WREG, F
0EA5  2EA0     GOTO 0x6A0
0EA6  0835     MOVF delta, W
0EA7  0021     MOVLB 0x1
0EA8  02D6     SUBWF MTOUCH_prox_filter, F
0EA9  0020     MOVLB 0x0
0EAA  0836     MOVF i, W
0EAB  0021     MOVLB 0x1
0EAC  3BD7     SUBWFB 0xD7, F
0EAD  0020     MOVLB 0x0
0EAE  0837     MOVF sample, W
0EAF  0021     MOVLB 0x1
0EB0  3BD8     SUBWFB 0xD8, F
0EB1  0020     MOVLB 0x0
0EB2  0838     MOVF 0x38, W
0EB3  0021     MOVLB 0x1
0EB4  3BD9     SUBWFB 0xD9, F
224:               MTOUCH_prox_filter += (uint32_t)delta;
0EB5  0020     MOVLB 0x0
0EB6  0839     MOVF delta, W
0EB7  0021     MOVLB 0x1
0EB8  07D6     ADDWF MTOUCH_prox_filter, F
0EB9  0020     MOVLB 0x0
0EBA  083A     MOVF adc, W
0EBB  0021     MOVLB 0x1
0EBC  3DD7     ADDWFC 0xD7, F
0EBD  0020     MOVLB 0x0
0EBE  083B     MOVF sensor2, W
0EBF  0021     MOVLB 0x1
0EC0  3DD8     ADDWFC 0xD8, F
0EC1  0020     MOVLB 0x0
0EC2  083C     MOVF 0x3C, W
0EC3  0021     MOVLB 0x1
0EC4  3DD9     ADDWFC 0xD9, F
225:           
226:           }
0EC5  0008     RETURN
227:           
228:           
229:           static uint32_t median_filter(uint32_t new_data)
230:           {
231:               uint8_t i = (uint8_t)0;
0EC6  01B4     CLRF 0xB4
232:               static uint8_t deleted;
233:               uint32_t temp_data;
234:               uint8_t new_index,temp_index;
235:           
236:               new_index=deleted;
0EC7  0862     MOVF MTOUCH_dataReady, W
0EC8  00B3     MOVWF 0xB3
237:               while (tap_index[i]!=deleted)
0EC9  0834     MOVF 0xB4, W
0ECA  3E2C     ADDLW 0x2C
0ECB  0086     MOVWF 0x86
0ECC  3001     MOVLW 0x1
0ECD  0087     MOVWF 0x87
0ECE  0801     MOVF 0x81, W
0ECF  0662     XORWF MTOUCH_dataReady, W
0ED0  1903     BTFSC 0x83, 0x2
0ED1  2F20     GOTO 0x720
0F1F  2EC9     GOTO 0x6C9
238:               {
239:                   if (filter_data[i]>new_data)
0ED2  0834     MOVF 0xB4, W
0ED3  0709     ADDWF 0x89, W
0ED4  0709     ADDWF 0x89, W
0ED5  3EA0     ADDLW 0xA0
0ED6  0086     MOVWF 0x86
0ED7  3F40     MOVIW [0]FSR1
0ED8  00AA     MOVWF 0xAA
0ED9  3F41     MOVIW [1]FSR1
0EDA  00AB     MOVWF 0xAB
0EDB  3F42     MOVIW [2]FSR1
0EDC  00AC     MOVWF 0xAC
0EDD  3F43     MOVIW [3]FSR1
0EDE  00AD     MOVWF 0xAD
0EDF  0229     SUBWF 0xA9, W
0EE0  1D03     BTFSS 0x83, 0x2
0EE1  2EEC     GOTO 0x6EC
0EE2  082C     MOVF 0xAC, W
0EE3  0228     SUBWF 0xA8, W
0EE4  1D03     BTFSS 0x83, 0x2
0EE5  2EEC     GOTO 0x6EC
0EE6  082B     MOVF 0xAB, W
0EE7  0227     SUBWF 0xA7, W
0EE8  1D03     BTFSS 0x83, 0x2
0EE9  2EEC     GOTO 0x6EC
0EEA  082A     MOVF 0xAA, W
0EEB  0226     SUBWF 0xA6, W
0EEC  1803     BTFSC 0x83, 0x0
0EED  2F1E     GOTO 0x71E
240:                   {
241:                       temp_data=filter_data[i];
0EEE  0834     MOVF 0xB4, W
0EEF  0709     ADDWF 0x89, W
0EF0  0709     ADDWF 0x89, W
0EF1  3EA0     ADDLW 0xA0
0EF2  0086     MOVWF 0x86
0EF3  3001     MOVLW 0x1
0EF4  0087     MOVWF 0x87
0EF5  3F40     MOVIW [0]FSR1
0EF6  00AE     MOVWF 0xAE
0EF7  3F41     MOVIW [1]FSR1
0EF8  00AF     MOVWF 0xAF
0EF9  3F42     MOVIW [2]FSR1
0EFA  00B0     MOVWF 0xB0
0EFB  3F43     MOVIW [3]FSR1
0EFC  00B1     MOVWF 0xB1
242:                       temp_index=tap_index[i];
0EFD  0834     MOVF 0xB4, W
0EFE  3E2C     ADDLW 0x2C
0EFF  0086     MOVWF 0x86
0F00  0801     MOVF 0x81, W
0F01  00B2     MOVWF MTOUCH_diffResult
243:                       filter_data[i]=new_data;
0F02  0834     MOVF 0xB4, W
0F03  0709     ADDWF 0x89, W
0F04  0709     ADDWF 0x89, W
0F05  3EA0     ADDLW 0xA0
0F06  0086     MOVWF 0x86
0F07  0826     MOVF 0xA6, W
0F08  3FC0     MOVWI [0]FSR1
0F09  0827     MOVF 0xA7, W
0F0A  3FC1     MOVWI [1]FSR1
0F0B  0828     MOVF 0xA8, W
0F0C  3FC2     MOVWI [2]FSR1
0F0D  0829     MOVF 0xA9, W
0F0E  3FC3     MOVWI [3]FSR1
244:                       tap_index[i]=new_index;
0F0F  0834     MOVF 0xB4, W
0F10  3E2C     ADDLW 0x2C
0F11  0086     MOVWF 0x86
0F12  0833     MOVF 0xB3, W
0F13  0081     MOVWF 0x81
245:                       new_data=temp_data;
0F14  0831     MOVF 0xB1, W
0F15  00A9     MOVWF 0xA9
0F16  0830     MOVF 0xB0, W
0F17  00A8     MOVWF 0xA8
0F18  082F     MOVF 0xAF, W
0F19  00A7     MOVWF 0xA7
0F1A  082E     MOVF 0xAE, W
0F1B  00A6     MOVWF 0xA6
246:                       new_index=temp_index;
0F1C  0832     MOVF MTOUCH_diffResult, W
0F1D  00B3     MOVWF 0xB3
247:                   }
248:                   i++;
0F1E  0AB4     INCF 0xB4, F
249:               }
250:               filter_data[i]=new_data;
0F20  0834     MOVF 0xB4, W
0F21  0709     ADDWF 0x89, W
0F22  0709     ADDWF 0x89, W
0F23  3EA0     ADDLW 0xA0
0F24  0086     MOVWF 0x86
0F25  3001     MOVLW 0x1
0F26  0087     MOVWF 0x87
0F27  0826     MOVF 0xA6, W
0F28  3FC0     MOVWI [0]FSR1
0F29  0827     MOVF 0xA7, W
0F2A  3FC1     MOVWI [1]FSR1
0F2B  0828     MOVF 0xA8, W
0F2C  3FC2     MOVWI [2]FSR1
0F2D  0829     MOVF 0xA9, W
0F2E  3FC3     MOVWI [3]FSR1
251:               tap_index[i]=new_index;
0F2F  0834     MOVF 0xB4, W
0F30  3E2C     ADDLW 0x2C
0F31  0086     MOVWF 0x86
0F32  0833     MOVF 0xB3, W
0F33  0081     MOVWF 0x81
252:               for (;i<MTOUCH_MEDIAN_FILTER_TAP-1;i++)
0F6D  0AB4     INCF 0xB4, F
0F6E  3006     MOVLW 0x6
0F6F  0234     SUBWF 0xB4, W
0F70  1803     BTFSC 0x83, 0x0
0F71  2F91     GOTO 0x791
253:               {
254:                   if(new_data>filter_data[i+1])
0F34  2F6E     GOTO 0x76E
0F72  0834     MOVF 0xB4, W
0F73  0709     ADDWF 0x89, W
0F74  0709     ADDWF 0x89, W
0F75  3EA4     ADDLW 0xA4
0F76  0086     MOVWF 0x86
0F77  3001     MOVLW 0x1
0F78  0087     MOVWF 0x87
0F79  3F40     MOVIW [0]FSR1
0F7A  00AA     MOVWF 0xAA
0F7B  3F41     MOVIW [1]FSR1
0F7C  00AB     MOVWF 0xAB
0F7D  3F42     MOVIW [2]FSR1
0F7E  00AC     MOVWF 0xAC
0F7F  3F43     MOVIW [3]FSR1
0F80  00AD     MOVWF 0xAD
0F81  0829     MOVF 0xA9, W
0F82  022D     SUBWF 0xAD, W
0F83  1D03     BTFSS 0x83, 0x2
0F84  2F8F     GOTO 0x78F
0F85  0828     MOVF 0xA8, W
0F86  022C     SUBWF 0xAC, W
0F87  1D03     BTFSS 0x83, 0x2
0F88  2F8F     GOTO 0x78F
0F89  0827     MOVF 0xA7, W
0F8A  022B     SUBWF 0xAB, W
0F8B  1D03     BTFSS 0x83, 0x2
0F8C  2F8F     GOTO 0x78F
0F8D  0826     MOVF 0xA6, W
0F8E  022A     SUBWF 0xAA, W
0F8F  1C03     BTFSS 0x83, 0x0
0F90  2F35     GOTO 0x735
255:                   {
256:                       filter_data[i]=filter_data[i+1];
0F35  0834     MOVF 0xB4, W
0F36  0709     ADDWF 0x89, W
0F37  0709     ADDWF 0x89, W
0F38  3EA4     ADDLW 0xA4
0F39  0086     MOVWF 0x86
0F3A  3001     MOVLW 0x1
0F3B  0087     MOVWF 0x87
0F3C  3F40     MOVIW [0]FSR1
0F3D  00AA     MOVWF 0xAA
0F3E  3F41     MOVIW [1]FSR1
0F3F  00AB     MOVWF 0xAB
0F40  3F42     MOVIW [2]FSR1
0F41  00AC     MOVWF 0xAC
0F42  3F43     MOVIW [3]FSR1
0F43  00AD     MOVWF 0xAD
0F44  0834     MOVF 0xB4, W
0F45  0709     ADDWF 0x89, W
0F46  0709     ADDWF 0x89, W
0F47  3EA0     ADDLW 0xA0
0F48  0086     MOVWF 0x86
0F49  082A     MOVF 0xAA, W
0F4A  3FC0     MOVWI [0]FSR1
0F4B  082B     MOVF 0xAB, W
0F4C  3FC1     MOVWI [1]FSR1
0F4D  082C     MOVF 0xAC, W
0F4E  3FC2     MOVWI [2]FSR1
0F4F  082D     MOVF 0xAD, W
0F50  3FC3     MOVWI [3]FSR1
257:                       tap_index[i]=tap_index[i+1];
0F51  0834     MOVF 0xB4, W
0F52  3E2C     ADDLW 0x2C
0F53  0086     MOVWF 0x86
0F54  0834     MOVF 0xB4, W
0F55  3E2D     ADDLW 0x2D
0F56  0084     MOVWF 0x84
0F57  3001     MOVLW 0x1
0F58  0085     MOVWF 0x85
0F59  0800     MOVF 0x80, W
0F5A  0081     MOVWF 0x81
258:                       filter_data[i+1]=new_data;
0F5B  0834     MOVF 0xB4, W
0F5C  0709     ADDWF 0x89, W
0F5D  0709     ADDWF 0x89, W
0F5E  3EA4     ADDLW 0xA4
0F5F  0086     MOVWF 0x86
0F60  0826     MOVF 0xA6, W
0F61  3FC0     MOVWI [0]FSR1
0F62  0827     MOVF 0xA7, W
0F63  3FC1     MOVWI [1]FSR1
0F64  0828     MOVF 0xA8, W
0F65  3FC2     MOVWI [2]FSR1
0F66  0829     MOVF 0xA9, W
0F67  3FC3     MOVWI [3]FSR1
259:                       tap_index[i+1]=new_index;
0F68  0834     MOVF 0xB4, W
0F69  3E2D     ADDLW 0x2D
0F6A  0086     MOVWF 0x86
0F6B  0833     MOVF 0xB3, W
0F6C  0081     MOVWF 0x81
260:                   }
261:                   else
262:                       break;
263:               }
264:               if (++deleted>=MTOUCH_MEDIAN_FILTER_TAP)
0F91  3007     MOVLW 0x7
0F92  0AE2     INCF MTOUCH_dataReady, F
0F93  0262     SUBWF MTOUCH_dataReady, W
0F94  1803     BTFSC 0x83, 0x0
265:                   deleted = (uint8_t)0;
0F95  01E2     CLRF MTOUCH_dataReady
266:           
267:               return filter_data[MTOUCH_MEDIAN_FILTER_TAP/2];
0F96  300C     MOVLW 0xC
0F97  3EA0     ADDLW 0xA0
0F98  0086     MOVWF 0x86
0F99  3001     MOVLW 0x1
0F9A  0087     MOVWF 0x87
0F9B  3F40     MOVIW [0]FSR1
0F9C  00A6     MOVWF 0xA6
0F9D  3F41     MOVIW [1]FSR1
0F9E  00A7     MOVWF 0xA7
0F9F  3F42     MOVIW [2]FSR1
0FA0  00A8     MOVWF 0xA8
0FA1  3F43     MOVIW [3]FSR1
0FA2  00A9     MOVWF 0xA9
268:           }
0FA3  0008     RETURN
269:           
270:           #endif
---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/mtouch.c
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            
37:            #pragma warning disable 1395 /* 'Notable code sequence' message */
38:            
39:            #include <stdint.h>
40:            
41:            #include "configuration.h"
42:            #include "mtouch.h"
43:            
44:                    extern MTOUCH_FLAGS_t      MTOUCH_flags;
45:            
46:            /* Global variables */
47:                    enum MTOUCH_STATE   MTOUCH_button_state             [MTOUCH_SENSORS];
48:                    MTOUCH_READING_t    MTOUCH_reading                  [MTOUCH_SENSORS];
49:                    uint8_t             MTOUCH_delta_scaling            [MTOUCH_SENSORS];
50:                    uint8_t             MTOUCH_button_debounce          [MTOUCH_SENSORS];
51:                    MTOUCH_DELTA_t      MTOUCH_delta                    [MTOUCH_SENSORS];
52:            
53:                    MTOUCH_DELTA_t      MTOUCH_button_threshold         [MTOUCH_SENSORS] =
0841  3064     MOVLW 0x64
0843  3064     MOVLW 0x64
0845  3064     MOVLW 0x64
0847  3064     MOVLW 0x64
0849  3064     MOVLW 0x64
084B  3064     MOVLW 0x64
54:                    {
55:                         (MTOUCH_DELTA_t)MTOUCH_BUTTON_THRESHOLD0
56:                        #if (MTOUCH_SENSORS > 1)
57:                        ,(MTOUCH_DELTA_t)MTOUCH_BUTTON_THRESHOLD1
58:                        #endif
59:                        #if (MTOUCH_SENSORS > 2)
60:                        ,(MTOUCH_DELTA_t)MTOUCH_BUTTON_THRESHOLD2
61:                        #endif
62:                        #if (MTOUCH_SENSORS > 3)
63:                        ,(MTOUCH_DELTA_t)MTOUCH_BUTTON_THRESHOLD3
64:                        #endif
65:                        #if (MTOUCH_SENSORS > 4)
66:                        ,(MTOUCH_DELTA_t)MTOUCH_BUTTON_THRESHOLD4
67:                        #endif
68:                        #if (MTOUCH_SENSORS > 5)
69:                        ,(MTOUCH_DELTA_t)MTOUCH_BUTTON_THRESHOLD5
70:                        #endif
71:                        #if (MTOUCH_SENSORS > 6)
72:                        #error("Edit required in MTOUCH_Button_StateMachine threshold array initialization to support additional sensors.")
73:                        #endif
74:                    };
75:            
76:            #if defined(CONFIGURABLE_BASELINEGAIN)
77:                    uint8_t             MTOUCH_baselineGain;
78:            #endif
79:            #if defined(CONFIGURABLE_BASELINERATE)
80:                    uint8_t             MTOUCH_baselineRate;
81:            #endif
82:            #if defined(CONFIGURABLE_NEGDELTACOUNTS)
83:                    uint8_t             MTOUCH_negDeltaCount;
84:            #endif
85:            #if defined(CONFIGURABLE_PRESSTIMEOUT)
86:                    uint8_t             MTOUCH_pressTimeout;
87:            #endif
88:            #if defined(CONFIGURABLE_DEBOUNCE)
89:                    uint8_t             MTOUCH_debounce;
90:            #endif
91:            
92:            /* Local variables */
93:            static  uint8_t             MTOUCH_mostPressed_index;
94:            static  MTOUCH_DELTA_t      MTOUCH_mostPressed_delta;
95:                    MTOUCH_DELTA_t      MTOUCH_mostPressed_threshold;
96:            
97:            
98:            static  MTOUCH_BASELINE_t   MTOUCH_baseline                 [MTOUCH_SENSORS];
99:            static  uint8_t             MTOUCH_baseline_count           [MTOUCH_SENSORS];
100:           
101:           typedef uint16_t            RESET_COUNT_t;
102:                   RESET_COUNT_t       MTOUCH_baseline_reset_count     [MTOUCH_SENSORS];
103:           
104:           /* Local Functions */
105:           static void             MTOUCH_Button_StateMachine      (uint8_t sensor);
106:           static void             MTOUCH_Sensor_Baseline_Update   (uint8_t sensor);
107:           static void             MTOUCH_Sensor_Delta_Calculate   (uint8_t sensor);
108:           
109:           
110:           /*
111:            *  PUBLIC FUNCTION
112:            *
113:            *  Initializes all mTouch scanning variables, the ADC, and Timer0 which is used
114:            *  as the scan interrupt.
115:            */
116:           void MTOUCH_Init(void)
117:           {
118:               uint8_t i;
119:               
120:               for (i = (uint8_t)0; i < (uint8_t)MTOUCH_SENSORS; i++)
0BC1  0020     MOVLB 0x0
0BC2  01A2     CLRF i
0BCF  3006     MOVLW 0x6
0BD0  0AA2     INCF i, F
0BD1  0222     SUBWF i, W
0BD2  1C03     BTFSS STATUS, 0x0
0BD3  2BC3     GOTO 0x3C3
121:               {
122:                   MTOUCH_button_state [i] = MTOUCH_STATE_initializing;
0BC3  0822     MOVF i, W
0BC4  3E45     ADDLW 0x45
0BC5  0086     MOVWF FSR1
0BC6  3001     MOVLW 0x1
0BC7  0087     MOVWF FSR1H
0BC8  0181     CLRF INDF1
123:                   MTOUCH_delta_scaling[i] = MTOUCH_DELTA_SCALING;
0BC9  0822     MOVF i, W
0BCA  3ECA     ADDLW 0xCA
0BCB  0086     MOVWF FSR1
0BCC  3009     MOVLW 0x9
0BCD  0187     CLRF FSR1H
0BCE  0081     MOVWF INDF1
124:               }
125:               MTOUCH_mostPressed_threshold = MTOUCH_MOSTPRESSED_THRESHOLD;
0BD4  300A     MOVLW 0xA
0BD5  0021     MOVLB 0x1
0BD6  00E4     MOVWF MTOUCH_mostPressed_threshold
126:           
127:               #if defined(CONFIGURABLE_BASELINEGAIN)
128:               MTOUCH_baselineGain = MTOUCH_BASELINE_GAIN;
0BD7  3004     MOVLW 0x4
0BD8  0020     MOVLB 0x0
0BD9  00D3     MOVWF MTOUCH_baselineGain
129:               #endif
130:               #if defined(CONFIGURABLE_BASELINERATE)
131:               MTOUCH_baselineRate = MTOUCH_BASELINE_RATE;
0BDA  300A     MOVLW 0xA
0BDB  00D4     MOVWF MTOUCH_baselineRate
132:               #endif
133:               #if defined(CONFIGURABLE_NEGDELTACOUNTS)
134:               MTOUCH_negDeltaCount = MTOUCH_NEGATIVEDELTA_COUNTS;
0BDC  3020     MOVLW 0x20
0BDD  00DA     MOVWF MTOUCH_negDeltaCount
135:               #endif
136:               #if defined(CONFIGURABLE_PRESSTIMEOUT)
137:               MTOUCH_pressTimeout = MTOUCH_PRESSTIMEOUT_COUNTS;
0BDE  300A     MOVLW 0xA
0BDF  00DC     MOVWF MTOUCH_pressTimeout
138:               #endif
139:               #if defined(CONFIGURABLE_DEBOUNCE)
140:               MTOUCH_debounce = MTOUCH_DEBOUNCE;
0BE0  01D5     CLRF MTOUCH_debounce
141:               #endif
142:               
143:               MTOUCH_Scan_Init();
0BE1  27A4     CALL 0x7A4
144:           
145:               #if defined(MTOUCH_PROXIMITY_ENABLED)
146:               MTOUCH_Proximity_Init();
0BE2  3194     MOVLP 0x14
147:               #endif
148:           
149:               #if defined(MTOUCH_SLIDER_ENABLED)
150:               MTOUCH_Slider_Init();
151:               #endif
152:           
153:               #if defined(MTOUCH_MATRIX_ENABLED)
154:               MTOUCH_Matrix_Init();
155:               #endif
156:           }
157:           
158:           /*
159:            *  PUBLIC FUNCTION
160:            *
161:            *  An mTouch service function designed to be called at a regular 10ms rate out
162:            *  of the main loop. Calls the sensor state machine on any sensor with new data
163:            *  to decode, and updates the baseline at a fixed rate.
164:            */
165:           void MTOUCH_Decode(void)
166:           {
167:               uint8_t i;
168:               MTOUCH_DELTA_t delta;
169:               MTOUCH_DELTA_t biggestDelta = 0;
087C  0020     MOVLB 0x0
087D  01C0     CLRF biggestDelta
170:               MTOUCH_DELTA_t secondDelta  = 0;
087E  01BE     CLRF secondDelta
171:           
172:               for (i = (uint8_t)0; i < (uint8_t)MTOUCH_SENSORS; i++)
087F  01C1     CLRF i
0883  3006     MOVLW 0x6
0884  0AC1     INCF i, F
0885  0241     SUBWF i, W
0886  1C03     BTFSS STATUS, 0x0
0887  2880     GOTO 0x80
173:               {
174:                   MTOUCH_Sensor_Delta_Calculate(i);
0880  0841     MOVF i, W
0881  22DE     CALL 0x2DE
0882  3188     MOVLP 0x8
175:               }
176:           
177:           #if defined(CONFIGURABLE_MOSTPRESSED)
178:               if (MTOUCH_flags.mostPressed == 1)
0888  1F56     BTFSS MTOUCH_flags, 0x6
0889  28B2     GOTO 0xB2
179:               {
180:           #endif
181:                   for (i = (uint8_t)0; i < (uint8_t)MTOUCH_SENSORS; i++)
088A  01C1     CLRF i
182:                   {
183:                       delta = MTOUCH_Sensor_Delta_Get(i);
088B  0841     MOVF i, W
088C  2174     CALL 0x174
088D  3188     MOVLP 0x8
088E  00BF     MOVWF delta
184:                       if (delta > biggestDelta)
088F  0840     MOVF biggestDelta, W
0890  3A80     XORLW 0x80
0891  00BD     MOVWF 0x3D
0892  083F     MOVF delta, W
0893  3A80     XORLW 0x80
0894  02BD     SUBWF 0x3D, F
0895  1803     BTFSC STATUS, 0x0
0896  289E     GOTO 0x9E
185:                       {
186:                           secondDelta = biggestDelta;
0897  0840     MOVF biggestDelta, W
0898  00BE     MOVWF secondDelta
187:                           biggestDelta = delta;
0899  083F     MOVF delta, W
089A  00C0     MOVWF biggestDelta
188:                           MTOUCH_mostPressed_index = i;
089B  0841     MOVF i, W
089C  00D9     MOVWF MTOUCH_mostPressed_index
189:                           MTOUCH_mostPressed_delta = biggestDelta - secondDelta;
08A8  083E     MOVF secondDelta, W
08A9  0240     SUBWF biggestDelta, W
08AA  0021     MOVLB 0x1
08AB  00E3     MOVWF MTOUCH_mostPressed_delta
190:                       }
089D  28A8     GOTO 0xA8
191:                       else if (delta > secondDelta)
089E  083E     MOVF MTOUCH_singleResult, W
089F  3A80     XORLW 0x80
08A0  00BD     MOVWF 0xBD
08A1  083F     MOVF 0xBF, W
08A2  3A80     XORLW 0x80
08A3  02BD     SUBWF 0xBD, F
08A4  1803     BTFSC 0x83, 0x0
08A5  28AC     GOTO 0xAC
192:                       {
193:                           secondDelta = delta;
08A6  083F     MOVF 0xBF, W
08A7  00BE     MOVWF MTOUCH_singleResult
194:                           MTOUCH_mostPressed_delta = biggestDelta - secondDelta;
195:                       }
196:                   }
08AC  0020     MOVLB 0x0
08AD  3006     MOVLW 0x6
08AE  0AC1     INCF i, F
08AF  0241     SUBWF i, W
08B0  1C03     BTFSS STATUS, 0x0
08B1  288B     GOTO 0x8B
197:           #if defined(CONFIGURABLE_MOSTPRESSED)
198:               }
199:           #endif
200:           
201:               for (i = (uint8_t)0; i < (uint8_t)MTOUCH_SENSORS; i++)
08B2  01C1     CLRF i
08B6  0020     MOVLB 0x0
08B7  3006     MOVLW 0x6
08B8  0AC1     INCF i, F
08B9  0241     SUBWF i, W
08BA  1C03     BTFSS STATUS, 0x0
08BB  28B3     GOTO 0xB3
202:               {
203:                   MTOUCH_Button_StateMachine(i);
08B3  0841     MOVF i, W
08B4  217B     CALL 0x17B
08B5  3188     MOVLP 0x8
204:               }
205:           
206:               #if defined(MTOUCH_PROXIMITY_ENABLED)
207:               MTOUCH_Proximity_Decode();
08BC  22DB     CALL 0x2DB
08BD  3188     MOVLP 0x8
208:               #endif
209:           
210:               #if defined(MTOUCH_SLIDER_ENABLED)
211:               MTOUCH_Slider_Decode();
212:               #endif
213:           
214:               #if defined(MTOUCH_MATRIX_ENABLED)
215:               MTOUCH_Matrix_Decode();
216:               #endif
217:           
218:               for (i = (uint8_t)0; i < (uint8_t)MTOUCH_SENSORS; i++)
08BE  0020     MOVLB 0x0
08BF  01C1     CLRF i
08D4  3006     MOVLW 0x6
08D5  0AC1     INCF i, F
08D6  0241     SUBWF i, W
08D7  1803     BTFSC STATUS, 0x0
08D8  0008     RETURN
08D9  28C0     GOTO 0xC0
219:               {
220:                   MTOUCH_baseline_count[i]++;
08C0  0841     MOVF i, W
08C1  3E39     ADDLW 0x39
08C2  0086     MOVWF FSR1
08C3  3001     MOVLW 0x1
08C4  0087     MOVWF FSR1H
08C5  0A81     INCF INDF1, F
221:                   #if defined(CONFIGURABLE_BASELINERATE)
222:                   if (MTOUCH_baseline_count[i] >= (uint8_t)MTOUCH_baselineRate)
08C6  0841     MOVF i, W
08C7  3E39     ADDLW 0x39
08C8  0086     MOVWF FSR1
08C9  0854     MOVF MTOUCH_baselineRate, W
08CA  0201     SUBWF INDF1, W
08CB  1C03     BTFSS STATUS, 0x0
08CC  28D4     GOTO 0xD4
223:                   #else
224:                   if (MTOUCH_baseline_count[i] >= (uint8_t)MTOUCH_BASELINE_RATE)
225:                   #endif
226:                   {
227:                       MTOUCH_baseline_count[i] = (uint8_t)0;
08CD  0841     MOVF i, W
08CE  3E39     ADDLW 0x39
08CF  0086     MOVWF FSR1
08D0  0181     CLRF INDF1
228:                       MTOUCH_Sensor_Baseline_Update(i);
08D1  0841     MOVF i, W
08D2  20DA     CALL 0xDA
08D3  3188     MOVLP 0x8
229:                   }
230:               }
231:           }
232:           
233:           /*
234:            *  PUBLIC FUNCTION
235:            *
236:            *  Safely returns the current reading value for the requested sensor.
237:            */
238:           MTOUCH_READING_t MTOUCH_Sensor_Reading_Get(uint8_t sensor)
03C4  00F4     MOVWF sensor
0944  0020     MOVLB 0x0
0945  00A5     MOVWF counter
239:           {
240:               return MTOUCH_reading[sensor];
03C5  0774     ADDWF sensor, W
03C6  0774     ADDWF sensor, W
03C7  3ED4     ADDLW 0xD4
03C8  0086     MOVWF FSR1
03C9  3001     MOVLW 0x1
03CA  0087     MOVWF FSR1H
03CB  3F40     MOVIW [0]FSR1
03CC  00F0     MOVWF __pcstackCOMMON
03CD  3F41     MOVIW [1]FSR1
03CE  00F1     MOVWF value
03CF  3F42     MOVIW [2]FSR1
03D0  00F2     MOVWF nibble
0946  0725     ADDWF counter, W
0947  0725     ADDWF counter, W
0948  3ED4     ADDLW 0xD4
0949  0086     MOVWF FSR1
094A  3001     MOVLW 0x1
094B  0087     MOVWF FSR1H
094C  3F40     MOVIW [0]FSR1
094D  00A1     MOVWF divisor
094E  3F41     MOVIW [1]FSR1
094F  00A2     MOVWF i
0950  3F42     MOVIW [2]FSR1
0951  00A3     MOVWF dividend
241:           }
03D1  0008     RETURN
0952  0008     RETURN
242:           
243:           
244:           /*
245:            *  PRIVATE FUNCTION
246:            *
247:            *  Updates the requested sensor's baseline, based on the current state of the
248:            *  sensor and the current reading value.
249:            */
250:           static void MTOUCH_Sensor_Baseline_Update(uint8_t sensor)
08DA  00AD     MOVWF sensor
251:           {
252:               if (MTOUCH_button_state[sensor] == MTOUCH_STATE_initializing)
08DB  3E45     ADDLW 0x45
08DC  0086     MOVWF FSR1
08DD  3001     MOVLW 0x1
08DE  0087     MOVWF FSR1H
08DF  0881     MOVF INDF1, F
08E0  1D03     BTFSS STATUS, 0x2
08E1  2904     GOTO 0x104
253:               {
254:                   #if defined(CONFIGURABLE_BASELINEGAIN)
255:                   MTOUCH_baseline[sensor] = (MTOUCH_BASELINE_t)((MTOUCH_BASELINE_t)(MTOUCH_Sensor_Reading_Get(sensor)) << (uint8_t)MTOUCH_baselineGain);
08E2  082D     MOVF sensor, W
08E3  2144     CALL 0x144
08E4  3188     MOVLP 0x8
08E5  0821     MOVF divisor, W
08E6  00A9     MOVWF delta
08E7  0822     MOVF i, W
08E8  00AA     MOVWF dataReady
08E9  0823     MOVF dividend, W
08EA  00AB     MOVWF i
08EB  01AC     CLRF delta
08EC  0A53     INCF MTOUCH_baselineGain, W
08ED  28F2     GOTO 0xF2
08EE  35A9     LSLF delta, F
08EF  0DAA     RLF dataReady, F
08F0  0DAB     RLF i, F
08F1  0DAC     RLF delta, F
08F2  0B89     DECFSZ WREG, F
08F3  28EE     GOTO 0xEE
08F4  082D     MOVF sensor, W
08F5  0709     ADDWF WREG, W
08F6  0709     ADDWF WREG, W
08F7  3EBC     ADDLW 0xBC
08F8  0086     MOVWF FSR1
08F9  3001     MOVLW 0x1
08FA  0087     MOVWF FSR1H
08FB  0829     MOVF delta, W
08FC  3FC0     MOVWI [0]FSR1
08FD  082A     MOVF dataReady, W
08FE  3FC1     MOVWI [1]FSR1
08FF  082B     MOVF i, W
0900  3FC2     MOVWI [2]FSR1
0901  082C     MOVF delta, W
0902  3FC3     MOVWI [3]FSR1
256:                   #else
257:                   MTOUCH_baseline[sensor] = (MTOUCH_BASELINE_t)((MTOUCH_BASELINE_t)(MTOUCH_Sensor_Reading_Get(sensor)) << (uint8_t)MTOUCH_BASELINE_GAIN);
258:                   #endif
259:               }
0903  0008     RETURN
260:               else if (MTOUCH_button_state[sensor] == MTOUCH_STATE_released)
0904  082D     MOVF sensor, W
0905  3E45     ADDLW 0x45
0906  0086     MOVWF FSR1
0907  3001     MOVLW 0x1
0908  0087     MOVWF FSR1H
0909  0B01     DECFSZ INDF1, W
090A  0008     RETURN
261:               {
262:                   MTOUCH_baseline[sensor] -= MTOUCH_Sensor_Baseline_Get(sensor);
090B  082D     MOVF sensor, W
090C  2153     CALL 0x153
090D  3188     MOVLP 0x8
090E  0821     MOVF divisor, W
090F  00A9     MOVWF delta
0910  0822     MOVF i, W
0911  00AA     MOVWF dataReady
0912  0823     MOVF dividend, W
0913  00AB     MOVWF i
0914  01AC     CLRF delta
0915  082D     MOVF sensor, W
0916  0709     ADDWF WREG, W
0917  0709     ADDWF WREG, W
0918  3EBC     ADDLW 0xBC
0919  0086     MOVWF FSR1
091A  3001     MOVLW 0x1
091B  0087     MOVWF FSR1H
091C  0829     MOVF delta, W
091D  0281     SUBWF INDF1, F
091E  3141     ADDFSR 1, 1
091F  082A     MOVF dataReady, W
0920  3B81     SUBWFB INDF1, F
0921  3141     ADDFSR 1, 1
0922  082B     MOVF i, W
0923  3B81     SUBWFB INDF1, F
0924  3141     ADDFSR 1, 1
0925  082C     MOVF delta, W
0926  3B81     SUBWFB INDF1, F
0927  317D     ADDFSR 1, -3
263:                   MTOUCH_baseline[sensor] += MTOUCH_Sensor_Reading_Get(sensor);
0928  082D     MOVF sensor, W
0929  2144     CALL 0x144
092A  0821     MOVF divisor, W
092B  00A9     MOVWF delta
092C  0822     MOVF i, W
092D  00AA     MOVWF dataReady
092E  0823     MOVF dividend, W
092F  00AB     MOVWF i
0930  01AC     CLRF delta
0931  082D     MOVF sensor, W
0932  0709     ADDWF WREG, W
0933  0709     ADDWF WREG, W
0934  3EBC     ADDLW 0xBC
0935  0086     MOVWF FSR1
0936  3001     MOVLW 0x1
0937  0087     MOVWF FSR1H
0938  0829     MOVF delta, W
0939  0781     ADDWF INDF1, F
093A  3141     ADDFSR 1, 1
093B  082A     MOVF dataReady, W
093C  3D81     ADDWFC INDF1, F
093D  3141     ADDFSR 1, 1
093E  082B     MOVF i, W
093F  3D81     ADDWFC INDF1, F
0940  3141     ADDFSR 1, 1
0941  082C     MOVF delta, W
0942  3D81     ADDWFC INDF1, F
264:               }
265:               else
266:               {
267:                   /* Do nothing when the sensor is pressed. */
268:               }
269:           }
0943  0008     RETURN
270:           
271:           /*
272:            *  PUBLIC FUNCTION
273:            *
274:            *  Safely returns the current baseline value for the requested sensor. The
275:            *  value is scaled to have the same gain as the reading, so that it is directly
276:            *  comparable without any additional logic.
277:            */
278:           MTOUCH_READING_t MTOUCH_Sensor_Baseline_Get(uint8_t sensor)
03A4  00F7     MOVWF sensor
0953  0020     MOVLB 0x0
0954  00A8     MOVWF sensor
279:           {
280:               #if defined(CONFIGURABLE_BASELINEGAIN)
281:               return (MTOUCH_READING_t)(MTOUCH_baseline[sensor] >> (uint8_t)MTOUCH_baselineGain);
03A5  0709     ADDWF WREG, W
03A6  0709     ADDWF WREG, W
03A7  3EBC     ADDLW 0xBC
03A8  0086     MOVWF FSR1
03A9  3001     MOVLW 0x1
03AA  0087     MOVWF FSR1H
03AB  3F40     MOVIW [0]FSR1
03AC  00F3     MOVWF i
03AD  3F41     MOVIW [1]FSR1
03AE  00F4     MOVWF sensor
03AF  3F42     MOVIW [2]FSR1
03B0  00F5     MOVWF 0x75
03B1  3F43     MOVIW [3]FSR1
03B2  00F6     MOVWF 0x76
03B3  0A53     INCF MTOUCH_baselineGain, W
03B4  2BBA     GOTO 0x3BA
03B5  1003     BCF STATUS, 0x0
03B6  0CF6     RRF 0x76, F
03B7  0CF5     RRF 0x75, F
03B8  0CF4     RRF sensor, F
03B9  0CF3     RRF i, F
03BA  3EFF     ADDLW 0xFF
03BB  1D03     BTFSS STATUS, 0x2
03BC  2BB5     GOTO 0x3B5
03BD  0875     MOVF 0x75, W
03BE  00F2     MOVWF nibble
03BF  0874     MOVF sensor, W
03C0  00F1     MOVWF value
03C1  0873     MOVF i, W
03C2  00F0     MOVWF __pcstackCOMMON
0955  0709     ADDWF WREG, W
0956  0709     ADDWF WREG, W
0957  3EBC     ADDLW 0xBC
0958  0086     MOVWF FSR1
0959  3001     MOVLW 0x1
095A  0087     MOVWF FSR1H
095B  3F40     MOVIW [0]FSR1
095C  00A4     MOVWF 0x24
095D  3F41     MOVIW [1]FSR1
095E  00A5     MOVWF counter
095F  3F42     MOVIW [2]FSR1
0960  00A6     MOVWF sign
0961  3F43     MOVIW [3]FSR1
0962  00A7     MOVWF quotient
0963  0A53     INCF MTOUCH_baselineGain, W
0964  296A     GOTO 0x16A
0965  1003     BCF STATUS, 0x0
0966  0CA7     RRF quotient, F
0967  0CA6     RRF sign, F
0968  0CA5     RRF counter, F
0969  0CA4     RRF 0x24, F
096A  3EFF     ADDLW 0xFF
096B  1D03     BTFSS STATUS, 0x2
096C  2965     GOTO 0x165
096D  0826     MOVF sign, W
096E  00A3     MOVWF dividend
096F  0825     MOVF counter, W
0970  00A2     MOVWF i
0971  0824     MOVF 0x24, W
0972  00A1     MOVWF divisor
282:               #else
283:               return (MTOUCH_READING_t)(MTOUCH_baseline[sensor] >> (uint8_t)MTOUCH_BASELINE_GAIN);
284:               #endif
285:           }
03C3  0008     RETURN
0973  0008     RETURN
286:           
287:           /*
288:            *  PUBLIC FUNCTION
289:            *
290:            *  Safely returns the difference between the baseline and the current sensor
291:            *  reading. Protects against overflow and provides thread safety.
292:            */
293:           MTOUCH_DELTA_t MTOUCH_Sensor_Delta_Get(uint8_t sensor)
039D  00F0     MOVWF __pcstackCOMMON
0974  00A1     MOVWF divisor
294:           {
295:               return MTOUCH_delta[sensor];
039E  3E51     ADDLW 0x51
039F  0086     MOVWF FSR1
03A0  3001     MOVLW 0x1
03A1  0087     MOVWF FSR1H
03A2  0801     MOVF INDF1, W
0975  3E51     ADDLW 0x51
0976  0086     MOVWF FSR1
0977  3001     MOVLW 0x1
0978  0087     MOVWF FSR1H
0979  0801     MOVF INDF1, W
296:           }
03A3  0008     RETURN
097A  0008     RETURN
297:           
298:           static void MTOUCH_Sensor_Delta_Calculate(uint8_t sensor)
0ADE  00B4     MOVWF sensor
299:           {
300:               int32_t delta;
301:               uint8_t i;
302:           
303:               delta = (int32_t)((int32_t)(MTOUCH_Sensor_Reading_Get(sensor)) - (int32_t)(MTOUCH_Sensor_Baseline_Get(sensor)));
0ADF  2144     CALL 0x144
0AE0  3188     MOVLP 0x8
0AE1  0821     MOVF divisor, W
0AE2  00B5     MOVWF delta
0AE3  0822     MOVF i, W
0AE4  00B6     MOVWF i
0AE5  0823     MOVF dividend, W
0AE6  00B7     MOVWF sample
0AE7  01B8     CLRF 0x38
0AE8  0834     MOVF sensor, W
0AE9  2153     CALL 0x153
0AEA  3188     MOVLP 0x8
0AEB  0821     MOVF divisor, W
0AEC  00AF     MOVWF 0x2F
0AED  0822     MOVF i, W
0AEE  00B0     MOVWF 0x30
0AEF  0823     MOVF dividend, W
0AF0  00B1     MOVWF 0x31
0AF1  01B2     CLRF delta
0AF2  082F     MOVF 0x2F, W
0AF3  02B5     SUBWF delta, F
0AF4  0830     MOVF 0x30, W
0AF5  3BB6     SUBWFB i, F
0AF6  0831     MOVF 0x31, W
0AF7  3BB7     SUBWFB sample, F
0AF8  0832     MOVF delta, W
0AF9  3BB8     SUBWFB 0x38, F
304:           
305:               for (i = MTOUCH_delta_scaling[sensor]; i > 0; i--)
0AFA  0834     MOVF sensor, W
0AFB  3ECA     ADDLW 0xCA
0AFC  0086     MOVWF FSR1
0AFD  0187     CLRF FSR1H
0AFE  0801     MOVF INDF1, W
0AFF  00B3     MOVWF i
0B00  08B3     MOVF i, F
0B01  1903     BTFSC STATUS, 0x2
0B02  2B1C     GOTO 0x31C
0B1A  03B3     DECF i, F
0B1B  2B00     GOTO 0x300
306:               {
307:                   delta = delta / 2;
0B03  3002     MOVLW 0x2
0B04  00A1     MOVWF divisor
0B05  01A2     CLRF i
0B06  01A3     CLRF dividend
0B07  01A4     CLRF 0x24
0B08  0838     MOVF 0x38, W
0B09  00A8     MOVWF sensor
0B0A  0837     MOVF sample, W
0B0B  00A7     MOVWF quotient
0B0C  0836     MOVF i, W
0B0D  00A6     MOVWF sign
0B0E  0835     MOVF delta, W
0B0F  00A5     MOVWF counter
0B10  2355     CALL 0x355
0B11  3188     MOVLP 0x8
0B12  0824     MOVF 0x24, W
0B13  00B8     MOVWF 0x38
0B14  0823     MOVF dividend, W
0B15  00B7     MOVWF sample
0B16  0822     MOVF i, W
0B17  00B6     MOVWF i
0B18  0821     MOVF divisor, W
0B19  00B5     MOVWF delta
308:               }
309:           
310:               if (delta > MTOUCH_DELTA_MAX)
0B1C  0838     MOVF 0x38, W
0B1D  3A80     XORLW 0x80
0B1E  00AF     MOVWF 0x2F
0B1F  3080     MOVLW 0x80
0B20  022F     SUBWF 0x2F, W
0B21  1D03     BTFSS STATUS, 0x2
0B22  2B2D     GOTO 0x32D
0B23  3000     MOVLW 0x0
0B24  0237     SUBWF sample, W
0B25  1D03     BTFSS STATUS, 0x2
0B26  2B2D     GOTO 0x32D
0B27  3000     MOVLW 0x0
0B28  0236     SUBWF i, W
0B29  1D03     BTFSS STATUS, 0x2
0B2A  2B2D     GOTO 0x32D
0B2B  3080     MOVLW 0x80
0B2C  0235     SUBWF delta, W
0B2D  1C03     BTFSS STATUS, 0x0
0B2E  2B34     GOTO 0x334
311:               {
312:                   delta = MTOUCH_DELTA_MAX;
0B2F  307F     MOVLW 0x7F
0B30  00B5     MOVWF delta
0B31  01B6     CLRF i
0B32  01B7     CLRF sample
0B33  01B8     CLRF 0x38
313:               }
314:               if (delta < MTOUCH_DELTA_MIN)
0B34  0838     MOVF 0x38, W
0B35  3A80     XORLW 0x80
0B36  00AF     MOVWF 0x2F
0B37  307F     MOVLW 0x7F
0B38  022F     SUBWF 0x2F, W
0B39  1D03     BTFSS STATUS, 0x2
0B3A  2B45     GOTO 0x345
0B3B  30FF     MOVLW 0xFF
0B3C  0237     SUBWF sample, W
0B3D  1D03     BTFSS STATUS, 0x2
0B3E  2B45     GOTO 0x345
0B3F  30FF     MOVLW 0xFF
0B40  0236     SUBWF i, W
0B41  1D03     BTFSS STATUS, 0x2
0B42  2B45     GOTO 0x345
0B43  3080     MOVLW 0x80
0B44  0235     SUBWF delta, W
0B45  1803     BTFSC STATUS, 0x0
0B46  2B4D     GOTO 0x34D
315:               {
316:                   delta = MTOUCH_DELTA_MIN;
0B47  30FF     MOVLW 0xFF
0B48  00B8     MOVWF 0x38
0B49  00B7     MOVWF sample
0B4A  00B6     MOVWF i
0B4B  3080     MOVLW 0x80
0B4C  00B5     MOVWF delta
317:               }
318:           
319:               MTOUCH_delta[sensor] = (MTOUCH_DELTA_t)delta;
0B4D  0834     MOVF sensor, W
0B4E  3E51     ADDLW 0x51
0B4F  0086     MOVWF FSR1
0B50  3001     MOVLW 0x1
0B51  0087     MOVWF FSR1H
0B52  0835     MOVF delta, W
0B53  0081     MOVWF INDF1
320:           }
0B54  0008     RETURN
321:           
322:           /*
323:            *  PUBLIC FUNCTION
324:            *
325:            *  Implements the mTouch sensor decoding state machine. There are three states:
326:            *
327:            *    - MTOUCH_STATE_initializing establishes a new baseline and sets the sensor
328:            *      to 'released'.
329:            *    - MTOUCH_STATE_released checks for the delta to increase above the press
330:            *      threshold, and recalibrates if too many consecutive negative deltas.
331:            *    - MTOUCH_STATE_pressed checks for the delta to decrease below the release
332:            *      threshold, and recalibrates if pressed for too long.
333:            *    - The 'default' option resets the sensor to initializing.
334:            */
335:           static void MTOUCH_Button_StateMachine(uint8_t sensor)
097B  00B3     MOVWF i
336:           {
337:               MTOUCH_DELTA_t delta = MTOUCH_Sensor_Delta_Get(sensor);
097C  2174     CALL 0x174
097D  3188     MOVLP 0x8
097E  00B2     MOVWF delta
338:           
339:               switch(MTOUCH_button_state[sensor])
097F  0833     MOVF i, W
0980  3E45     ADDLW 0x45
0981  0086     MOVWF FSR1
0982  3001     MOVLW 0x1
0983  0087     MOVWF FSR1H
0984  0801     MOVF INDF1, W
0985  3A00     XORLW 0x0
0986  1903     BTFSC STATUS, 0x2
0987  2990     GOTO 0x190
0988  3A01     XORLW 0x1
0989  1903     BTFSC STATUS, 0x2
098A  29A0     GOTO 0x1A0
098B  3A03     XORLW 0x3
098C  1903     BTFSC STATUS, 0x2
098D  2A21     GOTO 0x221
098E  2A6E     GOTO 0x26E
340:               {
341:                   /*
342:                    * The initialization state sets the baseline to the current value and
343:                    * then enters the released state. This state assumes that calibration
344:                    * is complete.
345:                    */
346:                   case MTOUCH_STATE_initializing:
347:                       MTOUCH_Sensor_Baseline_Update(sensor);
0990  0833     MOVF i, W
0991  20DA     CALL 0xDA
348:                       MTOUCH_button_state[sensor] = MTOUCH_STATE_released;
0992  0833     MOVF i, W
0993  3E45     ADDLW 0x45
0994  0086     MOVWF FSR1
0995  3001     MOVLW 0x1
0996  0087     MOVWF FSR1H
0997  0181     CLRF INDF1
0998  0A81     INCF INDF1, F
349:                       MTOUCH_baseline_reset_count[sensor] = (RESET_COUNT_t)0;
0999  3533     LSLF i, W
099A  3E20     ADDLW 0x20
099B  0086     MOVWF FSR1
099C  3000     MOVLW 0x0
099D  3FC0     MOVWI [0]FSR1
099E  3FC1     MOVWI [1]FSR1
350:                       break;
099F  0008     RETURN
351:           
352:                   /*
353:                    * The released state checks for the delta to increase above the press
354:                    * threshold, and recalibrates if too many consecutive negative deltas.
355:                    */
356:                   case MTOUCH_STATE_released:
357:                       if (delta > MTOUCH_button_threshold[sensor])
09A0  0833     MOVF i, W
09A1  3EE8     ADDLW 0xE8
09A2  0086     MOVWF FSR1
09A3  0187     CLRF FSR1H
09A4  0801     MOVF INDF1, W
09A5  3A80     XORLW 0x80
09A6  00AE     MOVWF temp_data
09A7  0832     MOVF delta, W
09A8  3A80     XORLW 0x80
09A9  02AE     SUBWF temp_data, F
09AA  1803     BTFSC STATUS, 0x0
09AB  29ED     GOTO 0x1ED
358:                       {
359:                           #if defined(CONFIGURABLE_MOSTPRESSED)
360:                           if ((MTOUCH_flags.mostPressed == 0) ||
361:                              ((MTOUCH_flags.mostPressed == 1) && (MTOUCH_mostPressed_index == sensor) && (MTOUCH_mostPressed_delta > MTOUCH_mostPressed_threshold)))
09AC  1F56     BTFSS MTOUCH_flags, 0x6
09AD  29C0     GOTO 0x1C0
09AE  1F56     BTFSS MTOUCH_flags, 0x6
09AF  29E6     GOTO 0x1E6
09B0  0859     MOVF MTOUCH_mostPressed_index, W
09B1  0633     XORWF i, W
09B2  1D03     BTFSS STATUS, 0x2
09B3  29E6     GOTO 0x1E6
09B4  0021     MOVLB 0x1
09B5  0864     MOVF MTOUCH_mostPressed_threshold, W
09B6  3A80     XORLW 0x80
09B7  0020     MOVLB 0x0
09B8  00AE     MOVWF temp_data
09B9  0021     MOVLB 0x1
09BA  0863     MOVF MTOUCH_mostPressed_delta, W
09BB  3A80     XORLW 0x80
09BC  0020     MOVLB 0x0
09BD  02AE     SUBWF temp_data, F
09BE  1803     BTFSC STATUS, 0x0
09BF  29E6     GOTO 0x1E6
362:                           {
363:                           #else
364:                           if ((MTOUCH_mostPressed_index == sensor) && (MTOUCH_mostPressed_delta > MTOUCH_mostPressed_threshold))
365:                           {
366:                           #endif
367:           
368:                               #if defined(CONFIGURABLE_DEBOUNCE)
369:                               if (MTOUCH_button_debounce[sensor] == MTOUCH_debounce)
09C0  0833     MOVF i, W
09C1  3E3F     ADDLW 0x3F
09C2  0086     MOVWF FSR1
09C3  3001     MOVLW 0x1
09C4  0087     MOVWF FSR1H
09C5  0801     MOVF INDF1, W
09C6  0655     XORWF MTOUCH_debounce, W
09C7  1D03     BTFSS STATUS, 0x2
09C8  29DF     GOTO 0x1DF
370:                               #else
371:                               if (MTOUCH_button_debounce[sensor] == MTOUCH_DEBOUNCE)
372:                               #endif
373:                               {
374:                                   MTOUCH_button_state[sensor] = MTOUCH_STATE_pressed;
09C9  0833     MOVF i, W
09CA  3E45     ADDLW 0x45
09CB  0086     MOVWF FSR1
09CC  3002     MOVLW 0x2
09CD  0081     MOVWF INDF1
375:                                   MTOUCH_button_debounce[sensor] = 0;
09CE  0833     MOVF i, W
09CF  3E3F     ADDLW 0x3F
09D0  0086     MOVWF FSR1
09D1  0181     CLRF INDF1
376:                                   #if defined(CONFIGURABLE_PRESSTIMEOUT)
377:                                   MTOUCH_baseline_reset_count[sensor] = MTOUCH_pressTimeout;
09D2  085C     MOVF MTOUCH_pressTimeout, W
09D3  00AE     MOVWF temp_data
09D4  01AF     CLRF 0x2F
09D5  3533     LSLF i, W
09D6  3E20     ADDLW 0x20
09D7  0086     MOVWF FSR1
09D8  082E     MOVF temp_data, W
09D9  3FC0     MOVWI [0]FSR1
09DA  082F     MOVF 0x2F, W
09DB  3FC1     MOVWI [1]FSR1
378:                                   #else
379:                                   MTOUCH_baseline_reset_count[sensor] = MTOUCH_PRESSTIMEOUT_COUNTS;
380:                                   #endif
381:                                   MTOUCH_CALLBACK_PressOccurred(sensor);
09DC  0833     MOVF i, W
09DD  3194     MOVLP 0x14
09DE  2CCA     GOTO 0x4CA
382:                               }
383:                               else
384:                               {
385:                                   MTOUCH_button_debounce[sensor]++;
09DF  0833     MOVF i, W
09E0  3E3F     ADDLW 0x3F
09E1  0086     MOVWF FSR1
09E2  3001     MOVLW 0x1
09E3  0087     MOVWF FSR1H
09E4  0A81     INCF INDF1, F
09E5  0008     RETURN
386:                               }
387:                           }
388:                           else
389:                           {
390:                               MTOUCH_button_debounce[sensor] = 0;
09E6  0833     MOVF i, W
09E7  3E3F     ADDLW 0x3F
09E8  0086     MOVWF FSR1
09E9  3001     MOVLW 0x1
09EA  0087     MOVWF FSR1H
09EB  0181     CLRF INDF1
09EC  0008     RETURN
391:                           }
392:                       }
393:                       else if (delta < 0)
09ED  1FB2     BTFSS delta, 0x7
09EE  2A13     GOTO 0x213
394:                       {
395:                           MTOUCH_button_debounce[sensor] = 0;
09EF  0833     MOVF i, W
09F0  3E3F     ADDLW 0x3F
09F1  0086     MOVWF FSR1
09F2  3001     MOVLW 0x1
09F3  0087     MOVWF FSR1H
09F4  0181     CLRF INDF1
396:                           MTOUCH_baseline_reset_count[sensor]++;
09F5  3533     LSLF i, W
09F6  3E20     ADDLW 0x20
09F7  0086     MOVWF FSR1
09F8  3001     MOVLW 0x1
09F9  0781     ADDWF INDF1, F
09FA  3141     ADDFSR 1, 1
09FB  1803     BTFSC STATUS, 0x0
09FC  0A81     INCF INDF1, F
397:                           #if defined(CONFIGURABLE_NEGDELTACOUNTS)
398:                           if (MTOUCH_baseline_reset_count[sensor] >= (uint16_t)MTOUCH_negDeltaCount)
09FD  085A     MOVF MTOUCH_negDeltaCount, W
09FE  00AE     MOVWF temp_data
09FF  01AF     CLRF 0x2F
0A00  3533     LSLF i, W
0A01  3E20     ADDLW 0x20
0A02  0086     MOVWF FSR1
0A03  3001     MOVLW 0x1
0A04  0087     MOVWF FSR1H
0A05  3F40     MOVIW [0]FSR1
0A06  00B0     MOVWF 0x30
0A07  3F41     MOVIW [1]FSR1
0A08  00B1     MOVWF 0x31
0A09  082F     MOVF 0x2F, W
0A0A  0231     SUBWF 0x31, W
0A0B  1D03     BTFSS STATUS, 0x2
0A0C  2A0F     GOTO 0x20F
0A0D  082E     MOVF temp_data, W
0A0E  0230     SUBWF 0x30, W
0A0F  1C03     BTFSS STATUS, 0x0
0A10  0008     RETURN
399:                           #else
400:                           if (MTOUCH_baseline_reset_count[sensor] >= (uint16_t)MTOUCH_NEGATIVEDELTA_COUNTS)
401:                           #endif
402:                           {
403:                               /*
404:                                * If negative capacitance values are maintained for an
405:                                * extended period, recalibrate the ADDCAP register for this
406:                                * sensor and reset the baseline.
407:                                */
408:                               MTOUCH_Button_State_Reset(sensor);
0A11  0833     MOVF i, W
0A12  2A70     GOTO 0x270
409:                           }
410:                       }
411:                       else
412:                       {
413:                           /* If the delta count is positive, reset the negative counter. */
414:                           MTOUCH_baseline_reset_count[sensor] = (RESET_COUNT_t)0;
0A13  3533     LSLF i, W
0A14  3E20     ADDLW 0x20
0A15  0086     MOVWF FSR1
0A16  3001     MOVLW 0x1
0A17  0087     MOVWF FSR1H
0A18  3000     MOVLW 0x0
0A19  3FC0     MOVWI [0]FSR1
0A1A  3FC1     MOVWI [1]FSR1
415:                           MTOUCH_button_debounce[sensor] = 0;
0A1B  0833     MOVF i, W
0A1C  3E3F     ADDLW 0x3F
0A1D  0086     MOVWF FSR1
0A1E  3001     MOVLW 0x1
0A1F  0181     CLRF INDF1
0A20  0008     RETURN
416:                       }
417:                       break;
418:           
419:                   /*
420:                    * The pressed state checks for the delta to decrease below the release
421:                    * threshold, and recalibrates if pressed for too long.
422:                    */
423:                   case MTOUCH_STATE_pressed:
424:                       if (delta < (MTOUCH_button_threshold[sensor] / (uint8_t)2))
0A21  3002     MOVLW 0x2
0A22  00A1     MOVWF divisor
0A23  01A2     CLRF i
0A24  0833     MOVF i, W
0A25  3EE8     ADDLW 0xE8
0A26  0086     MOVWF FSR1
0A27  0187     CLRF FSR1H
0A28  0801     MOVF INDF1, W
0A29  00A3     MOVWF dividend
0A2A  01A4     CLRF 0x24
0A2B  1BA3     BTFSC dividend, 0x7
0A2C  03A4     DECF 0x24, F
0A2D  229B     CALL 0x29B
0A2E  3188     MOVLP 0x8
0A2F  0832     MOVF delta, W
0A30  00AE     MOVWF temp_data
0A31  01AF     CLRF 0x2F
0A32  1BAE     BTFSC temp_data, 0x7
0A33  03AF     DECF 0x2F, F
0A34  082F     MOVF 0x2F, W
0A35  3A80     XORLW 0x80
0A36  00B0     MOVWF 0x30
0A37  0822     MOVF i, W
0A38  3A80     XORLW 0x80
0A39  0230     SUBWF 0x30, W
0A3A  1D03     BTFSS STATUS, 0x2
0A3B  2A3E     GOTO 0x23E
0A3C  0821     MOVF divisor, W
0A3D  022E     SUBWF temp_data, W
0A3E  1803     BTFSC STATUS, 0x0
0A3F  2A5B     GOTO 0x25B
425:                       {
426:                           #if defined(CONFIGURABLE_DEBOUNCE)
427:                           if (MTOUCH_button_debounce[sensor] == MTOUCH_debounce)
0A40  0020     MOVLB 0x0
0A41  0833     MOVF i, W
0A42  3E3F     ADDLW 0x3F
0A43  0086     MOVWF FSR1
0A44  3001     MOVLW 0x1
0A45  0087     MOVWF FSR1H
0A46  0801     MOVF INDF1, W
0A47  0655     XORWF MTOUCH_debounce, W
0A48  1D03     BTFSS STATUS, 0x2
0A49  29DF     GOTO 0x1DF
428:                           #else
429:                           if (MTOUCH_button_debounce[sensor] == MTOUCH_DEBOUNCE)
430:                           #endif         
431:                           {
432:                               MTOUCH_button_state[sensor] = MTOUCH_STATE_released;
0A4A  0833     MOVF i, W
0A4B  3E45     ADDLW 0x45
0A4C  0086     MOVWF FSR1
0A4D  0181     CLRF INDF1
0A4E  0A81     INCF INDF1, F
433:                               MTOUCH_button_debounce[sensor] = 0;
0A4F  0833     MOVF i, W
0A50  3E3F     ADDLW 0x3F
0A51  0086     MOVWF FSR1
0A52  0181     CLRF INDF1
434:                               MTOUCH_baseline_reset_count[sensor] = (RESET_COUNT_t)0;
0A53  3533     LSLF i, W
0A54  3E20     ADDLW 0x20
0A55  0086     MOVWF FSR1
0A56  3000     MOVLW 0x0
0A57  3FC0     MOVWI [0]FSR1
0A58  3FC1     MOVWI [1]FSR1
435:                               MTOUCH_CALLBACK_ReleaseOccurred(sensor);
0A59  0833     MOVF i, W
0A5A  2A78     GOTO 0x278
436:                           }
437:                           else
438:                           {
439:                               MTOUCH_button_debounce[sensor]++;
440:                           }
441:                       }
442:                       else
443:                       {
444:                           MTOUCH_button_debounce[sensor] = 0;
0A5B  0020     MOVLB 0x0
0A5C  0833     MOVF i, W
0A5D  3E3F     ADDLW 0x3F
0A5E  0086     MOVWF FSR1
0A5F  3001     MOVLW 0x1
0A60  0087     MOVWF FSR1H
0A61  0181     CLRF INDF1
445:                           if (MTOUCH_baseline_reset_count[sensor] == (RESET_COUNT_t)0)
0A62  3533     LSLF i, W
0A63  3E20     ADDLW 0x20
0A64  0086     MOVWF FSR1
0A65  0016     MOVIW FSR1++
0A66  0401     IORWF INDF1, W
0A67  1D03     BTFSS STATUS, 0x2
0A68  0008     RETURN
446:                           {
447:                               MTOUCH_Button_State_Reset(sensor);
0A69  0833     MOVF i, W
0A6A  2270     CALL 0x270
0A6B  3188     MOVLP 0x8
448:                               MTOUCH_CALLBACK_ReleaseOccurred(sensor);
0A6C  0833     MOVF i, W
0A6D  2A78     GOTO 0x278
449:                           }
450:                       }
451:                       break;
452:           
453:                   /*
454:                    * We should never reach this point. If so, recover by resetting the
455:                    * sensor through a recalibration and reinitialization.
456:                    */
457:                   default:    MTOUCH_Button_State_Reset(sensor);
0A6E  0833     MOVF i, W
0A6F  2A70     GOTO 0x270
458:               }
459:           }
098F  0008     RETURN
460:           
461:           /*
462:            *  PUBLIC FUNCTION
463:            */
464:           enum MTOUCH_STATE MTOUCH_Button_State_Get(uint8_t sensor)
03DF  00F0     MOVWF __pcstackCOMMON
465:           {
466:               return MTOUCH_button_state[sensor];
03E0  3E45     ADDLW 0x45
03E1  0086     MOVWF FSR1
03E2  3001     MOVLW 0x1
03E3  0087     MOVWF FSR1H
03E4  0801     MOVF INDF1, W
467:           }
03E5  0008     RETURN
468:           
469:           /*
470:            *  PUBLIC FUNCTION
471:            */
472:           void MTOUCH_Button_State_Reset(uint8_t sensor)
0A70  00A2     MOVWF i
473:           {
474:               MTOUCH_button_state[sensor] = MTOUCH_STATE_initializing;
0A71  3E45     ADDLW 0x45
0A72  0086     MOVWF FSR1
0A73  3001     MOVLW 0x1
0A74  0087     MOVWF FSR1H
0A75  0181     CLRF INDF1
475:               MTOUCH_Scan_ResetCalibration(sensor);
0A76  0822     MOVF i, W
476:           }
477:           
478:           void MTOUCH_Service_Tick(void)
479:           {
480:               uint8_t i;
481:           
482:               for (i = 0; i < MTOUCH_SENSORS; i++)
14A9  01F0     CLRF __pcstackCOMMON
14C4  3006     MOVLW 0x6
483:               {
484:                   if (MTOUCH_button_state[i] == MTOUCH_STATE_pressed)
14AA  0870     MOVF __pcstackCOMMON, W
14AB  3E45     ADDLW 0x45
14AC  0086     MOVWF FSR1
14AD  3001     MOVLW 0x1
14AE  0087     MOVWF FSR1H
14AF  0801     MOVF INDF1, W
14B0  3A02     XORLW 0x2
14B1  1D03     BTFSS STATUS, 0x2
14B2  2CC4     GOTO 0x4C4
485:                   {
486:                       if (MTOUCH_baseline_reset_count[i] != 0)
14B3  3570     LSLF __pcstackCOMMON, W
14B4  3E20     ADDLW 0x20
14B5  0086     MOVWF FSR1
14B6  0016     MOVIW FSR1++
14B7  0401     IORWF INDF1, W
14B8  1903     BTFSC STATUS, 0x2
14B9  2CC4     GOTO 0x4C4
487:                           MTOUCH_baseline_reset_count[i]--;
14BA  3570     LSLF __pcstackCOMMON, W
14BB  3E20     ADDLW 0x20
14BC  0086     MOVWF FSR1
14BD  3001     MOVLW 0x1
14BE  0087     MOVWF FSR1H
14BF  0281     SUBWF INDF1, F
14C0  3000     MOVLW 0x0
14C1  3141     ADDFSR 1, 1
14C2  3B81     SUBWFB INDF1, F
14C3  317F     ADDFSR 1, -1
488:                   }
489:               }
490:           }
---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/memory.c
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            
37:            #include <stdint.h>
38:            
39:            #include "configuration.h"
40:            #include "mtouch.h"
41:            
42:            #if defined(UART_ENABLED) || defined(I2C_ENABLED)
43:            
44:            /* Extern'd Global Variables */
45:            extern uint8_t              MTOUCH_delta_scaling    [MTOUCH_SENSORS];
46:            extern MTOUCH_DELTA_t       MTOUCH_button_threshold [MTOUCH_SENSORS];
47:            extern MTOUCH_FLAGS_t       MTOUCH_flags;
48:            extern MTOUCH_SAMPLE_t      MTOUCH_lastSample       [MTOUCH_SENSORS];
49:            extern MTOUCH_DELTA_t       MTOUCH_proximity_threshold;
50:            extern uint8_t              MTOUCH_proximity_scaling;  
51:            
52:            #if defined(CONFIGURABLE_NOISETHRESH)
53:            extern int24_t              MTOUCH_noise_threshold;
54:            #endif
55:            #if defined(CONFIGURABLE_SCANRATE_MIN)
56:            extern  uint8_t             MTOUCH_frequency_min;
57:            #endif
58:            #if defined(CONFIGURABLE_SCANRATE_TxCON)
59:            extern  uint8_t             MTOUCH_frequency_txcon;
60:            #endif
61:            #if defined(CONFIGURABLE_NUMBERSAMPLES)
62:            extern   int8_t             MTOUCH_numberSamples;
63:            #endif
64:            #if defined(CONFIGURABLE_READINGGAIN)
65:            extern  uint8_t             MTOUCH_readingGain;
66:            #endif
67:            #if defined(CONFIGURABLE_BASELINEGAIN)
68:            extern  uint8_t             MTOUCH_baselineGain;
69:            #endif
70:            #if defined(CONFIGURABLE_BASELINERATE)
71:            extern  uint8_t             MTOUCH_baselineRate;
72:            #endif
73:            #if defined(CONFIGURABLE_NEGDELTACOUNTS)
74:            extern  uint8_t             MTOUCH_negDeltaCount;
75:            #endif
76:            #if defined(CONFIGURABLE_PRESSTIMEOUT)
77:            extern  uint8_t             MTOUCH_pressTimeout;
78:            #endif
79:            #if defined(CONFIGURABLE_DEBOUNCE)
80:            extern  uint8_t             MTOUCH_debounce;
81:            #endif
82:            #if defined(CONFIGURABLE_SINGLERESULT)
83:            extern  uint16_t            MTOUCH_singleResult     [MTOUCH_SENSORS];
84:            #endif
85:            #if defined(CONFIGURABLE_DIFFRESULT)
86:            extern  uint16_t            MTOUCH_diffResult       [MTOUCH_SENSORS];
87:            #endif
88:            
89:            /* Local Variables */
90:            uint8_t bank = 0;
91:            
92:            /* Local Functions */
93:            uint8_t GetState        (void);
94:            uint8_t GetInterruptBit (void);
95:            void    CalibrateSensors(uint8_t mask);
96:            
97:            uint8_t MEMORY_Read(uint8_t addr)
0105  00FC     MOVWF addr
98:            {
99:                uint8_t output = 0;
0106  01FD     CLRF output
100:               if (bank == 0)
0107  08E1     MOVF bank, F
0108  1903     BTFSC STATUS, 0x2
0109  2968     GOTO 0x168
010A  29C1     GOTO 0x1C1
101:               {
102:                   switch(addr)
0168  087C     MOVF addr, W
0169  3A10     XORLW 0x10
016A  1903     BTFSC STATUS, 0x2
016B  290B     GOTO 0x10B
016C  3A01     XORLW 0x1
016D  1903     BTFSC STATUS, 0x2
016E  290E     GOTO 0x10E
016F  3A03     XORLW 0x3
0170  1903     BTFSC STATUS, 0x2
0171  2912     GOTO 0x112
0172  3A01     XORLW 0x1
0173  1903     BTFSC STATUS, 0x2
0174  2916     GOTO 0x116
0175  3A07     XORLW 0x7
0176  1903     BTFSC STATUS, 0x2
0177  291A     GOTO 0x11A
0178  3A01     XORLW 0x1
0179  1903     BTFSC STATUS, 0x2
017A  291E     GOTO 0x11E
017B  3A55     XORLW 0x55
017C  1903     BTFSC STATUS, 0x2
017D  2922     GOTO 0x122
017E  3A01     XORLW 0x1
017F  1903     BTFSC STATUS, 0x2
0180  2924     GOTO 0x124
0181  3A03     XORLW 0x3
0182  1903     BTFSC STATUS, 0x2
0183  2927     GOTO 0x127
0184  3A01     XORLW 0x1
0185  1903     BTFSC STATUS, 0x2
0186  292A     GOTO 0x12A
0187  3A07     XORLW 0x7
0188  1903     BTFSC STATUS, 0x2
0189  292D     GOTO 0x12D
018A  3A01     XORLW 0x1
018B  1903     BTFSC STATUS, 0x2
018C  2930     GOTO 0x130
018D  3A25     XORLW 0x25
018E  1903     BTFSC STATUS, 0x2
018F  2933     GOTO 0x133
0190  3A01     XORLW 0x1
0191  1903     BTFSC STATUS, 0x2
0192  2936     GOTO 0x136
0193  3A03     XORLW 0x3
0194  1903     BTFSC STATUS, 0x2
0195  2946     GOTO 0x146
0196  3AE2     XORLW 0xE2
0197  1903     BTFSC STATUS, 0x2
0198  2949     GOTO 0x149
0199  3A01     XORLW 0x1
019A  1903     BTFSC STATUS, 0x2
019B  294B     GOTO 0x14B
019C  3A03     XORLW 0x3
019D  1903     BTFSC STATUS, 0x2
019E  294E     GOTO 0x14E
019F  3A01     XORLW 0x1
01A0  1903     BTFSC STATUS, 0x2
01A1  2951     GOTO 0x151
01A2  3A07     XORLW 0x7
01A3  1903     BTFSC STATUS, 0x2
01A4  2954     GOTO 0x154
01A5  3A01     XORLW 0x1
01A6  1903     BTFSC STATUS, 0x2
01A7  2957     GOTO 0x157
01A8  3A15     XORLW 0x15
01A9  1903     BTFSC STATUS, 0x2
01AA  295A     GOTO 0x15A
01AB  3A30     XORLW 0x30
01AC  1903     BTFSC STATUS, 0x2
01AD  295A     GOTO 0x15A
01AE  3A10     XORLW 0x10
01AF  1903     BTFSC STATUS, 0x2
01B0  295C     GOTO 0x15C
01B1  3A01     XORLW 0x1
01B2  1903     BTFSC STATUS, 0x2
01B3  295E     GOTO 0x15E
01B4  3A03     XORLW 0x3
01B5  1903     BTFSC STATUS, 0x2
01B6  2960     GOTO 0x160
01B7  3A72     XORLW 0x72
01B8  1903     BTFSC STATUS, 0x2
01B9  2962     GOTO 0x162
01BA  3A01     XORLW 0x1
01BB  1903     BTFSC STATUS, 0x2
01BC  2964     GOTO 0x164
01BD  3A03     XORLW 0x3
01BE  1903     BTFSC STATUS, 0x2
01BF  2966     GOTO 0x166
01C0  2B4F     GOTO 0x34F
103:                   {
104:                       /* Sensor Deltas */
105:                       //case 0x10:  output = MTOUCH_Sensor_Delta_Get(0);    break;
106:                       case 0x10:  output = MTOUCH_Proximity_Delta_Get();    break;
010B  23FE     CALL 0x3FE
010C  3180     MOVLP 0x0
010D  2B40     GOTO 0x340
107:                       case 0x11:  output = MTOUCH_Sensor_Delta_Get(1);    break;
010E  3001     MOVLW 0x1
010F  239D     CALL 0x39D
0110  3180     MOVLP 0x0
0111  2B40     GOTO 0x340
108:                       case 0x12:  output = MTOUCH_Sensor_Delta_Get(2);    break;
0112  3002     MOVLW 0x2
0113  239D     CALL 0x39D
0114  3180     MOVLP 0x0
0115  2B40     GOTO 0x340
109:                       case 0x13:  output = MTOUCH_Sensor_Delta_Get(3);    break;
0116  3003     MOVLW 0x3
0117  239D     CALL 0x39D
0118  3180     MOVLP 0x0
0119  2B40     GOTO 0x340
110:                       case 0x14:  output = MTOUCH_Sensor_Delta_Get(4);    break;
011A  3004     MOVLW 0x4
011B  239D     CALL 0x39D
011C  3180     MOVLP 0x0
011D  2B40     GOTO 0x340
111:                       case 0x15:  output = MTOUCH_Sensor_Delta_Get(5);    break;
011E  3005     MOVLW 0x5
011F  239D     CALL 0x39D
0120  3180     MOVLP 0x0
0121  2B40     GOTO 0x340
112:                       #if (MTOUCH_SENSORS != 6)
113:                       #warning("Memory mapping should be updated to reflect the number of sensors.")
114:                       #endif
115:           
116:                       /* Sensor Thresholds */
117:                       //case 0x40:  output = MTOUCH_button_threshold[0];    break;
118:                       case 0x40:  output = MTOUCH_proximity_threshold;    break;
0122  085E     MOVF MTOUCH_proximity_threshold, W
0123  2B40     GOTO 0x340
119:                       case 0x41:  output = MTOUCH_button_threshold[1];    break;
0124  0021     MOVLB 0x1
0125  0869     MOVF 0xE9, W
0126  2B40     GOTO 0x340
120:                       case 0x42:  output = MTOUCH_button_threshold[2];    break;
0127  0021     MOVLB 0x1
0128  086A     MOVF 0xEA, W
0129  2B40     GOTO 0x340
121:                       case 0x43:  output = MTOUCH_button_threshold[3];    break;
012A  0021     MOVLB 0x1
012B  086B     MOVF 0xEB, W
012C  2B40     GOTO 0x340
122:                       case 0x44:  output = MTOUCH_button_threshold[4];    break;
012D  0021     MOVLB 0x1
012E  086C     MOVF 0xEC, W
012F  2B40     GOTO 0x340
123:                       case 0x45:  output = MTOUCH_button_threshold[5];    break;
0130  0021     MOVLB 0x1
0131  086D     MOVF 0xED, W
0132  2B40     GOTO 0x340
124:                       #if (MTOUCH_SENSORS != 6)
125:                       #warning("Memory mapping should be updated to reflect the number of sensors.")
126:                       #endif
127:           
128:                       #if defined(CONFIGURABLE_NOISETHRESH)
129:                       case 0x60:  output = (uint8_t)(MTOUCH_noise_threshold       );  break;
0133  0021     MOVLB 0x1
0134  085E     MOVF MTOUCH_noise_threshold, W
0135  2B40     GOTO 0x340
130:                       case 0x61:  output = (uint8_t)(MTOUCH_noise_threshold >> 8  );  break;
0136  0021     MOVLB 0x1
0137  085E     MOVF MTOUCH_noise_threshold, W
0138  00F8     MOVWF 0xF8
0139  085F     MOVF 0xDF, W
013A  00F9     MOVWF 0xF9
013B  0860     MOVF 0xE0, W
013C  00FA     MOVWF 0xFA
013D  3008     MOVLW 0x8
013E  00FB     MOVWF 0xFB
013F  0D7A     RLF 0xFA, W
0140  0CFA     RRF 0xFA, F
0141  0CF9     RRF 0xF9, F
0142  0CF8     RRF 0xF8, F
0143  0BFB     DECFSZ 0xFB, F
0144  293F     GOTO 0x13F
0145  2AD0     GOTO 0x2D0
131:                       case 0x62:  output = (uint8_t)(MTOUCH_noise_threshold >> 16 );  break;
0146  0021     MOVLB 0x1
0147  0860     MOVF 0xE0, W
0148  2B40     GOTO 0x340
132:                       #endif
133:           
134:                       /* Sensor Delta Scaling */
135:                       //case 0x80:  output = MTOUCH_delta_scaling[0];       break;
136:                       case 0x80:  output = MTOUCH_proximity_scaling;      break;
0149  085D     MOVF 0xDD, W
014A  2B40     GOTO 0x340
137:                       case 0x81:  output = MTOUCH_delta_scaling[1];       break;
014B  0021     MOVLB 0x1
014C  084B     MOVF 0xCB, W
014D  2B40     GOTO 0x340
138:                       case 0x82:  output = MTOUCH_delta_scaling[2];       break;
014E  0021     MOVLB 0x1
014F  084C     MOVF 0xCC, W
0150  2B40     GOTO 0x340
139:                       case 0x83:  output = MTOUCH_delta_scaling[3];       break;
0151  0021     MOVLB 0x1
0152  084D     MOVF 0xCD, W
0153  2B40     GOTO 0x340
140:                       case 0x84:  output = MTOUCH_delta_scaling[4];       break;
0154  0021     MOVLB 0x1
0155  084E     MOVF 0xCE, W
0156  2B40     GOTO 0x340
141:                       case 0x85:  output = MTOUCH_delta_scaling[5];       break;
0157  0021     MOVLB 0x1
0158  084F     MOVF 0xCF, W
0159  2B40     GOTO 0x340
142:                       #if (MTOUCH_SENSORS != 6)
143:                       #warning("Memory mapping should be updated to reflect the number of sensors.")
144:                       #endif
145:           
146:                       #if defined(CONFIGURABLE_SCANRATE_MIN)
147:                       case 0x90:  output = MTOUCH_frequency_min;
148:                       #endif
149:                       #if defined(CONFIGURABLE_SCANRATE_TxCON)
150:                       case 0x91:  output = MTOUCH_frequency_txcon;
151:                       #endif
152:           
153:                       #if defined(CONFIGURABLE_NUMBERSAMPLES)
154:                       case 0xA0:  output = MTOUCH_numberSamples;          break;
015A  085B     MOVF 0xDB, W
015B  2B40     GOTO 0x340
155:                       #else
156:                       case 0xA0:  output = MTOUCH_SAMPLES;                break;
157:                       #endif
158:           
159:           
160:                       #if defined(CONFIGURABLE_READINGGAIN)
161:                       case 0xB0:  output = MTOUCH_readingGain;            break;
015C  085F     MOVF 0xDF, W
015D  2B40     GOTO 0x340
162:                       #endif
163:                       #if defined(CONFIGURABLE_BASELINEGAIN)
164:                       case 0xB1:  output = MTOUCH_baselineGain;           break;
015E  0853     MOVF 0xD3, W
015F  2B40     GOTO 0x340
165:                       #endif
166:                       #if defined(CONFIGURABLE_BASELINERATE)
167:                       case 0xB2:  output = MTOUCH_baselineRate;           break;
0160  0854     MOVF 0xD4, W
0161  2B40     GOTO 0x340
168:                       #endif
169:           
170:                       #if defined(CONFIGURABLE_NEGDELTACOUNTS)
171:                       case 0xC0:  output = MTOUCH_negDeltaCount;          break;
0162  085A     MOVF MTOUCH_prox_reading, W
0163  2B40     GOTO 0x340
172:                       #endif
173:                       #if defined(CONFIGURABLE_PRESSTIMEOUT)
174:                       case 0xC1:  output = MTOUCH_pressTimeout;           break;
0164  085C     MOVF 0xDC, W
0165  2B40     GOTO 0x340
175:                       #endif
176:                       #if defined(CONFIGURABLE_DEBOUNCE)
177:                       case 0xC2:  output = MTOUCH_debounce;               break;
0166  0855     MOVF 0xD5, W
0167  2B40     GOTO 0x340
178:                       #endif
179:           
180:                       default: break;
181:                   }
182:               }
183:               else if (bank == 1)
01C1  0B61     DECFSZ tick, W
01C2  2A02     GOTO 0x202
01C3  29F5     GOTO 0x1F5
184:               {
185:                   switch(addr)
01F5  087C     MOVF 0xFC, W
01F6  3EF0     ADDLW 0xF0
01F7  1C03     BTFSS 0x83, 0x0
01F8  2B84     GOTO 0x384
01F9  0084     MOVWF 0x84
01FA  3012     MOVLW 0x12
01FB  0204     SUBWF 0x84, W
01FC  1803     BTFSC 0x83, 0x0
01FD  2B84     GOTO 0x384
01FE  3190     MOVLP 0x10
01FF  3504     LSLF 0x84, W
0200  3E00     ADDLW 0x0
0201  0082     MOVWF 0x82
1000  3181     MOVLP 0x1
186:                   {
187:                   #define READ_READING(addr,sensor)                                                        \
188:                       case (addr)  : output = (uint8_t)(MTOUCH_Sensor_Reading_Get((sensor)));       break; \
189:                       case (addr+1): output = (uint8_t)(MTOUCH_Sensor_Reading_Get((sensor)) >> 8);  break; \
190:                       case (addr+2): output = (uint8_t)(MTOUCH_Sensor_Reading_Get((sensor)) >> 16); break; 
191:           
192:                       READ_READING(0x10, 0);
01C4  3000     MOVLW 0x0
01C5  29E3     GOTO 0x1E3
01C6  3000     MOVLW 0x0
01C7  29E8     GOTO 0x1E8
01C8  3000     MOVLW 0x0
01C9  29F1     GOTO 0x1F1
193:                       READ_READING(0x13, 1);
01CA  3001     MOVLW 0x1
01CB  29E3     GOTO 0x1E3
01CC  3001     MOVLW 0x1
01CD  29E8     GOTO 0x1E8
01CE  3001     MOVLW 0x1
01CF  29F1     GOTO 0x1F1
194:                       READ_READING(0x16, 2);
01D0  3002     MOVLW 0x2
01D1  29E3     GOTO 0x1E3
01D2  3002     MOVLW 0x2
01D3  29E8     GOTO 0x1E8
01D4  3002     MOVLW 0x2
01D5  29F1     GOTO 0x1F1
195:                       READ_READING(0x19, 3);
01D6  3003     MOVLW 0x3
01D7  29E3     GOTO 0x1E3
01D8  3003     MOVLW 0x3
01D9  29E8     GOTO 0x1E8
01DA  3003     MOVLW 0x3
01DB  29F1     GOTO 0x1F1
196:                       READ_READING(0x1C, 4);
01DC  3004     MOVLW 0x4
01DD  29E3     GOTO 0x1E3
01DE  3004     MOVLW 0x4
01DF  29E8     GOTO 0x1E8
01E0  3004     MOVLW 0x4
01E1  29F1     GOTO 0x1F1
197:                       READ_READING(0x1F, 5);
01E2  3005     MOVLW 0x5
01E3  23C4     CALL 0x3C4
01E4  3180     MOVLP 0x0
01E5  0870     MOVF 0xF0, W
01E6  2B40     GOTO 0x340
01E7  3005     MOVLW 0x5
01E8  23C4     CALL 0x3C4
01E9  3180     MOVLP 0x0
01EA  0870     MOVF 0xF0, W
01EB  00F8     MOVWF 0xF8
01EC  0871     MOVF 0xF1, W
01ED  00F9     MOVWF 0xF9
01EE  0872     MOVF 0xF2, W
01EF  2A32     GOTO 0x232
01F0  3005     MOVLW 0x5
01F1  23C4     CALL 0x3C4
01F2  3180     MOVLP 0x0
01F3  0872     MOVF 0xF2, W
01F4  2B40     GOTO 0x340
198:           
199:                       default: break;
200:                   }
201:               }
202:               else if (bank == 2)
0202  0861     MOVF tick, W
0203  3A02     XORLW 0x2
0204  1903     BTFSC 0x83, 0x2
0205  2A3E     GOTO 0x23E
0206  2A4B     GOTO 0x24B
203:               {
204:                   switch(addr)
023E  087C     MOVF 0xFC, W
023F  3EF0     ADDLW 0xF0
0240  1C03     BTFSS 0x83, 0x0
0241  2B84     GOTO 0x384
0242  0084     MOVWF 0x84
0243  3012     MOVLW 0x12
0244  0204     SUBWF 0x84, W
0245  1803     BTFSC 0x83, 0x0
0246  2B84     GOTO 0x384
0247  3190     MOVLP 0x10
0248  3504     LSLF 0x84, W
0249  3E24     ADDLW 0x24
024A  0082     MOVWF 0x82
1024  3182     MOVLP 0x2
205:                   {
206:                   #define READ_BASELINE(addr,sensor)                                                        \
207:                       case (addr)  : output = (uint8_t)(MTOUCH_Sensor_Baseline_Get((sensor)));       break; \
208:                       case (addr+1): output = (uint8_t)(MTOUCH_Sensor_Baseline_Get((sensor)) >> 8);  break; \
209:                       case (addr+2): output = (uint8_t)(MTOUCH_Sensor_Baseline_Get((sensor)) >> 16); break;
210:           
211:                       READ_BASELINE(0x10, 0);
0207  3000     MOVLW 0x0
0208  2A26     GOTO 0x226
0209  3000     MOVLW 0x0
020A  2A2B     GOTO 0x22B
020B  3000     MOVLW 0x0
020C  2A3A     GOTO 0x23A
212:                       READ_BASELINE(0x13, 1);
020D  3001     MOVLW 0x1
020E  2A26     GOTO 0x226
020F  3001     MOVLW 0x1
0210  2A2B     GOTO 0x22B
0211  3001     MOVLW 0x1
0212  2A3A     GOTO 0x23A
213:                       READ_BASELINE(0x16, 2);
0213  3002     MOVLW 0x2
0214  2A26     GOTO 0x226
0215  3002     MOVLW 0x2
0216  2A2B     GOTO 0x22B
0217  3002     MOVLW 0x2
0218  2A3A     GOTO 0x23A
214:                       READ_BASELINE(0x19, 3);
0219  3003     MOVLW 0x3
021A  2A26     GOTO 0x226
021B  3003     MOVLW 0x3
021C  2A2B     GOTO 0x22B
021D  3003     MOVLW 0x3
021E  2A3A     GOTO 0x23A
215:                       READ_BASELINE(0x1C, 4);
021F  3004     MOVLW 0x4
0220  2A26     GOTO 0x226
0221  3004     MOVLW 0x4
0222  2A2B     GOTO 0x22B
0223  3004     MOVLW 0x4
0224  2A3A     GOTO 0x23A
216:                       READ_BASELINE(0x1F, 5);
0225  3005     MOVLW 0x5
0226  23A4     CALL 0x3A4
0227  3180     MOVLP 0x0
0228  0870     MOVF 0xF0, W
0229  2B40     GOTO 0x340
022A  3005     MOVLW 0x5
022B  23A4     CALL 0x3A4
022C  3180     MOVLP 0x0
022D  0870     MOVF 0xF0, W
022E  00F8     MOVWF 0xF8
022F  0871     MOVF 0xF1, W
0230  00F9     MOVWF 0xF9
0231  0872     MOVF 0xF2, W
0232  00FA     MOVWF 0xFA
0233  0879     MOVF 0xF9, W
0234  00F8     MOVWF 0xF8
0235  087A     MOVF 0xFA, W
0236  00F9     MOVWF 0xF9
0237  01FA     CLRF 0xFA
0238  2AD0     GOTO 0x2D0
0239  3005     MOVLW 0x5
023A  23A4     CALL 0x3A4
023B  3180     MOVLP 0x0
023C  0872     MOVF 0xF2, W
023D  2B40     GOTO 0x340
217:           
218:                       default: break;
219:                   }
220:               }
221:               else if (bank == 3)
024B  0861     MOVF tick, W
024C  3A03     XORLW 0x3
024D  1903     BTFSC 0x83, 0x2
024E  2AD5     GOTO 0x2D5
024F  2AE2     GOTO 0x2E2
222:               {
223:                   switch(addr)
02D5  087C     MOVF 0xFC, W
02D6  3EF0     ADDLW 0xF0
02D7  1C03     BTFSS 0x83, 0x0
02D8  2B84     GOTO 0x384
02D9  0084     MOVWF 0x84
02DA  3012     MOVLW 0x12
02DB  0204     SUBWF 0x84, W
02DC  1803     BTFSC 0x83, 0x0
02DD  2B84     GOTO 0x384
02DE  3190     MOVLP 0x10
02DF  3504     LSLF 0x84, W
02E0  3E48     ADDLW 0x48
02E1  0082     MOVWF 0x82
1048  3182     MOVLP 0x2
224:                   {
225:                   #define READ_SAMPLE(addr,sensor)                                                 \
226:                       case (addr)  : output = (uint8_t)(MTOUCH_lastSample[(sensor)]);       break; \
227:                       case (addr+1): output = (uint8_t)(MTOUCH_lastSample[(sensor)] >> 8);  break; \
228:                       case (addr+2): output = (uint8_t)(MTOUCH_lastSample[(sensor)] >> 16); break;
229:           
230:                       READ_SAMPLE(0x10, 0);
0250  0021     MOVLB 0x1
0251  0820     MOVF MTOUCH_lastSample, W
0252  2B40     GOTO 0x340
0253  0021     MOVLB 0x1
0254  0820     MOVF MTOUCH_lastSample, W
0255  00F8     MOVWF 0xF8
0256  0821     MOVF 0xA1, W
0257  00F9     MOVWF 0xF9
0258  0822     MOVF 0xA2, W
0259  00FA     MOVWF 0xFA
025A  3008     MOVLW 0x8
025B  00FB     MOVWF 0xFB
025C  0D7A     RLF 0xFA, W
025D  0CFA     RRF 0xFA, F
025E  0CF9     RRF 0xF9, F
025F  0CF8     RRF 0xF8, F
0260  0BFB     DECFSZ 0xFB, F
0261  2A5C     GOTO 0x25C
0262  2AD0     GOTO 0x2D0
0263  0021     MOVLB 0x1
0264  0822     MOVF 0xA2, W
0265  2B40     GOTO 0x340
231:                       READ_SAMPLE(0x13, 1);
0266  0021     MOVLB 0x1
0267  0823     MOVF 0xA3, W
0268  2B40     GOTO 0x340
0269  0021     MOVLB 0x1
026A  0823     MOVF 0xA3, W
026B  00F8     MOVWF 0xF8
026C  0824     MOVF 0xA4, W
026D  00F9     MOVWF 0xF9
026E  0825     MOVF 0xA5, W
026F  00FA     MOVWF 0xFA
0270  3008     MOVLW 0x8
0271  00FB     MOVWF 0xFB
0272  0D7A     RLF 0xFA, W
0273  0CFA     RRF 0xFA, F
0274  0CF9     RRF 0xF9, F
0275  0CF8     RRF 0xF8, F
0276  0BFB     DECFSZ 0xFB, F
0277  2A72     GOTO 0x272
0278  2AD0     GOTO 0x2D0
0279  0021     MOVLB 0x1
027A  0825     MOVF 0xA5, W
027B  2B40     GOTO 0x340
232:                       READ_SAMPLE(0x16, 2);
027C  0021     MOVLB 0x1
027D  0826     MOVF 0xA6, W
027E  2B40     GOTO 0x340
027F  0021     MOVLB 0x1
0280  0826     MOVF 0xA6, W
0281  00F8     MOVWF 0xF8
0282  0827     MOVF 0xA7, W
0283  00F9     MOVWF 0xF9
0284  0828     MOVF 0xA8, W
0285  00FA     MOVWF 0xFA
0286  3008     MOVLW 0x8
0287  00FB     MOVWF 0xFB
0288  0D7A     RLF 0xFA, W
0289  0CFA     RRF 0xFA, F
028A  0CF9     RRF 0xF9, F
028B  0CF8     RRF 0xF8, F
028C  0BFB     DECFSZ 0xFB, F
028D  2A88     GOTO 0x288
028E  2AD0     GOTO 0x2D0
028F  0021     MOVLB 0x1
0290  0828     MOVF 0xA8, W
0291  2B40     GOTO 0x340
233:                       READ_SAMPLE(0x19, 3);
0292  0021     MOVLB 0x1
0293  0829     MOVF 0xA9, W
0294  2B40     GOTO 0x340
0295  0021     MOVLB 0x1
0296  0829     MOVF 0xA9, W
0297  00F8     MOVWF 0xF8
0298  082A     MOVF 0xAA, W
0299  00F9     MOVWF 0xF9
029A  082B     MOVF 0xAB, W
029B  00FA     MOVWF 0xFA
029C  3008     MOVLW 0x8
029D  00FB     MOVWF 0xFB
029E  0D7A     RLF 0xFA, W
029F  0CFA     RRF 0xFA, F
02A0  0CF9     RRF 0xF9, F
02A1  0CF8     RRF 0xF8, F
02A2  0BFB     DECFSZ 0xFB, F
02A3  2A9E     GOTO 0x29E
02A4  2AD0     GOTO 0x2D0
02A5  0021     MOVLB 0x1
02A6  082B     MOVF 0xAB, W
02A7  2B40     GOTO 0x340
234:                       READ_SAMPLE(0x1C, 4);
02A8  0021     MOVLB 0x1
02A9  082C     MOVF 0xAC, W
02AA  2B40     GOTO 0x340
02AB  0021     MOVLB 0x1
02AC  082C     MOVF 0xAC, W
02AD  00F8     MOVWF 0xF8
02AE  082D     MOVF 0xAD, W
02AF  00F9     MOVWF 0xF9
02B0  082E     MOVF 0xAE, W
02B1  00FA     MOVWF 0xFA
02B2  3008     MOVLW 0x8
02B3  00FB     MOVWF 0xFB
02B4  0D7A     RLF 0xFA, W
02B5  0CFA     RRF 0xFA, F
02B6  0CF9     RRF 0xF9, F
02B7  0CF8     RRF 0xF8, F
02B8  0BFB     DECFSZ 0xFB, F
02B9  2AB4     GOTO 0x2B4
02BA  2AD0     GOTO 0x2D0
02BB  0021     MOVLB 0x1
02BC  082E     MOVF 0xAE, W
02BD  2B40     GOTO 0x340
235:                       READ_SAMPLE(0x1F, 5);
02BE  0021     MOVLB 0x1
02BF  082F     MOVF 0xAF, W
02C0  2B40     GOTO 0x340
02C1  0021     MOVLB 0x1
02C2  082F     MOVF 0xAF, W
02C3  00F8     MOVWF 0xF8
02C4  0830     MOVF 0xB0, W
02C5  00F9     MOVWF 0xF9
02C6  0831     MOVF 0xB1, W
02C7  00FA     MOVWF 0xFA
02C8  3008     MOVLW 0x8
02C9  00FB     MOVWF 0xFB
02CA  0D7A     RLF 0xFA, W
02CB  0CFA     RRF 0xFA, F
02CC  0CF9     RRF 0xF9, F
02CD  0CF8     RRF 0xF8, F
02CE  0BFB     DECFSZ 0xFB, F
02CF  2ACA     GOTO 0x2CA
02D0  0878     MOVF 0xF8, W
02D1  2B40     GOTO 0x340
02D2  0021     MOVLB 0x1
02D3  0831     MOVF 0xB1, W
02D4  2B40     GOTO 0x340
236:           
237:                       default: break;
238:                   }
239:               }
240:               else if (bank == 4)
02E2  0861     MOVF tick, W
02E3  3A04     XORLW 0x4
02E4  1903     BTFSC 0x83, 0x2
02E5  2B0B     GOTO 0x30B
02E6  2B18     GOTO 0x318
241:               {
242:                   switch(addr)
030B  087C     MOVF 0xFC, W
030C  3EF0     ADDLW 0xF0
030D  1C03     BTFSS 0x83, 0x0
030E  2B84     GOTO 0x384
030F  0084     MOVWF 0x84
0310  300C     MOVLW 0xC
0311  0204     SUBWF 0x84, W
0312  1803     BTFSC 0x83, 0x0
0313  2B84     GOTO 0x384
0314  3190     MOVLP 0x10
0315  3504     LSLF 0x84, W
0316  3E8C     ADDLW 0x8C
0317  0082     MOVWF 0x82
108C  3182     MOVLP 0x2
243:                   {
244:                   #define READ_DIFFRESULT(addr,sensor)                                             \
245:                       case (addr)  : output = (uint8_t)(MTOUCH_diffResult[(sensor)]);       break; \
246:                       case (addr+1): output = (uint8_t)(MTOUCH_diffResult[(sensor)] >> 8);  break;
247:           
248:                       READ_DIFFRESULT(0x10, 0);
02E7  0021     MOVLB 0x1
02E8  0832     MOVF MTOUCH_diffResult, W
02E9  2B40     GOTO 0x340
02EA  0021     MOVLB 0x1
02EB  0833     MOVF 0xB3, W
02EC  2B40     GOTO 0x340
249:                       READ_DIFFRESULT(0x12, 1);
02ED  0021     MOVLB 0x1
02EE  0834     MOVF 0xB4, W
02EF  2B40     GOTO 0x340
02F0  0021     MOVLB 0x1
02F1  0835     MOVF 0xB5, W
02F2  2B40     GOTO 0x340
250:                       READ_DIFFRESULT(0x14, 2);
02F3  0021     MOVLB 0x1
02F4  0836     MOVF 0xB6, W
02F5  2B40     GOTO 0x340
02F6  0021     MOVLB 0x1
02F7  0837     MOVF 0xB7, W
02F8  2B40     GOTO 0x340
251:                       READ_DIFFRESULT(0x16, 3);
02F9  0021     MOVLB 0x1
02FA  0838     MOVF 0xB8, W
02FB  2B40     GOTO 0x340
02FC  0021     MOVLB 0x1
02FD  0839     MOVF 0xB9, W
02FE  2B40     GOTO 0x340
252:                       READ_DIFFRESULT(0x18, 4);
02FF  0021     MOVLB 0x1
0300  083A     MOVF 0xBA, W
0301  2B40     GOTO 0x340
0302  0021     MOVLB 0x1
0303  083B     MOVF 0xBB, W
0304  2B40     GOTO 0x340
253:                       READ_DIFFRESULT(0x1A, 5);
0305  0021     MOVLB 0x1
0306  083C     MOVF 0xBC, W
0307  2B40     GOTO 0x340
0308  0021     MOVLB 0x1
0309  083D     MOVF 0xBD, W
030A  2B40     GOTO 0x340
254:           
255:                       default: break;
256:                   }
257:               }
258:               else if (bank == 5)
0318  0861     MOVF tick, W
0319  3A05     XORLW 0x5
031A  1903     BTFSC 0x83, 0x2
031B  2B42     GOTO 0x342
031C  2B84     GOTO 0x384
259:               {
260:                   switch(addr)
0342  087C     MOVF 0xFC, W
0343  3EF0     ADDLW 0xF0
0344  1C03     BTFSS 0x83, 0x0
0345  2B84     GOTO 0x384
0346  0084     MOVWF 0x84
0347  300C     MOVLW 0xC
0348  0204     SUBWF 0x84, W
0349  1803     BTFSC 0x83, 0x0
034A  2B84     GOTO 0x384
034B  3190     MOVLP 0x10
034C  3504     LSLF 0x84, W
034D  3EA4     ADDLW 0xA4
034E  0082     MOVWF 0x82
10A4  3183     MOVLP 0x3
261:                   {
262:                   #define READ_SINGLERESULT(addr,sensor)                                             \
263:                       case (addr)  : output = (uint8_t)(MTOUCH_singleResult[(sensor)]);       break; \
264:                       case (addr+1): output = (uint8_t)(MTOUCH_singleResult[(sensor)] >> 8);  break;
265:           
266:                       READ_SINGLERESULT(0x10, 0);
031D  0021     MOVLB 0x1
031E  083E     MOVF MTOUCH_singleResult, W
031F  2B40     GOTO 0x340
0320  0021     MOVLB 0x1
0321  083F     MOVF 0xBF, W
0322  2B40     GOTO 0x340
267:                       READ_SINGLERESULT(0x12, 1);
0323  0021     MOVLB 0x1
0324  0840     MOVF 0xC0, W
0325  2B40     GOTO 0x340
0326  0021     MOVLB 0x1
0327  0841     MOVF 0xC1, W
0328  2B40     GOTO 0x340
268:                       READ_SINGLERESULT(0x14, 2);
0329  0021     MOVLB 0x1
032A  0842     MOVF 0xC2, W
032B  2B40     GOTO 0x340
032C  0021     MOVLB 0x1
032D  0843     MOVF 0xC3, W
032E  2B40     GOTO 0x340
269:                       READ_SINGLERESULT(0x16, 3);
032F  0021     MOVLB 0x1
0330  0844     MOVF 0xC4, W
0331  2B40     GOTO 0x340
0332  0021     MOVLB 0x1
0333  0845     MOVF 0xC5, W
0334  2B40     GOTO 0x340
270:                       READ_SINGLERESULT(0x18, 4);
0335  0021     MOVLB 0x1
0336  0846     MOVF 0xC6, W
0337  2B40     GOTO 0x340
0338  0021     MOVLB 0x1
0339  0847     MOVF 0xC7, W
033A  2B40     GOTO 0x340
271:                       READ_SINGLERESULT(0x1A, 5);
033B  0021     MOVLB 0x1
033C  0848     MOVF 0xC8, W
033D  2B40     GOTO 0x340
033E  0021     MOVLB 0x1
033F  0849     MOVF 0xC9, W
0340  00FD     MOVWF 0xFD
0341  2B84     GOTO 0x384
272:           
273:                       default: break;
274:                   }
275:               }
276:           
277:               /* Common registers, regardless of bank */
278:               switch(addr)
034F  2B84     GOTO 0x384
0384  087C     MOVF 0xFC, W
0385  3A00     XORLW 0x0
0386  1903     BTFSC 0x83, 0x2
0387  2B50     GOTO 0x350
0388  3A01     XORLW 0x1
0389  1903     BTFSC 0x83, 0x2
038A  2B75     GOTO 0x375
038B  3AF1     XORLW 0xF1
038C  1903     BTFSC 0x83, 0x2
038D  2B78     GOTO 0x378
038E  3A01     XORLW 0x1
038F  1903     BTFSC 0x83, 0x2
0390  2B7B     GOTO 0x37B
0391  3A0C     XORLW 0xC
0392  1903     BTFSC 0x83, 0x2
0393  2B7D     GOTO 0x37D
0394  3A03     XORLW 0x3
0395  1903     BTFSC 0x83, 0x2
0396  2B7F     GOTO 0x37F
0397  3A01     XORLW 0x1
0398  1903     BTFSC 0x83, 0x2
0399  2B82     GOTO 0x382
039A  2B9B     GOTO 0x39B
279:               {
280:                   case 0x00:  output += GetInterruptBit();
0350  23D2     CALL 0x3D2
0351  3180     MOVLP 0x0
0352  07FD     ADDWF 0xFD, F
281:                               #if defined(CONFIGURABLE_FILTERTYPE)
282:                               output += MTOUCH_flags.hamming_nAccumulation << 7;
0353  0020     MOVLB 0x0
0354  0C56     RRF MTOUCH_flags, W
0355  00F8     MOVWF 0x78
0356  0CF8     RRF 0x78, F
0357  0C78     RRF 0x78, W
0358  3901     ANDLW 0x1
0359  00F9     MOVWF 0x79
035A  3006     MOVLW 0x6
035B  35F9     LSLF 0x79, F
035C  3EFF     ADDLW 0xFF
035D  1D03     BTFSS STATUS, 0x2
035E  2B5B     GOTO 0x35B
035F  3579     LSLF 0x79, W
0360  07FD     ADDWF output, F
283:                               #endif
284:                               #if defined(CONFIGURABLE_SAMPLETYPE)
285:                               output += MTOUCH_flags.active_nJitter << 6;
0361  0E56     SWAPF MTOUCH_flags, W
0362  3901     ANDLW 0x1
0363  00F8     MOVWF 0x78
0364  0CF8     RRF 0x78, F
0365  0CF8     RRF 0x78, F
0366  0C78     RRF 0x78, W
0367  39C0     ANDLW 0xC0
0368  07FD     ADDWF output, F
286:                               #endif
287:                               #if defined(CONFIGURABLE_GUARD)
288:                               output += MTOUCH_flags.guard << 5;
0369  0E56     SWAPF MTOUCH_flags, W
036A  0C89     RRF WREG, F
036B  3901     ANDLW 0x1
036C  00F8     MOVWF 0x78
036D  3004     MOVLW 0x4
036E  35F8     LSLF 0x78, F
036F  3EFF     ADDLW 0xFF
0370  1D03     BTFSS STATUS, 0x2
0371  2B6E     GOTO 0x36E
0372  3578     LSLF 0x78, W
0373  07FD     ADDWF output, F
289:                               #endif
290:                                                                       break;
0374  2B9B     GOTO 0x39B
291:           
292:                   case 0x01:  output = GetState();                    break;
0375  23E6     CALL 0x3E6
0376  3180     MOVLP 0x0
0377  2B80     GOTO 0x380
293:           
294:                   /* Reserved memory space */
295:                   case 0xF0:  output = bank;                          break;
0378  0020     MOVLB 0x0
0379  0861     MOVF bank, W
037A  2B80     GOTO 0x380
296:                   case 0xF1:  output = MTOUCH_SENSORS;                break;
037B  3006     MOVLW 0x6
037C  2B80     GOTO 0x380
297:                   case 0xFD:  output = ID_PRODUCT;                    break;
037D  30FF     MOVLW 0xFF
037E  2B80     GOTO 0x380
298:                   case 0xFE:  output = ID_MANUFACTURER;               break;
037F  30BD     MOVLW 0xBD
0380  00FD     MOVWF output
0381  2B9B     GOTO 0x39B
299:                   case 0xFF:  output = ID_REVISION;                   break;
0382  01FD     CLRF output
0383  2B9B     GOTO 0x39B
300:           
301:                   default: break;
302:               }
303:           
304:               return output;
039B  087D     MOVF output, W
305:           }
039C  0008     RETURN
306:           
307:           void MEMORY_Write(uint8_t addr, uint8_t value)
1552  00FB     MOVWF addr
308:           {
309:               switch(addr)
1553  2E00     GOTO 0x600
1600  087B     MOVF addr, W
1601  3A00     XORLW 0x0
1602  1903     BTFSC STATUS, 0x2
1603  2D54     GOTO 0x554
1604  3A40     XORLW 0x40
1605  1903     BTFSC STATUS, 0x2
1606  2D67     GOTO 0x567
1607  3A01     XORLW 0x1
1608  1903     BTFSC STATUS, 0x2
1609  2D6D     GOTO 0x56D
160A  3A03     XORLW 0x3
160B  1903     BTFSC STATUS, 0x2
160C  2D73     GOTO 0x573
160D  3A01     XORLW 0x1
160E  1903     BTFSC STATUS, 0x2
160F  2D79     GOTO 0x579
1610  3A07     XORLW 0x7
1611  1903     BTFSC STATUS, 0x2
1612  2D7F     GOTO 0x57F
1613  3A01     XORLW 0x1
1614  1903     BTFSC STATUS, 0x2
1615  2D85     GOTO 0x585
1616  3A25     XORLW 0x25
1617  1903     BTFSC STATUS, 0x2
1618  2D8B     GOTO 0x58B
1619  3A01     XORLW 0x1
161A  1903     BTFSC STATUS, 0x2
161B  2D9A     GOTO 0x59A
161C  3A03     XORLW 0x3
161D  1903     BTFSC STATUS, 0x2
161E  2DB0     GOTO 0x5B0
161F  3A12     XORLW 0x12
1620  1903     BTFSC STATUS, 0x2
1621  2DC0     GOTO 0x5C0
1622  3AF0     XORLW 0xF0
1623  1903     BTFSC STATUS, 0x2
1624  2DC2     GOTO 0x5C2
1625  3A01     XORLW 0x1
1626  1903     BTFSC STATUS, 0x2
1627  2DC6     GOTO 0x5C6
1628  3A03     XORLW 0x3
1629  1903     BTFSC STATUS, 0x2
162A  2DCA     GOTO 0x5CA
162B  3A01     XORLW 0x1
162C  1903     BTFSC STATUS, 0x2
162D  2DCE     GOTO 0x5CE
162E  3A07     XORLW 0x7
162F  1903     BTFSC STATUS, 0x2
1630  2DD2     GOTO 0x5D2
1631  3A01     XORLW 0x1
1632  1903     BTFSC STATUS, 0x2
1633  2DD6     GOTO 0x5D6
1634  3A15     XORLW 0x15
1635  1903     BTFSC STATUS, 0x2
1636  2DDA     GOTO 0x5DA
1637  3A30     XORLW 0x30
1638  1903     BTFSC STATUS, 0x2
1639  2DDD     GOTO 0x5DD
163A  3A10     XORLW 0x10
163B  1903     BTFSC STATUS, 0x2
163C  2DE9     GOTO 0x5E9
163D  3A01     XORLW 0x1
163E  1903     BTFSC STATUS, 0x2
163F  2DED     GOTO 0x5ED
1640  3A03     XORLW 0x3
1641  1903     BTFSC STATUS, 0x2
1642  2DF1     GOTO 0x5F1
1643  3A72     XORLW 0x72
1644  1903     BTFSC STATUS, 0x2
1645  2DF4     GOTO 0x5F4
1646  3A01     XORLW 0x1
1647  1903     BTFSC STATUS, 0x2
1648  2DF7     GOTO 0x5F7
1649  3A03     XORLW 0x3
164A  1903     BTFSC STATUS, 0x2
164B  2DFA     GOTO 0x5FA
164C  3A32     XORLW 0x32
164D  1903     BTFSC STATUS, 0x2
164E  2DFD     GOTO 0x5FD
164F  2E50     GOTO 0x650
310:               {
311:                   case 0x00:
312:                               #if defined(CONFIGURABLE_FILTERTYPE)
313:                               if ((value & 0x80) != 0)
1554  1FF4     BTFSS sensor, 0x7
1555  2D5A     GOTO 0x55A
314:                               {
315:                                   MTOUCH_flags.hamming_nAccumulation = 1;
1557  15D6     BSF MTOUCH_flags, 0x3
316:                                   #if defined(CONFIGURABLE_NUMBERSAMPLES)
317:                                   MTOUCH_numberSamples = MTOUCH_SAMPLES;
1556  3020     MOVLW 0x20
1558  00DB     MOVWF MTOUCH_numberSamples
318:                                   #endif
319:                               }
1559  2D5B     GOTO 0x55B
320:                               else                        
321:                               {
322:                                   MTOUCH_flags.hamming_nAccumulation = 0;
155A  11D6     BCF MTOUCH_flags, 0x3
323:                               }
324:                               #endif
325:                               #if defined(CONFIGURABLE_SAMPLETYPE)
326:                               if ((value & 0x40) != 0)    MTOUCH_flags.active_nJitter = 1;
155B  1F74     BTFSS sensor, 0x6
155C  2D5F     GOTO 0x55F
155D  1656     BSF MTOUCH_flags, 0x4
155E  2D60     GOTO 0x560
327:                               else                        MTOUCH_flags.active_nJitter = 0;
155F  1256     BCF MTOUCH_flags, 0x4
328:                               #endif
329:                               #if defined(CONFIGURABLE_GUARD)
330:                               if ((value & 0x20) != 0)    MTOUCH_flags.guard = 1;
1560  1EF4     BTFSS sensor, 0x5
1561  2D64     GOTO 0x564
1562  16D6     BSF MTOUCH_flags, 0x5
1563  2D65     GOTO 0x565
331:                               else                        MTOUCH_flags.guard = 0;
1564  12D6     BCF MTOUCH_flags, 0x5
332:                               #endif
333:                               CalibrateSensors(0xFF);                 break;
1565  30FF     MOVLW 0xFF
1566  2E51     GOTO 0x651
334:           
335:                   /* Sensor Thresholds */
336:                   case 0x40:  if ((int8_t)value < 0) { value = 0; }
1567  1BF4     BTFSC sensor, 0x7
1568  01F4     CLRF sensor
337:                               MTOUCH_button_threshold[0] = value;     break;
1569  0874     MOVF sensor, W
156A  0021     MOVLB 0x1
156B  00E8     MOVWF MTOUCH_button_threshold
156C  0008     RETURN
338:                   case 0x41:  if ((int8_t)value < 0) { value = 0; }
156D  1BF4     BTFSC 0xF4, 0x7
156E  01F4     CLRF 0xF4
339:                               MTOUCH_button_threshold[1] = value;     break;
156F  0874     MOVF 0xF4, W
1570  0021     MOVLB 0x1
1571  00E9     MOVWF 0xE9
1572  0008     RETURN
340:                   case 0x42:  if ((int8_t)value < 0) { value = 0; }
1573  1BF4     BTFSC 0xF4, 0x7
1574  01F4     CLRF 0xF4
341:                               MTOUCH_button_threshold[2] = value;     break;
1575  0874     MOVF 0xF4, W
1576  0021     MOVLB 0x1
1577  00EA     MOVWF 0xEA
1578  0008     RETURN
342:                   case 0x43:  if ((int8_t)value < 0) { value = 0; }
1579  1BF4     BTFSC 0xF4, 0x7
157A  01F4     CLRF 0xF4
343:                               MTOUCH_button_threshold[3] = value;     break;
157B  0874     MOVF 0xF4, W
157C  0021     MOVLB 0x1
157D  00EB     MOVWF 0xEB
157E  0008     RETURN
344:                   case 0x44:  if ((int8_t)value < 0) { value = 0; }
157F  1BF4     BTFSC 0xF4, 0x7
1580  01F4     CLRF 0xF4
345:                               MTOUCH_button_threshold[4] = value;     break;
1581  0874     MOVF 0xF4, W
1582  0021     MOVLB 0x1
1583  00EC     MOVWF 0xEC
1584  0008     RETURN
346:                   case 0x45:  if ((int8_t)value < 0) { value = 0; }
1585  1BF4     BTFSC 0xF4, 0x7
1586  01F4     CLRF 0xF4
347:                               MTOUCH_button_threshold[5] = value;     break;
1587  0874     MOVF 0xF4, W
1588  0021     MOVLB 0x1
1589  00ED     MOVWF 0xED
158A  0008     RETURN
348:           
349:                   #if defined(CONFIGURABLE_NOISETHRESH)
350:                   case 0x60:  MTOUCH_noise_threshold &= 0xFFFF00;
158B  0021     MOVLB 0x1
158C  30FF     MOVLW 0xFF
158D  01DE     CLRF MTOUCH_noise_threshold
158E  05DF     ANDWF 0xDF, F
158F  05E0     ANDWF 0xE0, F
351:                               MTOUCH_noise_threshold |= value;                    break;
1590  0874     MOVF 0xF4, W
1591  00F5     MOVWF 0xF5
1592  01F6     CLRF 0xF6
1593  01F7     CLRF 0xF7
1594  04DE     IORWF MTOUCH_noise_threshold, F
1595  0876     MOVF 0xF6, W
1596  04DF     IORWF 0xDF, F
1597  0877     MOVF 0xF7, W
1598  04E0     IORWF 0xE0, F
1599  0008     RETURN
352:                   case 0x61:  MTOUCH_noise_threshold &= 0xFF00FF;
159A  30FF     MOVLW 0xFF
159B  0021     MOVLB 0x1
159C  05DE     ANDWF MTOUCH_noise_threshold, F
159D  01DF     CLRF 0xDF
159E  05E0     ANDWF 0xE0, F
353:                               MTOUCH_noise_threshold |= (uint16_t)(value) << 8;   break;
159F  0874     MOVF 0xF4, W
15A0  00F5     MOVWF 0xF5
15A1  01F6     CLRF 0xF6
15A2  00F6     MOVWF 0xF6
15A3  01F5     CLRF 0xF5
15A4  0875     MOVF 0xF5, W
15A5  00F8     MOVWF 0xF8
15A6  0876     MOVF 0xF6, W
15A7  00F9     MOVWF 0xF9
15A8  01FA     CLRF 0xFA
15A9  0878     MOVF 0xF8, W
15AA  04DE     IORWF MTOUCH_noise_threshold, F
15AB  0879     MOVF 0xF9, W
15AC  04DF     IORWF 0xDF, F
15AD  087A     MOVF 0xFA, W
15AE  04E0     IORWF 0xE0, F
15AF  0008     RETURN
354:                   case 0x62:  MTOUCH_noise_threshold &= 0x00FFFF;
15B0  30FF     MOVLW 0xFF
15B1  0021     MOVLB 0x1
15B2  05DE     ANDWF MTOUCH_noise_threshold, F
15B3  05DF     ANDWF 0xDF, F
15B4  01E0     CLRF 0xE0
355:                               MTOUCH_noise_threshold |= (uint24_t)(value) << 16;  break;
15B5  0874     MOVF 0xF4, W
15B6  00F7     MOVWF 0xF7
15B7  01F6     CLRF 0xF6
15B8  01F5     CLRF 0xF5
15B9  0875     MOVF 0xF5, W
15BA  04DE     IORWF MTOUCH_noise_threshold, F
15BB  0876     MOVF 0xF6, W
15BC  04DF     IORWF 0xDF, F
15BD  0877     MOVF 0xF7, W
15BE  04E0     IORWF 0xE0, F
15BF  0008     RETURN
356:                   #endif
357:           
358:                   case 0x70:  CalibrateSensors(value);                break;
15C0  0874     MOVF 0xF4, W
15C1  2E51     GOTO 0x651
359:           
360:                   /* Sensor Delta Scaling */
361:                   case 0x80:  MTOUCH_delta_scaling[0] = value;        break;
15C2  0874     MOVF 0xF4, W
15C3  0021     MOVLB 0x1
15C4  00CA     MOVWF MTOUCH_delta_scaling
15C5  0008     RETURN
362:                   case 0x81:  MTOUCH_delta_scaling[1] = value;        break;
15C6  0874     MOVF 0xF4, W
15C7  0021     MOVLB 0x1
15C8  00CB     MOVWF 0xCB
15C9  0008     RETURN
363:                   case 0x82:  MTOUCH_delta_scaling[2] = value;        break;
15CA  0874     MOVF 0xF4, W
15CB  0021     MOVLB 0x1
15CC  00CC     MOVWF 0xCC
15CD  0008     RETURN
364:                   case 0x83:  MTOUCH_delta_scaling[3] = value;        break;
15CE  0874     MOVF 0xF4, W
15CF  0021     MOVLB 0x1
15D0  00CD     MOVWF 0xCD
15D1  0008     RETURN
365:                   case 0x84:  MTOUCH_delta_scaling[4] = value;        break;
15D2  0874     MOVF 0xF4, W
15D3  0021     MOVLB 0x1
15D4  00CE     MOVWF 0xCE
15D5  0008     RETURN
366:                   case 0x85:  MTOUCH_delta_scaling[5] = value;        break;
15D6  0874     MOVF 0xF4, W
15D7  0021     MOVLB 0x1
15D8  00CF     MOVWF 0xCF
15D9  0008     RETURN
367:                   #if (MTOUCH_SENSORS != 6)
368:                   #warning("Memory mapping should be updated to reflect the number of sensors.")
369:                   #endif
370:           
371:                   #if defined(CONFIGURABLE_SCANRATE_MIN)
372:                   case 0x90:  MTOUCH_frequency_min = value;           break;
15DA  0874     MOVF 0xF4, W
15DB  00D8     MOVWF 0xD8
15DC  0008     RETURN
373:                   #endif
374:                   #if defined(CONFIGURABLE_SCANRATE_TxCON)
375:                   case 0x91:  MTOUCH_frequency_txcon = value;         break;
376:                   #endif
377:           
378:                   #if defined(CONFIGURABLE_NUMBERSAMPLES)
379:                   case 0xA0:
380:                       #if defined(CONFIGURABLE_FILTERTYPE)
381:                       if (MTOUCH_flags.hamming_nAccumulation == 0)
15DD  19D6     BTFSC MTOUCH_prox_filter, 0x3
15DE  0008     RETURN
382:                       {
383:                           if (value > INT8_MAX) { MTOUCH_numberSamples = INT8_MAX;    }
15DF  3080     MOVLW 0x80
15E0  0274     SUBWF 0xF4, W
15E1  1C03     BTFSS 0x83, 0x0
15E2  2DE5     GOTO 0x5E5
15E3  307F     MOVLW 0x7F
15E4  2DE6     GOTO 0x5E6
384:                           else                  { MTOUCH_numberSamples = value;       }
15E5  0874     MOVF 0xF4, W
15E6  00DB     MOVWF 0xDB
385:                           CalibrateSensors(value);
15E7  0874     MOVF 0xF4, W
15E8  2E51     GOTO 0x651
386:                       }
387:                       break;
388:                       #endif
389:                   #endif
390:           
391:                   #if defined(CONFIGURABLE_READINGGAIN)
392:                   case 0xB0:  MTOUCH_readingGain = value;
15E9  0874     MOVF 0xF4, W
15EA  00DF     MOVWF 0xDF
393:                               CalibrateSensors(value);                break;
15EB  0874     MOVF 0xF4, W
15EC  2E51     GOTO 0x651
394:                   #endif
395:                   #if defined(CONFIGURABLE_BASELINEGAIN)
396:                   case 0xB1:  MTOUCH_baselineGain = value;
15ED  0874     MOVF 0xF4, W
15EE  00D3     MOVWF 0xD3
397:                               CalibrateSensors(value);                break;
15EF  0874     MOVF 0xF4, W
15F0  2E51     GOTO 0x651
398:                   #endif
399:                   #if defined(CONFIGURABLE_BASELINERATE)
400:                   case 0xB2:  MTOUCH_baselineRate = value;           break;
15F1  0874     MOVF 0xF4, W
15F2  00D4     MOVWF 0xD4
15F3  0008     RETURN
401:                   #endif
402:           
403:                   #if defined(CONFIGURABLE_NEGDELTACOUNTS)
404:                   case 0xC0:  MTOUCH_negDeltaCount = value;          break;
15F4  0874     MOVF 0xF4, W
15F5  00DA     MOVWF MTOUCH_prox_reading
15F6  0008     RETURN
405:                   #endif
406:                   #if defined(CONFIGURABLE_PRESSTIMEOUT)
407:                   case 0xC1:  MTOUCH_pressTimeout = value;           break;
15F7  0874     MOVF 0xF4, W
15F8  00DC     MOVWF 0xDC
15F9  0008     RETURN
408:                   #endif
409:                   #if defined(CONFIGURABLE_DEBOUNCE)
410:                   case 0xC2:  MTOUCH_debounce = value;               break;
15FA  0874     MOVF 0xF4, W
15FB  00D5     MOVWF 0xD5
15FC  0008     RETURN
411:                   #endif
412:           
413:                   /* Reserved memory space */
414:                   case 0xF0:  bank = value;   break;
15FD  0874     MOVF 0xF4, W
15FE  00E1     MOVWF tick
15FF  0008     RETURN
415:           
416:                   default:                    break;
417:               }
418:           }
1650  0008     RETURN
419:           
420:           uint8_t GetState(void)
421:           {
422:               uint8_t output = 0;
03E6  01F2     CLRF 0xF2
423:           
424:               for (uint8_t i = 0; i < MTOUCH_SENSORS; i++)
03E7  01F3     CLRF 0xF3
03F7  3006     MOVLW 0x6
03F8  0AF3     INCF 0xF3, F
03F9  0273     SUBWF 0xF3, W
03FA  1C03     BTFSS 0x83, 0x0
03FB  2BE8     GOTO 0x3E8
425:               {
426:                   if (MTOUCH_Button_State_Get(i) == MTOUCH_STATE_pressed)
03E8  0873     MOVF 0xF3, W
03E9  23DF     CALL 0x3DF
03EA  3180     MOVLP 0x0
03EB  3A02     XORLW 0x2
03EC  1D03     BTFSS 0x83, 0x2
03ED  2BF7     GOTO 0x3F7
427:                   {
428:                       output |= 0x01 << i;
03EE  3001     MOVLW 0x1
03EF  00F1     MOVWF 0xF1
03F0  0A73     INCF 0xF3, W
03F1  2BF3     GOTO 0x3F3
03F2  35F1     LSLF 0xF1, F
03F3  0B89     DECFSZ 0x89, F
03F4  2BF2     GOTO 0x3F2
03F5  0871     MOVF 0xF1, W
03F6  04F2     IORWF 0xF2, F
429:                   }
430:               }
431:               #if (MTOUCH_SENSORS != 6)
432:               #error("State mask creation must be updated to reflect the number of sensors.")
433:               #endif
434:           
435:               return output;
03FC  0872     MOVF 0xF2, W
436:           }
03FD  0008     RETURN
437:           
438:           uint8_t GetInterruptBit(void)
439:           {
440:               uint8_t i;
441:           
442:               for (i = 0; i < MTOUCH_SENSORS; i++)
03D2  01F1     CLRF 0xF1
03D9  3006     MOVLW 0x6
03DA  0AF1     INCF 0xF1, F
03DB  0271     SUBWF 0xF1, W
03DC  1803     BTFSC 0x83, 0x0
03DE  2BD3     GOTO 0x3D3
443:               {
444:                   if (MTOUCH_Button_State_Get(i) == MTOUCH_STATE_pressed)
03D3  0871     MOVF 0xF1, W
03D4  23DF     CALL 0x3DF
03D5  3180     MOVLP 0x0
03D6  3A02     XORLW 0x2
03D7  1903     BTFSC 0x83, 0x2
445:                   {
446:                       return 1;
03D8  3401     RETLW 0x1
447:                   }
448:               }
449:               return 0;
03DD  3400     RETLW 0x0
450:           }
451:           
452:           void CalibrateSensors(uint8_t mask)
1651  00F2     MOVWF 0xF2
453:           {
454:               uint8_t i;
455:               for (i = 0; i < MTOUCH_SENSORS; i++)
1652  01F3     CLRF 0xF3
1661  3006     MOVLW 0x6
456:               {
457:                   if ((mask & (0x01 << i)) != 0)
1653  3001     MOVLW 0x1
1654  00F1     MOVWF 0xF1
1655  0A73     INCF 0xF3, W
1656  2E58     GOTO 0x658
1657  35F1     LSLF 0xF1, F
1658  0B89     DECFSZ 0x89, F
1659  2E57     GOTO 0x657
165A  0871     MOVF 0xF1, W
165B  0572     ANDWF 0xF2, W
165C  1903     BTFSC 0x83, 0x2
165D  2E61     GOTO 0x661
458:                   {
459:                       MTOUCH_Scan_ResetCalibration(i);
165E  0873     MOVF 0xF3, W
165F  2667     CALL 0x667
1660  3195     MOVLP 0x15
460:                   }
461:               }
462:               #if (MTOUCH_SENSORS != 6)
463:               #error("Recalibration command must be updated to reflect the number of sensors.")
464:               #endif
465:           }
466:           #endif
---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/main_1559.c
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            
37:            #include <xc.h>
38:            #include <stdint.h>
39:            
40:            #if __XC8_VERSION != 1340
41:            #warning("This code was developed using XC8 v1.34")
42:            #endif
43:            
44:            #include "main.h"
45:            #include "configuration.h"
46:            #include "mtouch.h"
47:            #include "uart.h"
48:            #include "i2c.h"
49:            
50:            #ifdef _16LF1559
51:            #pragma config FOSC = INTOSC    // Oscillator Selection Bits (INTOSC oscillator: I/O function on CLKIN pin)
52:            #pragma config WDTE = SWDTEN    // Watchdog Timer Enable (WDT controlled by the SWDTEN bit in the WDTCON register)
53:            #pragma config PWRTE = ON       // Power-up Timer Enable (PWRT enabled)
54:            #pragma config MCLRE = OFF      // MCLR Pin Function Select (MCLR/VPP pin function is digital input)
55:            #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is enabled)
56:            #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
57:            #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
58:            #pragma config WRT = ALL        // Flash Memory Self-Write Protection (000h to FFFh write protected, no addresses may be modified by PMCON control)
59:            #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
60:            #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), 1.9V trip point selected.)
61:            #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
62:            #pragma config LVP = OFF        // Low-Voltage Programming Enable (High-voltage on MCLR/VPP must be used for programming)
63:            #else
64:            #error("This code was developed for the PIC16LF1559.")
65:            #endif
66:            
67:            extern MTOUCH_SAMPLE_t MTOUCH_lastSample[MTOUCH_SENSORS];
68:            
69:            void interrupt  ISR         (void);
70:            void            SYSTEM_Init (void);
71:            
72:            void main(void)
73:            {
74:                SYSTEM_Init();
0850  27D5     CALL 0x7D5
0851  3188     MOVLP 0x8
75:            
76:                #if defined(I2C_ENABLED)
77:                I2C_Init();
0852  206D     CALL 0x6D
0853  3188     MOVLP 0x8
78:                PIR1bits.SSP1IF = 0;
0854  0020     MOVLB 0x0
0855  1191     BCF PIR1, 0x3
79:                PIE1bits.SSP1IE = 1;
0856  0021     MOVLB 0x1
0857  1591     BSF PIE1, 0x3
80:                #endif
81:            
82:                #if defined(UART_ENABLED)
83:                UART_Init();
0858  23F5     CALL 0x3F5
0859  3188     MOVLP 0x8
84:                PIR1bits.RCIF = 0;
085A  0020     MOVLB 0x0
085B  1291     BCF PIR1, 0x5
85:                PIE1bits.RCIE = 1;
085C  0021     MOVLB 0x1
085D  1691     BSF PIE1, 0x5
86:                #endif
87:            
88:                MTOUCH_Init();
085E  23C1     CALL 0x3C1
085F  3188     MOVLP 0x8
89:            
90:                INTCONbits.PEIE = (uint8_t)1;
0860  170B     BSF 0x8B, 0x6
91:                INTCONbits.GIE  = (uint8_t)1;
0861  178B     BSF 0x8B, 0x7
92:            
93:                /**********************/
94:                /* START OF MAIN LOOP */
95:                /**********************/
96:                for(;;)
97:                {
98:                    INTCONbits.TMR0IE = 0;
0862  128B     BCF 0x8B, 0x5
99:                    LATAbits.LATA4 = 1;
0863  0022     MOVLB 0x2
0864  160C     BSF LATA, 0x4
100:                   MTOUCH_Scan();                  /* Scan the sensors */
0865  23E4     CALL 0x3E4
0866  3188     MOVLP 0x8
101:                   LATAbits.LATA4 = 0;
0867  0022     MOVLB 0x2
0868  120C     BCF LATA, 0x4
102:                   INTCONbits.TMR0IE = 1;
0869  168B     BSF 0x10B, 0x5
103:                   
104:                   MTOUCH_Decode();                /* Process the new data */
086A  207C     CALL 0x7C
086B  3188     MOVLP 0x8
105:           
106:                   #if defined(DEBUG_UART)
107:                   UART_SendShortLong(MTOUCH_lastSample[0] );
108:                   UART_SendShortLong(MTOUCH_Sensor_Reading_Get(0) );
109:                   UART_SendShortLong(MTOUCH_Sensor_Baseline_Get(0));
110:                   UART_SendSignedChar(MTOUCH_Sensor_Delta_Get(0));
111:                   UART_SendShortLong(MTOUCH_lastSample[2] );
112:                   UART_SendShortLong(MTOUCH_Sensor_Reading_Get(2) );
113:                   UART_SendShortLong(MTOUCH_Sensor_Baseline_Get(2));
114:                   UART_SendSignedChar(MTOUCH_Sensor_Delta_Get(2));
115:                   UART_SendNewLine();
116:                   #endif
117:               }
086C  2862     GOTO 0x62
118:               /**********************/
119:               /* END OF MAIN LOOP   */
120:               /**********************/
121:           }
122:           
123:           void interrupt ISR(void)
0004  147E     BSF 0x17E, 0x0
124:           {
125:               static uint8_t tick = 0;
126:           
127:               #if defined(UART_ENABLED)
128:               if (PIE1bits.RCIE == 1)
0006  0021     MOVLB 0x1
0007  1E91     BTFSS PIE1, 0x5
0008  2813     GOTO 0x13
129:               {
130:                   if (PIR1bits.RCIF == 1)
0009  0020     MOVLB 0x0
000A  1E91     BTFSS PIR1, 0x5
000B  2813     GOTO 0x13
131:                   {
132:                       PIR1bits.RCIF = 0;
000C  1291     BCF PIR1, 0x5
133:                       UART_Receive_Service();
000D  3180     MOVLP 0x0
000E  2035     CALL 0x35
000F  3180     MOVLP 0x0
134:                       MTOUCH_Notify_InterruptServiced();  /* Required. */
0010  3187     MOVLP 0x7
0011  27FA     CALL 0x7FA
0012  3180     MOVLP 0x0
135:                   }
136:               }
137:               #endif
138:           
139:               #if defined(I2C_ENABLED)
140:               if (PIE1bits.SSP1IE == 1)
0013  0021     MOVLB 0x1
0014  1D91     BTFSS PIE1, 0x3
0015  2820     GOTO 0x20
141:               {
142:                   if (PIR1bits.SSP1IF == 1)
0016  0020     MOVLB 0x0
0017  1D91     BTFSS PIR1, 0x3
0018  2820     GOTO 0x20
143:                   {
144:                       PIR1bits.SSP1IF = 0;
0019  1191     BCF PIR1, 0x3
145:                       I2C_Service();
001A  3195     MOVLP 0x15
001B  251B     CALL 0x51B
001C  3180     MOVLP 0x0
146:                       MTOUCH_Notify_InterruptServiced();  /* Required. */
001D  3187     MOVLP 0x7
001E  27FA     CALL 0x7FA
001F  3180     MOVLP 0x0
147:                   }
148:               }
149:               #endif
150:           
151:               if (INTCONbits.TMR0IF == 1)
0020  1D0B     BTFSS INTCON, 0x2
0021  282C     GOTO 0x2C
152:               {
153:               //LATAbits.LATA5 = 1;
154:                   INTCONbits.TMR0IF = 0;
0022  110B     BCF INTCON, 0x2
155:           
156:                   tick++;
0023  0021     MOVLB 0x1
0024  0AE1     INCF tick, F
157:                   if (tick == COUNT_0p5sec)
0025  0861     MOVF tick, W
0026  3A3D     XORLW 0x3D
0027  1D03     BTFSS 0x83, 0x2
0028  282C     GOTO 0x2C
158:                   {
159:                       tick = 0;
0029  01E1     CLRF tick
160:                       MTOUCH_Service_Tick();
002A  3194     MOVLP 0x14
002B  24A9     CALL 0x4A9
161:                   }
162:               //LATAbits.LATA5 = 0;
163:               }
164:           
165:           
166:               /* Other ISR services may be placed here. */
167:           }
002C  107E     BCF 0xFE, 0x0
168:           
169:           void SYSTEM_Init(void)
170:           {
171:               OSCCON  = (uint8_t)0b11110000;  /* 32 MHz. No PLL.              */
0FD5  30F0     MOVLW 0xF0
0FD6  0021     MOVLB 0x1
0FD7  0099     MOVWF OSCCON
172:               WDTCON  = (uint8_t)0;           /* Disable watchdog.            */
0FD8  0197     CLRF WDTCON
173:           #if defined(DEBUG_I2C)
174:               APFCON  = (uint8_t)0b00000000;  /* AD1GRDA on RC4. SDA on RB4.  */
175:           #else
176:               APFCON  = (uint8_t)0b00010000;  /* AD1GRDA on RC4. SDA on RA3.  */
0FD9  3010     MOVLW 0x10
0FDA  0022     MOVLB 0x2
0FDB  009D     MOVWF APFCON
177:           #endif
178:           
179:           #if defined(DEBUG_I2C)
180:               LATA    = (uint8_t)0;
181:               ANSELA  = (uint8_t)0;
182:               TRISA   = (uint8_t)0b00010011;
183:           #else
184:               LATA    = (uint8_t)0;
0FDC  018C     CLRF LATA
185:               ANSELA  = (uint8_t)0;
0FDD  0023     MOVLB 0x3
0FDE  018C     CLRF ANSELA
186:               TRISA   = (uint8_t)0b00001011;
0FDF  300B     MOVLW 0xB
0FE0  0021     MOVLB 0x1
0FE1  008C     MOVWF TRISA
187:                           /*         ||||||_____- LED5
188:                            *         |||||______- LED4
189:                            *         ||||_______- CS4
190:                            *         |||________- SDA
191:                            *         ||_________- ADTRIG
192:                            *         |__________- CS5
193:                            */
194:           #endif
195:           
196:           #if defined(DEBUG_I2C)
197:               LATB    = (uint8_t)0;
198:               ANSELB  = (uint8_t)0;
199:               TRISB   = (uint8_t)0b11110000;
200:           #else
201:               LATB    = (uint8_t)0;
0FE2  0022     MOVLB 0x2
0FE3  018D     CLRF LATB
202:               ANSELB  = (uint8_t)0;
0FE4  0023     MOVLB 0x3
0FE5  018D     CLRF ANSELB
203:               TRISB   = (uint8_t)0b11100000;
0FE6  30E0     MOVLW 0xE0
0FE7  0021     MOVLB 0x1
0FE8  008D     MOVWF TRISB
204:                           /*       ||||_________- CS1
205:                            *       |||__________- RX
206:                            *       ||___________- SCL
207:                            *       |____________- TX
208:                            */
209:           #endif
210:           
211:               LATC    = (uint8_t)0;
0FE9  0022     MOVLB 0x2
0FEA  018E     CLRF LATC
212:               ANSELC  = (uint8_t)0;
0FEB  0023     MOVLB 0x3
0FEC  018E     CLRF ANSELC
213:               TRISC   = (uint8_t)0b10101100;
0FED  30AC     MOVLW 0xAC
0FEE  0021     MOVLB 0x1
0FEF  008E     MOVWF TRISC
214:                           /*       ||||||||_____- CS3
215:                            *       |||||||______- CS2
216:                            *       ||||||_______- LED0
217:                            *       |||||________- LED1
218:                            *       ||||_________- AD1GRDA
219:                            *       |||__________- LED3
220:                            *       ||___________- CS0
221:                            *       |____________- LED2
222:                            */
223:           
224:               OPTION_REG = (uint8_t)0b10000111;
0FF0  3087     MOVLW 0x87
0FF1  0095     MOVWF OPTION_REG
225:               INTCONbits.TMR0IE = 1;
0FF2  168B     BSF 0x8B, 0x5
226:           }
0FF3  0008     RETURN
---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/i2c.c  -
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            
37:            #include <xc.h>
38:            #include <stdint.h>
39:            
40:            #include "i2c.h"
41:            #include "memory.h"
42:            
43:            #define I2C_CMD_WRITE   ((uint8_t)0)
44:            #define I2C_BYTE_ADDR   ((uint8_t)0)
45:            
46:            void I2C_Init(void)
47:            {
48:                SSPSTAT = (uint8_t)0b11000000;  /* Slew rate control disabled. 100kHz and 1MHz.
086D  30C0     MOVLW 0xC0
086E  0024     MOVLB 0x4
086F  0094     MOVWF SSP1STAT
49:                                                 * SMBus-compliant voltage thresholds enabled. */
50:                SSPCON1 = (uint8_t)0b00000110;  /* Clear write collision and overflow bits.
0870  3006     MOVLW 0x6
0871  0095     MOVWF SSP1CON1
51:                                                 * SSP module disabled until init is complete.
52:                                                 * I2C slave mode w/o START or STOP interrupts. */
53:                SSPCON2 = (uint8_t)0b00000001;  /* General call address disabled.
0872  3001     MOVLW 0x1
0873  0096     MOVWF SSP1CON2
54:                                                 * Clock stretching enabled. */
55:                SSPCON3 = (uint8_t)0b00010000;  /* Start/Stop interrupts disabled.
0874  3010     MOVLW 0x10
0875  0097     MOVWF SSP1CON3
56:                                                 * Buffer overwrite is enabled. NACK sent if this occurs.
57:                                                 * Bus collision interrupt disabled.
58:                                                 * Address and Data byte clock stretching disabled. */
59:                SSPMSK = (uint8_t)0xFF;         /* All address bits required to match. */
0876  30FF     MOVLW 0xFF
0877  0093     MOVWF SSP1MSK
60:                SSPADD = (uint8_t)0b01010000;   /* Address is the same as the CAP1114. */
0878  3050     MOVLW 0x50
0879  0092     MOVWF SSP1ADD
61:            
62:                SSPCON1bits.SSPEN = (uint8_t)1; /* Enable I2C communications. */
087A  1695     BSF SSP1CON1, 0x5
63:            }
0004  147E     BSF 0x27E, 0x0
0005  3180     MOVLP 0x0
087B  0008     RETURN
64:            
65:            void I2C_Service(void)
66:            {
67:                static  uint8_t             count               = (uint8_t)0;
68:                static  uint8_t             startAddress        = (uint8_t)0;
69:            
70:                uint8_t data = SSPBUF;
151B  0024     MOVLB 0x4
151C  0811     MOVF SSP1BUF, W
151D  0020     MOVLB 0x0
151E  00A0     MOVWF __pcstackBANK0
71:            
72:                if (SSPCON1bits.SSPOV != (uint8_t)0)
151F  0024     MOVLB 0x4
1520  1B15     BTFSC SSP1CON1, 0x6
73:                {
74:                    /*
75:                     * An overflow has occurred. The only safe recovery is to reset the
76:                     * MSSP module and wait for the start of a new packet.
77:                     */
78:                    SSPCON1bits.SSPEN = (uint8_t)0;
1521  2D4D     GOTO 0x54D
79:                    SSPCON1bits.SSPEN = (uint8_t)1;
80:                }
81:                else
82:                {
83:                    if (SSPSTATbits.R_nW == I2C_CMD_WRITE)
1522  1914     BTFSC SSP1STAT, 0x2
1523  2D3A     GOTO 0x53A
84:                    {
85:                        if (SSPSTATbits.D_nA == I2C_BYTE_ADDR)
1524  1A94     BTFSC SSP1STAT, 0x5
1525  2D2A     GOTO 0x52A
86:                        {
87:                            /* Address byte received with 'write' bit set */
88:                            count = (uint8_t)0xFF;
1526  30FF     MOVLW 0xFF
1527  0020     MOVLB 0x0
1528  00C9     MOVWF count
89:                        }
1529  2D4F     GOTO 0x54F
90:                        else
91:                        {
92:                            /* Data byte received while in 'write' mode */
93:                            if (count == (uint8_t)0xFF)
152A  0020     MOVLB 0x0
152B  0849     MOVF count, W
152C  3AFF     XORLW 0xFF
152D  1D03     BTFSS STATUS, 0x2
152E  2D33     GOTO 0x533
94:                            {
95:                                /* This is the first byte received after a 'write' device
96:                                 * address match. Store the byte as the start address. */
97:                                startAddress  = data;
152F  0820     MOVF __pcstackBANK0, W
1530  00CA     MOVWF startAddress
98:                                count = (uint8_t)0;
1531  01C9     CLRF count
99:                            }
1532  2D4F     GOTO 0x54F
100:                           else
101:                           {
102:                               MEMORY_Write((uint8_t)(startAddress + count), data);
1533  0820     MOVF __pcstackBANK0, W
1534  00F4     MOVWF sensor
1535  084A     MOVF startAddress, W
1536  0749     ADDWF count, W
1537  2552     CALL 0x552
1538  3195     MOVLP 0x15
1539  2D46     GOTO 0x546
103:                               count++;
104:                               if (count == (uint8_t)0xFF)
105:                               {
106:                                   /* The host should never be writing this many
107:                                    * consecutive bytes. Reset the MSSP.
108:                                    */
109:                                   SSPCON1bits.SSPEN = (uint8_t)0;
110:                                   SSPCON1bits.SSPEN = (uint8_t)1;
111:                               }
112:                           }
113:                       }
114:                   }
115:                   else /* READ */
116:                   {
117:                       if (SSPSTATbits.D_nA == I2C_BYTE_ADDR)
153A  1A94     BTFSC 0x14, 0x5
153B  2D3E     GOTO 0x53E
118:                       {
119:                           /* Address byte received with 'read' bit set. Reset the count
120:                            * variable to start reading at the currently set startAddress. */
121:                           count = (uint8_t)0;
153C  0020     MOVLB 0x0
153D  01C9     CLRF count
122:                       }
123:           
124:                       SSPBUF = MEMORY_Read(startAddress + count);
153E  0020     MOVLB 0x0
153F  084A     MOVF startAddress, W
1540  0749     ADDWF count, W
1541  3181     MOVLP 0x1
1542  2105     CALL 0x105
1543  3195     MOVLP 0x15
1544  0024     MOVLB 0x4
1545  0091     MOVWF SSP1BUF
125:                       count++;
1546  0020     MOVLB 0x0
1547  0AC9     INCF count, F
126:                       if (count == (uint8_t)0xFF)
1548  0849     MOVF count, W
1549  3AFF     XORLW 0xFF
154A  1D03     BTFSS STATUS, 0x2
154B  2D4F     GOTO 0x54F
127:                       {
128:                           /* 
129:                            * The host should never be reading this many
130:                            * consecutive bytes. Reset the MSSP.
131:                            */
132:                           SSPCON1bits.SSPEN = (uint8_t)0;
154C  0024     MOVLB 0x4
154D  1295     BCF SSP1CON1, 0x5
133:                           SSPCON1bits.SSPEN = (uint8_t)1;
154E  1695     BSF SSP1CON1, 0x5
134:                       }
135:                   }
136:               }
137:               SSPCON1bits.CKP = (uint8_t)1; /* Release clock stretch */
154F  0024     MOVLB 0x4
1550  1615     BSF SSP1CON1, 0x4
138:           }
1551  0008     RETURN
---  /Users/c14652/Dropbox/work/HMID Parts/PIC/PIC16F1554_1559/mTouch Eval Board/firmware/source/hamming.c
1:             /*
2:                 MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:
3:             
4:                 You may use this software, and any derivatives created by any person or
5:                 entity by or on your behalf, exclusively with Microchip's products.
6:                 Microchip and its subsidiaries ("Microchip"), and its licensors, retain all
7:                 ownership and intellectual property rights in the accompanying software and
8:                 in all derivatives hereto.
9:             
10:                This software and any accompanying information is for suggestion only. It
11:                does not modify Microchip's standard warranty for its products.  You agree
12:                that you are solely responsible for testing the software and determining
13:                its suitability.  Microchip has no obligation to modify, test, certify, or
14:                support the software.
15:            
16:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
17:                EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
18:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
19:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S
20:                PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
21:            
22:                IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
23:                (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
24:                INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
25:                EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
26:                ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
28:                FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL
29:                LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
30:                THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
31:                THIS SOFTWARE.
32:            
33:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
34:                THESE TERMS.
35:            */
36:            
37:            #include <stdint.h>
38:            #include "configuration.h"
39:            #include "hamming.h"
40:            
41:            uint16_t MTOUCH_Hamming(uint8_t index, uint16_t value)
1673  00A5     MOVWF 0x225
42:            {
43:                uint8_t i = index;
1674  00A6     MOVWF 0x226
44:                uint16_t output;
45:                uint16_t temp;
46:            
47:            #if MTOUCH_SAMPLES == 32
48:                /* Final scaling amount: 16.50391 */
49:            
50:                if (i > (uint8_t)31)
1675  3020     MOVLW 0x20
1676  0226     SUBWF 0x226, W
1677  1C03     BTFSS 0x203, 0x0
1678  2E7C     GOTO 0x67C
51:                {
52:                    output = (uint16_t)0;
1679  01A7     CLRF 0x227
167A  01A8     CLRF 0x228
53:                }
167B  2FFB     GOTO 0x7FB
54:                else
55:                {
56:                    if (i > (uint8_t)15)
167C  3010     MOVLW 0x10
167D  0226     SUBWF 0x226, W
167E  1C03     BTFSS 0x203, 0x0
167F  2E83     GOTO 0x683
57:                    {
58:                        i = (uint8_t)((uint8_t)(31) - i);
1680  0826     MOVF 0x226, W
1681  3C1F     SUBLW 0x1F
1682  00A6     MOVWF 0x226
59:                    }
60:            
61:                #if 0
62:                    switch(i)
63:                    {
64:                        case 0:     output = (uint16_t)((         (value >> (uint8_t) 7)  + (value >> (uint8_t)10)) + (value >> (uint8_t)12)); /* 0.009033203 */ break;
65:                        case 1:     output = (uint16_t)((         (value >> (uint8_t) 5)  + (value >> (uint8_t) 8)) + (value >> (uint8_t)10)); /* 0.035888672 */ break;
66:                        case 2:     output = (uint16_t)((         (value >> (uint8_t) 4)  + (value >> (uint8_t) 6)) + (value >> (uint8_t)10)); /* 0.079345703 */ break;
67:                        case 3:     output = (uint16_t) (         (value >> (uint8_t) 3)  + (value >> (uint8_t) 6)                          ); /* 0.138183594 */ break;
68:                        case 4:     output = (uint16_t)((         (value >> (uint8_t) 2)  - (value >> (uint8_t) 5)) - (value >> (uint8_t) 7)); /* 0.209960938 */ break;
69:                        case 5:     output = (uint16_t)((         (value >> (uint8_t) 2)  + (value >> (uint8_t) 5)) + (value >> (uint8_t) 6)); /* 0.29296875  */ break;
70:                        case 6:     output = (uint16_t)((         (value >> (uint8_t) 1)  - (value >> (uint8_t) 3)) + (value >> (uint8_t) 7)); /* 0.382324219 */ break;
71:                        case 7:     output = (uint16_t)((         (value >> (uint8_t) 1)  - (value >> (uint8_t) 5)) + (value >> (uint8_t) 7)); /* 0.476074219 */ break;
72:                        case 8:     output = (uint16_t)((         (value >> (uint8_t) 1)  + (value >> (uint8_t) 4)) + (value >> (uint8_t) 7)); /* 0.571289063 */ break;
73:                        case 9:     output = (uint16_t)((         (value >> (uint8_t) 1)  + (value >> (uint8_t) 3)) + (value >> (uint8_t) 5)); /* 0.6640625   */ break;
74:                        case 10:    output = (uint16_t) ( value - (value >> (uint8_t) 2)                                                    ); /* 0.75        */ break;
75:                        case 11:    output = (uint16_t)(((value - (value >> (uint8_t) 3)) - (value >> (uint8_t) 4)) + (value >> (uint8_t) 6)); /* 0.828125    */ break;
76:                        case 12:    output = (uint16_t)(((value - (value >> (uint8_t) 3)) + (value >> (uint8_t) 6)) + (value >> (uint8_t) 9)); /* 0.892578125 */ break;
77:                        case 13:    output = (uint16_t)(((value - (value >> (uint8_t) 4)) + (value >> (uint8_t) 7)) - (value >> (uint8_t)10)); /* 0.944335938 */ break;
78:                        case 14:    output = (uint16_t)(((value - (value >> (uint8_t) 6)) - (value >> (uint8_t) 8)) - (value >> (uint8_t)11)); /* 0.979980469 */ break;
79:                        case 15:    output = (uint16_t)(((value - (value >> (uint8_t) 9)) - (value >> (uint8_t)12))                         ); /* 0.997802734 */ break;
80:                        default:    output = (uint16_t)0; break;
81:                    }
82:                #else
83:                    output = (uint16_t)0;
1683  01A7     CLRF 0x227
1684  01A8     CLRF 0x228
84:                    switch(i)
106C  3196     MOVLP 0x16
1685  2FF1     GOTO 0x7F1
17F1  0826     MOVF 0x226, W
17F2  0084     MOVWF 0x204
17F3  3010     MOVLW 0x10
17F4  0204     SUBWF 0x204, W
17F5  1803     BTFSC 0x203, 0x0
17F6  2FFB     GOTO 0x7FB
17F7  3190     MOVLP 0x10
17F8  3504     LSLF 0x204, W
17F9  3E6C     ADDLW 0x6C
17FA  0082     MOVWF 0x202
85:                    {
86:                        case 0:     /* output = (value >> 7) + (value >> 10) + (value >> 12) */
87:                            temp    = value >> 7;   output += temp;
1686  0822     MOVF 0x222, W
1687  00AA     MOVWF 0x22A
1688  0821     MOVF 0x221, W
1689  00A9     MOVWF 0x229
168A  3007     MOVLW 0x7
168B  36AA     LSRF 0x22A, F
168C  0CA9     RRF 0x229, F
168D  0B89     DECFSZ 0x209, F
168E  2E8B     GOTO 0x68B
168F  0829     MOVF 0x229, W
1690  07A7     ADDWF 0x227, F
1691  082A     MOVF 0x22A, W
1692  3DA8     ADDWFC 0x228, F
88:                            temp    = temp  >> 3;   output += temp;
1693  36AA     LSRF 0x22A, F
1694  0CA9     RRF 0x229, F
1695  36AA     LSRF 0x22A, F
1696  0CA9     RRF 0x229, F
1697  36AA     LSRF 0x22A, F
1698  0CA9     RRF 0x229, F
1699  0829     MOVF 0x229, W
169A  07A7     ADDWF 0x227, F
169B  082A     MOVF 0x22A, W
169C  3DA8     ADDWFC 0x228, F
89:                                                    output += temp >> 2;
169D  082A     MOVF 0x22A, W
169E  2F85     GOTO 0x785
90:                            break;
91:                        case 1:     /* output = (value >> 5) + (value >> 8) + (value >> 10) */
92:                                                    output  = value >> 5;
169F  0822     MOVF 0x222, W
16A0  00A8     MOVWF 0x228
16A1  0821     MOVF 0x221, W
16A2  00A7     MOVWF 0x227
16A3  3005     MOVLW 0x5
16A4  36A8     LSRF 0x228, F
16A5  0CA7     RRF 0x227, F
16A6  0B89     DECFSZ 0x209, F
16A7  2EA4     GOTO 0x6A4
93:                            temp    = value >> 8;   output += temp;
16A8  0822     MOVF 0x222, W
16A9  00A9     MOVWF 0x229
16AA  01AA     CLRF 0x22A
16AB  2E99     GOTO 0x699
94:                                                    output += temp >> 2;
95:                            break;
96:                        case 2:     /* output = (value >> 4) + (value >> 6) + (value >> 10) */
97:                            temp    = value >> 4;   output += temp;
16AC  0822     MOVF 0x222, W
16AD  00AA     MOVWF 0x22A
16AE  0821     MOVF 0x221, W
16AF  00A9     MOVWF 0x229
16B0  300F     MOVLW 0xF
16B1  0EA9     SWAPF 0x229, F
16B2  0EAA     SWAPF 0x22A, F
16B3  05A9     ANDWF 0x229, F
16B4  082A     MOVF 0x22A, W
16B5  39F0     ANDLW 0xF0
16B6  04A9     IORWF 0x229, F
16B7  300F     MOVLW 0xF
16B8  05AA     ANDWF 0x22A, F
16B9  0829     MOVF 0x229, W
16BA  07A7     ADDWF 0x227, F
16BB  082A     MOVF 0x22A, W
16BC  3DA8     ADDWFC 0x228, F
98:                            temp    = temp  >> 2;   output += temp;
16BD  36AA     LSRF 0x22A, F
16BE  0CA9     RRF 0x229, F
16BF  36AA     LSRF 0x22A, F
16C0  0CA9     RRF 0x229, F
16C1  0829     MOVF 0x229, W
16C2  07A7     ADDWF 0x227, F
16C3  082A     MOVF 0x22A, W
16C4  3DA8     ADDWFC 0x228, F
99:                                                    output += temp >> 4;
16C5  00A4     MOVWF 0x224
16C6  0829     MOVF 0x229, W
16C7  00A3     MOVWF 0x223
16C8  3004     MOVLW 0x4
16C9  36A4     LSRF 0x224, F
16CA  0CA3     RRF 0x223, F
16CB  0B89     DECFSZ 0x209, F
16CC  2EC9     GOTO 0x6C9
16CD  2F8C     GOTO 0x78C
100:                           break;
101:                       case 3:     /* output = (value >> 3) + (value >> 6) */
102:                           temp    = value >> 3;   output += temp;
16CE  0822     MOVF 0x222, W
16CF  00AA     MOVWF 0x22A
16D0  0821     MOVF 0x221, W
16D1  00A9     MOVWF 0x229
16D2  2F43     GOTO 0x743
103:                                                   output += temp  >> 3;
104:                           break;
105:                       case 4:     /* output = (value >> 2) - (value >> 5) - (value >> 7) */
106:                           temp    = value >> 2;   output += temp;
16D3  0822     MOVF 0x222, W
16D4  00AA     MOVWF 0x22A
16D5  0821     MOVF 0x221, W
16D6  00A9     MOVWF 0x229
16D7  36AA     LSRF 0x22A, F
16D8  0CA9     RRF 0x229, F
16D9  36AA     LSRF 0x22A, F
16DA  0CA9     RRF 0x229, F
16DB  0829     MOVF 0x229, W
16DC  07A7     ADDWF 0x227, F
16DD  082A     MOVF 0x22A, W
16DE  3DA8     ADDWFC 0x228, F
107:                           temp    = temp  >> 3;   output -= temp;
16DF  36AA     LSRF 0x22A, F
16E0  0CA9     RRF 0x229, F
16E1  36AA     LSRF 0x22A, F
16E2  0CA9     RRF 0x229, F
16E3  36AA     LSRF 0x22A, F
16E4  0CA9     RRF 0x229, F
16E5  0829     MOVF 0x229, W
16E6  02A7     SUBWF 0x227, F
16E7  082A     MOVF 0x22A, W
16E8  3BA8     SUBWFB 0x228, F
108:                                                   output -= temp  >> 2;
16E9  00A4     MOVWF 0x224
16EA  0829     MOVF 0x229, W
16EB  2F6C     GOTO 0x76C
109:                           break;
110:                       case 5:     /* output = (value >> 2) + (value >> 5) + (value >> 6) */
111:                           temp    = value >> 2;   output += temp;
16EC  0822     MOVF 0x222, W
16ED  00AA     MOVWF 0x22A
16EE  0821     MOVF 0x221, W
16EF  00A9     MOVWF 0x229
16F0  36AA     LSRF 0x22A, F
16F1  0CA9     RRF 0x229, F
16F2  36AA     LSRF 0x22A, F
16F3  0CA9     RRF 0x229, F
16F4  0829     MOVF 0x229, W
16F5  07A7     ADDWF 0x227, F
16F6  082A     MOVF 0x22A, W
16F7  3DA8     ADDWFC 0x228, F
112:                           temp    = temp  >> 3;   output += temp;
16F8  36AA     LSRF 0x22A, F
16F9  0CA9     RRF 0x229, F
16FA  36AA     LSRF 0x22A, F
16FB  0CA9     RRF 0x229, F
16FC  36AA     LSRF 0x22A, F
16FD  0CA9     RRF 0x229, F
16FE  0829     MOVF 0x229, W
16FF  07A7     ADDWF 0x227, F
1700  082A     MOVF 0x22A, W
1701  3DA8     ADDWFC 0x228, F
113:                                                   output += temp  >> 1;
1702  00A4     MOVWF 0x224
1703  0829     MOVF 0x229, W
1704  00A3     MOVWF 0x223
1705  2F8A     GOTO 0x78A
114:                           break;
115:                       case 6:     /* output = (value >> 1) - (value >> 3) + (value >> 7) */
116:                           temp    = value >> 1;   output += temp;
1706  0822     MOVF 0x222, W
1707  00AA     MOVWF 0x22A
1708  0821     MOVF 0x221, W
1709  00A9     MOVWF 0x229
170A  36AA     LSRF 0x22A, F
170B  0CA9     RRF 0x229, F
170C  0829     MOVF 0x229, W
170D  07A7     ADDWF 0x227, F
170E  082A     MOVF 0x22A, W
170F  3DA8     ADDWFC 0x228, F
117:                           temp    = temp  >> 2;   output -= temp;
1710  36AA     LSRF 0x22A, F
1711  0CA9     RRF 0x229, F
1712  36AA     LSRF 0x22A, F
1713  0CA9     RRF 0x229, F
1714  0829     MOVF 0x229, W
1715  02A7     SUBWF 0x227, F
1716  082A     MOVF 0x22A, W
1717  3BA8     SUBWFB 0x228, F
118:                                                   output += temp  >> 4;
1718  00A4     MOVWF 0x224
1719  0829     MOVF 0x229, W
171A  00A3     MOVWF 0x223
171B  3004     MOVLW 0x4
171C  36A4     LSRF 0x224, F
171D  0CA3     RRF 0x223, F
171E  0B89     DECFSZ 0x209, F
171F  2F1C     GOTO 0x71C
1720  2F8C     GOTO 0x78C
119:                           break;
120:                       case 7:     /* output = (value >> 1) - (value >> 5) + (value >> 7) */
121:                           temp    = value >> 1;   output += temp;
1721  0822     MOVF 0x222, W
1722  00AA     MOVWF 0x22A
1723  0821     MOVF 0x221, W
1724  00A9     MOVWF 0x229
1725  36AA     LSRF 0x22A, F
1726  0CA9     RRF 0x229, F
1727  0829     MOVF 0x229, W
1728  07A7     ADDWF 0x227, F
1729  082A     MOVF 0x22A, W
172A  3DA8     ADDWFC 0x228, F
122:                           temp    = temp  >> 4;   output -= temp;
172B  300F     MOVLW 0xF
172C  0EA9     SWAPF 0x229, F
172D  0EAA     SWAPF 0x22A, F
172E  05A9     ANDWF 0x229, F
172F  082A     MOVF 0x22A, W
1730  39F0     ANDLW 0xF0
1731  04A9     IORWF 0x229, F
1732  300F     MOVLW 0xF
1733  05AA     ANDWF 0x22A, F
1734  0829     MOVF 0x229, W
1735  02A7     SUBWF 0x227, F
1736  082A     MOVF 0x22A, W
1737  3BA8     SUBWFB 0x228, F
1738  2E9D     GOTO 0x69D
123:                                                   output += temp  >> 2;
124:                           break;
125:                       case 8:     /* output = (value >> 1) + (value >> 4) + (value >> 7) */
126:                           temp    = value >> 1;   output += temp;
1739  0822     MOVF 0x222, W
173A  00AA     MOVWF 0x22A
173B  0821     MOVF 0x221, W
173C  00A9     MOVWF 0x229
173D  36AA     LSRF 0x22A, F
173E  0CA9     RRF 0x229, F
173F  0829     MOVF 0x229, W
1740  07A7     ADDWF 0x227, F
1741  082A     MOVF 0x22A, W
1742  3DA8     ADDWFC 0x228, F
127:                           temp    = temp  >> 3;   output += temp;
1743  36AA     LSRF 0x22A, F
1744  0CA9     RRF 0x229, F
1745  36AA     LSRF 0x22A, F
1746  0CA9     RRF 0x229, F
1747  36AA     LSRF 0x22A, F
1748  0CA9     RRF 0x229, F
1749  0829     MOVF 0x229, W
174A  07A7     ADDWF 0x227, F
174B  082A     MOVF 0x22A, W
174C  3DA8     ADDWFC 0x228, F
128:                                                   output += temp  >> 3;
174D  00A4     MOVWF 0x224
174E  0829     MOVF 0x229, W
174F  00A3     MOVWF 0x223
1750  36A4     LSRF 0x224, F
1751  0CA3     RRF 0x223, F
1752  2F88     GOTO 0x788
129:                           break;
130:                       case 9:     /* output = (value >> 1) + (value >> 3) + (value >> 5) */
131:                           temp    = value >> 1;   output += temp;
1753  0822     MOVF 0x222, W
1754  00AA     MOVWF 0x22A
1755  0821     MOVF 0x221, W
1756  00A9     MOVWF 0x229
1757  36AA     LSRF 0x22A, F
1758  0CA9     RRF 0x229, F
1759  0829     MOVF 0x229, W
175A  07A7     ADDWF 0x227, F
175B  082A     MOVF 0x22A, W
175C  3DA8     ADDWFC 0x228, F
132:                           temp    = temp  >> 2;   output += temp;
175D  36AA     LSRF 0x22A, F
175E  0CA9     RRF 0x229, F
175F  36AA     LSRF 0x22A, F
1760  0CA9     RRF 0x229, F
1761  0829     MOVF 0x229, W
1762  07A7     ADDWF 0x227, F
1763  082A     MOVF 0x22A, W
1764  3DA8     ADDWFC 0x228, F
1765  2F85     GOTO 0x785
133:                                                   output += temp  >> 2;
134:                           break;
135:                       case 10:    /* output = value - (value >> 2) */
136:                                                   output += value;
1766  0821     MOVF 0x221, W
1767  07A7     ADDWF 0x227, F
1768  0822     MOVF 0x222, W
1769  3DA8     ADDWFC 0x228, F
137:                                                   output -= value >> 2;
176A  00A4     MOVWF 0x224
176B  0821     MOVF 0x221, W
176C  00A3     MOVWF 0x223
176D  2FC7     GOTO 0x7C7
138:                           break;
139:                       case 11:    /* output = value - (value >> 3) - (value >> 4) + (value >> 6) */
140:                                                   output += value;
176E  0821     MOVF 0x221, W
176F  07A7     ADDWF 0x227, F
1770  0822     MOVF 0x222, W
1771  3DA8     ADDWFC 0x228, F
141:                           temp    = value >> 3;   output -= temp;
1772  00AA     MOVWF 0x22A
1773  0821     MOVF 0x221, W
1774  00A9     MOVWF 0x229
1775  36AA     LSRF 0x22A, F
1776  0CA9     RRF 0x229, F
1777  36AA     LSRF 0x22A, F
1778  0CA9     RRF 0x229, F
1779  36AA     LSRF 0x22A, F
177A  0CA9     RRF 0x229, F
177B  0829     MOVF 0x229, W
177C  02A7     SUBWF 0x227, F
177D  082A     MOVF 0x22A, W
177E  3BA8     SUBWFB 0x228, F
142:                           temp    = temp  >> 1;   output -= temp;
177F  36AA     LSRF 0x22A, F
1780  0CA9     RRF 0x229, F
1781  0829     MOVF 0x229, W
1782  02A7     SUBWF 0x227, F
1783  082A     MOVF 0x22A, W
1784  3BA8     SUBWFB 0x228, F
143:                                                   output += temp  >> 2;
1785  00A4     MOVWF 0x224
1786  0829     MOVF 0x229, W
1787  00A3     MOVWF 0x223
1788  36A4     LSRF 0x224, F
1789  0CA3     RRF 0x223, F
178A  36A4     LSRF 0x224, F
178B  0CA3     RRF 0x223, F
178C  0823     MOVF 0x223, W
178D  07A7     ADDWF 0x227, F
178E  0824     MOVF 0x224, W
178F  3DA8     ADDWFC 0x228, F
144:                           break;
1790  2FFB     GOTO 0x7FB
145:                       case 12:    /* output = value - (value >> 3) + (value >> 6) + (value >> 9) */
146:                                                   output += value;
1791  0821     MOVF 0x221, W
1792  07A7     ADDWF 0x227, F
1793  0822     MOVF 0x222, W
1794  3DA8     ADDWFC 0x228, F
147:                           temp    = value >> 3;   output -= temp;
1795  00AA     MOVWF 0x22A
1796  0821     MOVF 0x221, W
1797  00A9     MOVWF 0x229
1798  36AA     LSRF 0x22A, F
1799  0CA9     RRF 0x229, F
179A  36AA     LSRF 0x22A, F
179B  0CA9     RRF 0x229, F
179C  36AA     LSRF 0x22A, F
179D  0CA9     RRF 0x229, F
179E  0829     MOVF 0x229, W
179F  02A7     SUBWF 0x227, F
17A0  082A     MOVF 0x22A, W
17A1  3BA8     SUBWFB 0x228, F
17A2  2F43     GOTO 0x743
148:                           temp    = temp  >> 3;   output += temp;
149:                                                   output += temp  >> 3;
150:                           break;
151:                       case 13:    /* output = value - (value >> 4) + (value >> 7) - (value >> 10) */
152:                                                   output += value;
17A3  0821     MOVF 0x221, W
17A4  07A7     ADDWF 0x227, F
17A5  0822     MOVF 0x222, W
17A6  3DA8     ADDWFC 0x228, F
153:                           temp    = value >> 4;   output -= temp;
17A7  00AA     MOVWF 0x22A
17A8  0821     MOVF 0x221, W
17A9  00A9     MOVWF 0x229
17AA  300F     MOVLW 0xF
17AB  0EA9     SWAPF 0x229, F
17AC  0EAA     SWAPF 0x22A, F
17AD  05A9     ANDWF 0x229, F
17AE  082A     MOVF 0x22A, W
17AF  39F0     ANDLW 0xF0
17B0  04A9     IORWF 0x229, F
17B1  300F     MOVLW 0xF
17B2  05AA     ANDWF 0x22A, F
17B3  0829     MOVF 0x229, W
17B4  02A7     SUBWF 0x227, F
17B5  082A     MOVF 0x22A, W
17B6  3BA8     SUBWFB 0x228, F
154:                           temp    = temp  >> 3;   output += temp;
17B7  36AA     LSRF 0x22A, F
17B8  0CA9     RRF 0x229, F
17B9  36AA     LSRF 0x22A, F
17BA  0CA9     RRF 0x229, F
17BB  36AA     LSRF 0x22A, F
17BC  0CA9     RRF 0x229, F
17BD  0829     MOVF 0x229, W
17BE  07A7     ADDWF 0x227, F
17BF  082A     MOVF 0x22A, W
17C0  3DA8     ADDWFC 0x228, F
155:                                                   output -= temp  >> 3;
17C1  082A     MOVF 0x22A, W
17C2  00A4     MOVWF 0x224
17C3  0829     MOVF 0x229, W
17C4  00A3     MOVWF 0x223
17C5  36A4     LSRF 0x224, F
17C6  0CA3     RRF 0x223, F
17C7  36A4     LSRF 0x224, F
17C8  0CA3     RRF 0x223, F
17C9  36A4     LSRF 0x224, F
17CA  0CA3     RRF 0x223, F
17CB  0823     MOVF 0x223, W
17CC  02A7     SUBWF 0x227, F
17CD  0824     MOVF 0x224, W
17CE  3BA8     SUBWFB 0x228, F
156:                           break;
17CF  2FFB     GOTO 0x7FB
157:                       case 14:    /* output = value - (value >> 6) - (value >> 8) - (value >> 11) */
158:                                                   output += value;
17D0  0821     MOVF 0x221, W
17D1  07A7     ADDWF 0x227, F
17D2  0822     MOVF 0x222, W
17D3  3DA8     ADDWFC 0x228, F
159:                                                   output -= value >> 6;
17D4  00A4     MOVWF 0x224
17D5  0821     MOVF 0x221, W
17D6  00A3     MOVWF 0x223
17D7  3006     MOVLW 0x6
17D8  36A4     LSRF 0x224, F
17D9  0CA3     RRF 0x223, F
17DA  0B89     DECFSZ 0x209, F
17DB  2FD8     GOTO 0x7D8
17DC  0823     MOVF 0x223, W
17DD  02A7     SUBWF 0x227, F
17DE  0824     MOVF 0x224, W
17DF  3BA8     SUBWFB 0x228, F
160:                           temp    = value >> 8;   output -= temp;
17E0  0822     MOVF 0x222, W
17E1  00A9     MOVWF 0x229
17E2  01AA     CLRF 0x22A
17E3  0829     MOVF 0x229, W
17E4  02A7     SUBWF 0x227, F
17E5  082A     MOVF 0x22A, W
17E6  3BA8     SUBWFB 0x228, F
17E7  2FC1     GOTO 0x7C1
161:                                                   output -= temp  >> 3;
162:                           break;
163:                       case 15:    /* output = value - (value >> 9) - (value >> 12) */
164:                                                   output += value;
17E8  0821     MOVF 0x221, W
17E9  07A7     ADDWF 0x227, F
17EA  0822     MOVF 0x222, W
17EB  3DA8     ADDWFC 0x228, F
165:                           temp    = value >> 8;
17EC  00A9     MOVWF 0x229
17ED  01AA     CLRF 0x22A
166:                           temp    = temp  >> 1;   output -= temp;
17EE  36AA     LSRF 0x22A, F
17EF  0CA9     RRF 0x229, F
17F0  2FE3     GOTO 0x7E3
167:                                                   output -= temp  >> 3;
168:                           break;
169:                       default: break;
170:                   }
171:               #endif
172:               }
173:           #elif MTOUCH_SAMPLES == 24
174:               /* Final scaling amount: 12.50681 */
175:           
176:               if (i > (uint8_t)23)
177:               {
178:                   output = (uint16_t)0;
179:               }
180:               else
181:               {
182:                   if (i > (uint8_t)11)
183:                   {
184:                       i = (uint8_t)23 - i;
185:                   }
186:           
187:               #if 0
188:                   switch(i)
189:                   {
190:                       case 0:     output = (uint16_t)(          (value >> (uint8_t) 6)                                                    );  /* 0.015625    */ break;
191:                       case 1:     output = (uint16_t)(          (value >> (uint8_t) 4)  - (value >> (uint8_t)11)                          );  /* 0.062011719 */ break;
192:                       case 2:     output = (uint16_t)((         (value >> (uint8_t) 3)  + (value >> (uint8_t) 7)) + (value >> (uint8_t) 9));  /* 0.134765625 */ break;
193:                       case 3:     output = (uint16_t)((         (value >> (uint8_t) 2)  - (value >> (uint8_t) 6)) - (value >> (uint8_t) 9));  /* 0.232421875 */ break;
194:                       case 4:     output = (uint16_t)((         (value >> (uint8_t) 2)  + (value >> (uint8_t) 4)) + (value >> (uint8_t) 5));  /* 0.34375     */ break;
195:                       case 5:     output = (uint16_t)(          (value >> (uint8_t) 1)  - (value >> (uint8_t) 5)                          );  /* 0.46875     */ break;
196:                       case 6:     output = (uint16_t)((         (value >> (uint8_t) 1)  + (value >> (uint8_t) 4)) + (value >> (uint8_t) 5));  /* 0.59375     */ break;
197:                       case 7:     output = (uint16_t)((         (value >> (uint8_t) 1)  + (value >> (uint8_t) 2)) - (value >> (uint8_t) 5));  /* 0.71875     */ break;
198:                       case 8:     output = (uint16_t)(((value - (value >> (uint8_t) 3)) - (value >> (uint8_t) 4)) + (value >> (uint8_t) 8));  /* 0.81640625  */ break;
199:                       case 9:     output = (uint16_t)( (value - (value >> (uint8_t) 3)) + (value >> (uint8_t) 5)                          );  /* 0.90625     */ break;
200:                       case 10:    output = (uint16_t)( (value - (value >> (uint8_t) 5)) - (value >> (uint8_t) 8)                          );  /* 0.96484375  */ break;
201:                       case 11:    output = (uint16_t)(  value - (value >> (uint8_t) 8)                                                    );  /* 0.99609375  */ break;
202:                       default:    output = (uint16_t)0; break;
203:                   }
204:               #else
205:                   output = (uint16_t)0;
206:                   switch(i)
207:                   {
208:                       case 0:     /* output = (value >> 6) */
209:                           output = value >> 6;
210:                           break;
211:                       case 1:     /* output = (value >> 4) - (value >> 11) */
212:                                                   output  = value >> 4;
213:                           temp    = value >> 8;   output -= temp >> 3;
214:                           break;
215:                       case 2:     /* output = (value >> 3) + (value >> 7) + (value >> 9) */
216:                           temp    = value >> 3;   output += temp;
217:                           temp    = temp  >> 4;   output += temp;
218:                                                   output += temp >> 2;
219:                           break;
220:                       case 3:     /* output = (value >> 2) - (value >> 6) - (value >> 9) */
221:                           temp    = value >> 2;   output += temp;
222:                           temp    = temp  >> 4;   output -= temp;
223:                                                   output -= temp >> 3;
224:                           break;
225:                       case 4:     /* output = (value >> 2) + (value >> 4) + (value >> 5) */
226:                           temp    = value >> 2;   output += temp;
227:                           temp    = temp  >> 2;   output += temp;
228:                                                   output += temp  >> 1;
229:                           break;
230:                       case 5:     /* output = (value >> 1) - (value >> 5) */
231:                           temp    = value >> 1;   output += temp;
232:                                                   output -= temp  >> 4;
233:                           break;
234:                       case 6:     /* output = (value >> 1) - (value >> 4) + (value >> 5) */
235:                           temp    = value >> 1;   output += temp;
236:                           temp    = temp  >> 3;   output += temp;
237:                                                   output += temp  >> 1;
238:                           break;
239:                       case 7:     /* output = (value >> 1) + (value >> 2) - (value >> 5) */
240:                           temp    = value >> 1;   output += temp;
241:                           temp    = temp  >> 1;   output += temp;
242:                                                   output -= temp  >> 3;
243:                           break;
244:                       case 8:     /* output = value - (value >> 3) - (value >> 4) + (value >> 8) */
245:                                                   output += value;
246:                           temp    = value >> 3;   output -= temp;
247:                           temp    = temp  >> 1;   output -= temp;
248:                                                   output += value >> 8;
249:                           break;
250:                       case 9:     /* output = value - (value >> 3) + (value >> 5) */
251:                                                   output += value;
252:                           temp    = value >> 3;   output -= temp;
253:                                                   output += temp  >> 2;
254:                           break;
255:                       case 10:    /* output = value - (value >> 5) + (value >> 8) */
256:                                                   output += value;
257:                                                   output -= value >> 5;
258:                                                   output -= value >> 8;
259:                           break;
260:                       case 11:    /* output = value - (value >> 8) */
261:                                                   output += value;
262:                                                   output -= value >> 8;
263:                           break;
264:                       default: break;
265:                   }
266:               #endif
267:               }
268:           #else
269:           #error HAMMING option is invalid.
270:           #endif
271:           
272:               return output;
17FB  0828     MOVF 0x228, W
17FC  00A2     MOVWF 0x222
17FD  0827     MOVF 0x227, W
17FE  00A1     MOVWF 0x221
273:           }
17FF  0008     RETURN
---  /Applications/microchip/xc8/v1.33/sources/common/awdiv.c  ------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	signed int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0A9B  01A6     CLRF 0x226
15:            	if(divisor < 0) {
0A9C  1FA2     BTFSS 0x222, 0x7
0A9D  2AA5     GOTO 0x2A5
16:            		divisor = -divisor;
0A9E  09A1     COMF 0x221, F
0A9F  09A2     COMF 0x222, F
0AA0  0AA1     INCF 0x221, F
0AA1  1903     BTFSC 0x203, 0x2
0AA2  0AA2     INCF 0x222, F
17:            		sign = 1;
0AA3  01A6     CLRF 0x226
0AA4  0AA6     INCF 0x226, F
18:            	}
19:            	if(dividend < 0) {
0AA5  1FA4     BTFSS 0x224, 0x7
0AA6  2AAE     GOTO 0x2AE
20:            		dividend = -dividend;
0AA7  09A3     COMF 0x223, F
0AA8  09A4     COMF 0x224, F
0AA9  0AA3     INCF 0x223, F
0AAA  1903     BTFSC 0x203, 0x2
0AAB  0AA4     INCF 0x224, F
21:            		sign ^= 1;
0AAC  3001     MOVLW 0x1
0AAD  06A6     XORWF 0x226, F
22:            	}
23:            	quotient = 0;
0AAE  01A7     CLRF 0x227
0AAF  01A8     CLRF 0x228
24:            	if(divisor != 0) {
0AB0  0822     MOVF 0x222, W
0AB1  0421     IORWF 0x221, W
0AB2  1903     BTFSC 0x203, 0x2
0AB3  2ACE     GOTO 0x2CE
25:            		counter = 1;
0AB4  01A5     CLRF 0x225
26:            		while((divisor & 0x8000U) == 0) {
0AB6  1BA2     BTFSC 0x222, 0x7
0AB7  2ABB     GOTO 0x2BB
0ABA  2AB5     GOTO 0x2B5
27:            			divisor <<= 1;
0AB8  35A1     LSLF 0x221, F
0AB9  0DA2     RLF 0x222, F
28:            			counter++;
0AB5  0AA5     INCF 0x225, F
29:            		}
30:            		do {
31:            			quotient <<= 1;
0ABB  35A7     LSLF 0x227, F
0ABC  0DA8     RLF 0x228, F
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0ABD  0822     MOVF 0x222, W
0ABE  0224     SUBWF 0x224, W
0ABF  1D03     BTFSS 0x203, 0x2
0AC0  2AC3     GOTO 0x2C3
0AC1  0821     MOVF 0x221, W
0AC2  0223     SUBWF 0x223, W
0AC3  1C03     BTFSS 0x203, 0x0
0AC4  2ACA     GOTO 0x2CA
33:            				dividend -= divisor;
0AC5  0821     MOVF 0x221, W
0AC6  02A3     SUBWF 0x223, F
0AC7  0822     MOVF 0x222, W
0AC8  3BA4     SUBWFB 0x224, F
34:            				quotient |= 1;
0AC9  1427     BSF 0x227, 0x0
35:            			}
36:            			*(unsigned int *)&divisor >>= 1;
0ACA  36A2     LSRF 0x222, F
0ACB  0CA1     RRF 0x221, F
37:            		} while(--counter != 0);
0ACC  0BA5     DECFSZ 0x225, F
0ACD  2ABB     GOTO 0x2BB
38:            	}
39:            	if(sign)
0ACE  0826     MOVF 0x226, W
0ACF  1903     BTFSC 0x203, 0x2
0AD0  2AD6     GOTO 0x2D6
40:            		quotient = -quotient;
0AD1  09A7     COMF 0x227, F
0AD2  09A8     COMF 0x228, F
0AD3  0AA7     INCF 0x227, F
0AD4  1903     BTFSC 0x203, 0x2
0AD5  0AA8     INCF 0x228, F
41:            	return quotient;
0AD6  0828     MOVF 0x228, W
0AD7  00A2     MOVWF 0x222
0AD8  0827     MOVF 0x227, W
0AD9  00A1     MOVWF 0x221
42:            }
0ADA  0008     RETURN
---  /Applications/microchip/xc8/v1.33/sources/common/aldiv.c  ------------------------------------------
1:             // long signed unsigned division
2:             
3:             signed long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __aldiv(signed long int divisor, signed long int dividend)
7:             #else
8:             __aldiv(signed long int dividend, signed long int divisor)
9:             #endif
10:            {
11:            	signed long int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0B55  01AA     CLRF 0x22A
15:            	if(divisor < 0) {
0B56  1FA4     BTFSS 0x224, 0x7
0B57  2B65     GOTO 0x365
16:            		divisor = -divisor;
0B58  09A1     COMF 0x221, F
0B59  09A2     COMF 0x222, F
0B5A  09A3     COMF 0x223, F
0B5B  09A4     COMF 0x224, F
0B5C  0AA1     INCF 0x221, F
0B5D  1903     BTFSC 0x203, 0x2
0B5E  0AA2     INCF 0x222, F
0B5F  1903     BTFSC 0x203, 0x2
0B60  0AA3     INCF 0x223, F
0B61  1903     BTFSC 0x203, 0x2
0B62  0AA4     INCF 0x224, F
17:            		sign = 1;
0B63  01AA     CLRF 0x22A
0B64  0AAA     INCF 0x22A, F
18:            	}
19:            	if(dividend < 0) {
0B65  1FA8     BTFSS 0x228, 0x7
0B66  2B74     GOTO 0x374
20:            		dividend = -dividend;
0B67  09A5     COMF 0x225, F
0B68  09A6     COMF 0x226, F
0B69  09A7     COMF 0x227, F
0B6A  09A8     COMF 0x228, F
0B6B  0AA5     INCF 0x225, F
0B6C  1903     BTFSC 0x203, 0x2
0B6D  0AA6     INCF 0x226, F
0B6E  1903     BTFSC 0x203, 0x2
0B6F  0AA7     INCF 0x227, F
0B70  1903     BTFSC 0x203, 0x2
0B71  0AA8     INCF 0x228, F
21:            		sign ^= 1;
0B72  3001     MOVLW 0x1
0B73  06AA     XORWF 0x22A, F
22:            	}
23:            	quotient = 0;
0B74  01AB     CLRF 0x22B
0B75  01AC     CLRF 0x22C
0B76  01AD     CLRF 0x22D
0B77  01AE     CLRF 0x22E
24:            	if(divisor != 0) {
0B78  0824     MOVF 0x224, W
0B79  0423     IORWF 0x223, W
0B7A  0422     IORWF 0x222, W
0B7B  0421     IORWF 0x221, W
0B7C  1903     BTFSC 0x203, 0x2
0B7D  2BAA     GOTO 0x3AA
25:            		counter = 1;
0B7E  01A9     CLRF 0x229
26:            		while((divisor & 0x80000000UL) == 0) {
0B80  1BA4     BTFSC 0x224, 0x7
0B81  2B87     GOTO 0x387
0B86  2B7F     GOTO 0x37F
27:            			divisor <<= 1;
0B82  35A1     LSLF 0x221, F
0B83  0DA2     RLF 0x222, F
0B84  0DA3     RLF 0x223, F
0B85  0DA4     RLF 0x224, F
28:            			counter++;
0B7F  0AA9     INCF 0x229, F
29:            		}
30:            		do {
31:            			quotient <<= 1;
0B87  35AB     LSLF 0x22B, F
0B88  0DAC     RLF 0x22C, F
0B89  0DAD     RLF 0x22D, F
0B8A  0DAE     RLF 0x22E, F
32:            			if((unsigned long)divisor <= (unsigned long)dividend) {
0B8B  0824     MOVF 0x224, W
0B8C  0228     SUBWF 0x228, W
0B8D  1D03     BTFSS 0x203, 0x2
0B8E  2B99     GOTO 0x399
0B8F  0823     MOVF 0x223, W
0B90  0227     SUBWF 0x227, W
0B91  1D03     BTFSS 0x203, 0x2
0B92  2B99     GOTO 0x399
0B93  0822     MOVF 0x222, W
0B94  0226     SUBWF 0x226, W
0B95  1D03     BTFSS 0x203, 0x2
0B96  2B99     GOTO 0x399
0B97  0821     MOVF 0x221, W
0B98  0225     SUBWF 0x225, W
0B99  1C03     BTFSS 0x203, 0x0
0B9A  2BA4     GOTO 0x3A4
33:            				dividend -= divisor;
0B9B  0821     MOVF 0x221, W
0B9C  02A5     SUBWF 0x225, F
0B9D  0822     MOVF 0x222, W
0B9E  3BA6     SUBWFB 0x226, F
0B9F  0823     MOVF 0x223, W
0BA0  3BA7     SUBWFB 0x227, F
0BA1  0824     MOVF 0x224, W
0BA2  3BA8     SUBWFB 0x228, F
34:            				quotient |= 1;
0BA3  142B     BSF 0x22B, 0x0
35:            			}
36:            			*(unsigned long int *)&divisor >>= 1;
0BA4  36A4     LSRF 0x224, F
0BA5  0CA3     RRF 0x223, F
0BA6  0CA2     RRF 0x222, F
0BA7  0CA1     RRF 0x221, F
37:            		} while(--counter != 0);
0BA8  0BA9     DECFSZ 0x229, F
0BA9  2B87     GOTO 0x387
38:            	}
39:            	if(sign)
0BAA  082A     MOVF 0x22A, W
0BAB  1903     BTFSC 0x203, 0x2
0BAC  2BB8     GOTO 0x3B8
40:            		quotient = -quotient;
0BAD  09AB     COMF 0x22B, F
0BAE  09AC     COMF 0x22C, F
0BAF  09AD     COMF 0x22D, F
0BB0  09AE     COMF 0x22E, F
0BB1  0AAB     INCF 0x22B, F
0BB2  1903     BTFSC 0x203, 0x2
0BB3  0AAC     INCF 0x22C, F
0BB4  1903     BTFSC 0x203, 0x2
0BB5  0AAD     INCF 0x22D, F
0BB6  1903     BTFSC 0x203, 0x2
0BB7  0AAE     INCF 0x22E, F
41:            	return quotient;
0BB8  082E     MOVF 0x22E, W
0BB9  00A4     MOVWF 0x224
0BBA  082D     MOVF 0x22D, W
0BBB  00A3     MOVWF 0x223
0BBC  082C     MOVF 0x22C, W
0BBD  00A2     MOVWF 0x222
0BBE  082B     MOVF 0x22B, W
0BBF  00A1     MOVWF 0x221
42:            }
0BC0  0008     RETURN
---  /Applications/microchip/xc8/v1.33/sources/common/Umul16.c  -----------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
06EC  01A5     CLRF 0x225
06ED  01A6     CLRF 0x226
44:            	do {
45:            		if(multiplier & 1)
06EE  1C21     BTFSS 0x221, 0x0
06EF  2EF4     GOTO 0x6F4
46:            			product += multiplicand;
06F0  0823     MOVF 0x223, W
06F1  07A5     ADDWF 0x225, F
06F2  0824     MOVF 0x224, W
06F3  3DA6     ADDWFC 0x226, F
47:            		multiplicand <<= 1;
06F4  35A3     LSLF 0x223, F
06F5  0DA4     RLF 0x224, F
48:            		multiplier >>= 1;
06F6  36A2     LSRF 0x222, F
06F7  0CA1     RRF 0x221, F
49:            	} while(multiplier != 0);
06F8  0822     MOVF 0x222, W
06F9  0421     IORWF 0x221, W
06FA  1D03     BTFSS 0x203, 0x2
06FB  2EEE     GOTO 0x6EE
50:            
51:            #endif
52:                    return product;
06FC  0826     MOVF 0x226, W
06FD  00A2     MOVWF 0x222
06FE  0825     MOVF 0x225, W
06FF  00A1     MOVWF 0x221
53:            }
0700  0008     RETURN
